#include <pybind11/pybind11.h>
namespace py = pybind11;

#include <Standard_Handle.hxx>
PYBIND11_DECLARE_HOLDER_TYPE(T, opencascade::handle<T>, true);
PYBIND11_DECLARE_HOLDER_TYPE(T, T*);
using opencascade::handle;

// Deleter template for mixed holder types with public/hidden destructors.
template<typename T> struct Deleter { void operator() (T *o) const { delete o; } };

#include <Standard_Handle.hxx>
#include <NCollection_BaseAllocator.hxx>
#include <BOPCol_ListOfShape.hxx>
#include <Standard_TypeDef.hxx>
#include <BOPTools_ConnexityBlock.hxx>
#include <NCollection_BaseList.hxx>
#include <NCollection_List.hxx>
#include <BOPTools_ListOfConnexityBlock.hxx>
#include <BOPCol_BaseAllocator.hxx>
#include <TopoDS_Shape.hxx>
#include <TopAbs_ShapeEnum.hxx>
#include <TopoDS_Edge.hxx>
#include <BOPTools_ShapeSet.hxx>
#include <BOPTools_EdgeSet.hxx>
#include <TopoDS_Vertex.hxx>
#include <gp_Pnt.hxx>
#include <IntTools_Curve.hxx>
#include <TopoDS_Face.hxx>
#include <IntTools_Context.hxx>
#include <BOPTools_ListOfCoupleOfShape.hxx>
#include <TopoDS_Solid.hxx>
#include <BOPCol_IndexedDataMapOfShapeListOfShape.hxx>
#include <TopAbs_State.hxx>
#include <BOPCol_IndexedMapOfShape.hxx>
#include <IntTools_Range.hxx>
#include <TopoDS_Shell.hxx>
#include <BOPTools_AlgoTools.hxx>
#include <BOPTools_Set.hxx>
#include <BOPTools_SetMapHasher.hxx>
#include <gp_Vec.hxx>
#include <Geom2d_Curve.hxx>
#include <Geom_Curve.hxx>
#include <BRepAdaptor_Surface.hxx>
#include <BOPTools_AlgoTools2D.hxx>
#include <gp_Dir.hxx>
#include <Geom_Surface.hxx>
#include <gp_Pnt2d.hxx>
#include <BOPTools_AlgoTools3D.hxx>
#include <BOPCol_MapOfShape.hxx>
#include <BOPTools.hxx>
#include <BOPTools_CoupleOfShape.hxx>
#include <NCollection_BaseMap.hxx>
#include <NCollection_DataMap.hxx>
#include <BOPTools_DataMapOfShapeSet.hxx>
#include <BOPTools_ListOfEdgeSet.hxx>
#include <BOPTools_ListOfShapeSet.hxx>
#include <NCollection_Map.hxx>
#include <BOPTools_MapOfSet.hxx>

PYBIND11_MODULE(BOPTools, mod) {

	// IMPORT
	py::module::import("OCCT.Standard");
	py::module::import("OCCT.NCollection");
	py::module::import("OCCT.BOPCol");
	py::module::import("OCCT.TopoDS");
	py::module::import("OCCT.TopAbs");
	py::module::import("OCCT.gp");
	py::module::import("OCCT.IntTools");
	py::module::import("OCCT.Geom2d");
	py::module::import("OCCT.Geom");
	py::module::import("OCCT.BRepAdaptor");

	py::module other_mod;

	// IMPORT GUARDS

	// ENUMS

	// FUNCTIONS

	// CLASSES
	// C:\Miniconda\envs\occt\Library\include\opencascade\BOPTools_ConnexityBlock.hxx
	py::class_<BOPTools_ConnexityBlock, std::unique_ptr<BOPTools_ConnexityBlock, Deleter<BOPTools_ConnexityBlock>>> cls_BOPTools_ConnexityBlock(mod, "BOPTools_ConnexityBlock", "None");
	cls_BOPTools_ConnexityBlock.def(py::init<>());
	cls_BOPTools_ConnexityBlock.def(py::init<const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("theAllocator"));
	cls_BOPTools_ConnexityBlock.def("Shapes", (const BOPCol_ListOfShape & (BOPTools_ConnexityBlock::*)() const ) &BOPTools_ConnexityBlock::Shapes, "None");
	cls_BOPTools_ConnexityBlock.def("ChangeShapes", (BOPCol_ListOfShape & (BOPTools_ConnexityBlock::*)()) &BOPTools_ConnexityBlock::ChangeShapes, "None");
	cls_BOPTools_ConnexityBlock.def("SetRegular", (void (BOPTools_ConnexityBlock::*)(const Standard_Boolean)) &BOPTools_ConnexityBlock::SetRegular, "None", py::arg("theFlag"));
	cls_BOPTools_ConnexityBlock.def("IsRegular", (Standard_Boolean (BOPTools_ConnexityBlock::*)() const ) &BOPTools_ConnexityBlock::IsRegular, "None");
	cls_BOPTools_ConnexityBlock.def("Loops", (const BOPCol_ListOfShape & (BOPTools_ConnexityBlock::*)() const ) &BOPTools_ConnexityBlock::Loops, "None");
	cls_BOPTools_ConnexityBlock.def("ChangeLoops", (BOPCol_ListOfShape & (BOPTools_ConnexityBlock::*)()) &BOPTools_ConnexityBlock::ChangeLoops, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\BOPTools_ShapeSet.hxx
	py::class_<BOPTools_ShapeSet, std::unique_ptr<BOPTools_ShapeSet, Deleter<BOPTools_ShapeSet>>> cls_BOPTools_ShapeSet(mod, "BOPTools_ShapeSet", "Implementation of some formal opereations with a set of shapes");
	cls_BOPTools_ShapeSet.def(py::init<>());
	cls_BOPTools_ShapeSet.def(py::init<const BOPCol_BaseAllocator &>(), py::arg("theAllocator"));
	cls_BOPTools_ShapeSet.def("SetShape", (void (BOPTools_ShapeSet::*)(const TopoDS_Shape &)) &BOPTools_ShapeSet::SetShape, "None", py::arg("theS"));
	cls_BOPTools_ShapeSet.def("Shape", (const TopoDS_Shape & (BOPTools_ShapeSet::*)() const ) &BOPTools_ShapeSet::Shape, "None");
	cls_BOPTools_ShapeSet.def("Add", (void (BOPTools_ShapeSet::*)(const BOPCol_ListOfShape &)) &BOPTools_ShapeSet::Add, "None", py::arg("theLS"));
	cls_BOPTools_ShapeSet.def("Add", (void (BOPTools_ShapeSet::*)(const TopoDS_Shape &)) &BOPTools_ShapeSet::Add, "None", py::arg("theShape"));
	cls_BOPTools_ShapeSet.def("Add", (void (BOPTools_ShapeSet::*)(const TopoDS_Shape &, const TopAbs_ShapeEnum)) &BOPTools_ShapeSet::Add, "None", py::arg("theShape"), py::arg("theType"));
	cls_BOPTools_ShapeSet.def("AddEdge", (void (BOPTools_ShapeSet::*)(const TopoDS_Edge &)) &BOPTools_ShapeSet::AddEdge, "None", py::arg("theEdge"));
	cls_BOPTools_ShapeSet.def("AddEdges", (void (BOPTools_ShapeSet::*)(const BOPCol_ListOfShape &)) &BOPTools_ShapeSet::AddEdges, "None", py::arg("theLS"));
	cls_BOPTools_ShapeSet.def("AddEdges", (void (BOPTools_ShapeSet::*)(const TopoDS_Shape &)) &BOPTools_ShapeSet::AddEdges, "None", py::arg("theFace"));
	cls_BOPTools_ShapeSet.def("Subtract", (void (BOPTools_ShapeSet::*)(const BOPTools_ShapeSet &)) &BOPTools_ShapeSet::Subtract, "None", py::arg("theSet"));
	cls_BOPTools_ShapeSet.def("__isub__", (void (BOPTools_ShapeSet::*)(const BOPTools_ShapeSet &)) &BOPTools_ShapeSet::operator-=, "None", py::arg("theSet"));
	cls_BOPTools_ShapeSet.def("Clear", (void (BOPTools_ShapeSet::*)()) &BOPTools_ShapeSet::Clear, "None");
	cls_BOPTools_ShapeSet.def("Get", (void (BOPTools_ShapeSet::*)(BOPCol_ListOfShape &) const ) &BOPTools_ShapeSet::Get, "None", py::arg("theLS"));
	cls_BOPTools_ShapeSet.def("Contains", (Standard_Boolean (BOPTools_ShapeSet::*)(const BOPTools_ShapeSet &) const ) &BOPTools_ShapeSet::Contains, "None", py::arg("theSet"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\BOPTools_EdgeSet.hxx
	py::class_<BOPTools_EdgeSet, std::unique_ptr<BOPTools_EdgeSet, Deleter<BOPTools_EdgeSet>>> cls_BOPTools_EdgeSet(mod, "BOPTools_EdgeSet", "None");
	cls_BOPTools_EdgeSet.def(py::init<>());
	cls_BOPTools_EdgeSet.def(py::init<const BOPCol_BaseAllocator &>(), py::arg("theAllocator"));
	cls_BOPTools_EdgeSet.def("SetShape", (void (BOPTools_EdgeSet::*)(const TopoDS_Shape &)) &BOPTools_EdgeSet::SetShape, "None", py::arg("theS"));
	cls_BOPTools_EdgeSet.def("Shape", (const TopoDS_Shape & (BOPTools_EdgeSet::*)() const ) &BOPTools_EdgeSet::Shape, "None");
	cls_BOPTools_EdgeSet.def("AddEdge", (void (BOPTools_EdgeSet::*)(const TopoDS_Edge &)) &BOPTools_EdgeSet::AddEdge, "None", py::arg("theEdge"));
	cls_BOPTools_EdgeSet.def("AddEdges", (void (BOPTools_EdgeSet::*)(const BOPCol_ListOfShape &)) &BOPTools_EdgeSet::AddEdges, "None", py::arg("theLS"));
	cls_BOPTools_EdgeSet.def("AddEdges", (void (BOPTools_EdgeSet::*)(const TopoDS_Shape &)) &BOPTools_EdgeSet::AddEdges, "None", py::arg("theFace"));
	cls_BOPTools_EdgeSet.def("Clear", (void (BOPTools_EdgeSet::*)()) &BOPTools_EdgeSet::Clear, "None");
	cls_BOPTools_EdgeSet.def("Get", (void (BOPTools_EdgeSet::*)(BOPCol_ListOfShape &) const ) &BOPTools_EdgeSet::Get, "None", py::arg("theLS"));
	cls_BOPTools_EdgeSet.def("Contains", (Standard_Boolean (BOPTools_EdgeSet::*)(const BOPTools_EdgeSet &) const ) &BOPTools_EdgeSet::Contains, "None", py::arg("theSet"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\BOPTools_AlgoTools.hxx
	py::class_<BOPTools_AlgoTools, std::unique_ptr<BOPTools_AlgoTools, Deleter<BOPTools_AlgoTools>>> cls_BOPTools_AlgoTools(mod, "BOPTools_AlgoTools", "None");
	cls_BOPTools_AlgoTools.def(py::init<>());
	cls_BOPTools_AlgoTools.def_static("ComputeVV_", (Standard_Integer (*)(const TopoDS_Vertex &, const gp_Pnt &, const Standard_Real)) &BOPTools_AlgoTools::ComputeVV, "None", py::arg("aV1"), py::arg("aP2"), py::arg("aTolP2"));
	cls_BOPTools_AlgoTools.def_static("ComputeVV_", [](const TopoDS_Vertex & a0, const TopoDS_Vertex & a1) -> Standard_Integer { return BOPTools_AlgoTools::ComputeVV(a0, a1); }, py::arg("aV1"), py::arg("aV2"));
	cls_BOPTools_AlgoTools.def_static("ComputeVV_", (Standard_Integer (*)(const TopoDS_Vertex &, const TopoDS_Vertex &, const Standard_Real)) &BOPTools_AlgoTools::ComputeVV, "None", py::arg("aV1"), py::arg("aV2"), py::arg("theFuzz"));
	cls_BOPTools_AlgoTools.def_static("MakeVertex_", (void (*)(const BOPCol_ListOfShape &, TopoDS_Vertex &)) &BOPTools_AlgoTools::MakeVertex, "None", py::arg("aLV"), py::arg("aV"));
	cls_BOPTools_AlgoTools.def_static("MakeEdge_", (void (*)(const IntTools_Curve &, const TopoDS_Vertex &, const Standard_Real, const TopoDS_Vertex &, const Standard_Real, const Standard_Real, TopoDS_Edge &)) &BOPTools_AlgoTools::MakeEdge, "None", py::arg("theCurve"), py::arg("theV1"), py::arg("theT1"), py::arg("theV2"), py::arg("theT2"), py::arg("theTolR3D"), py::arg("theE"));
	cls_BOPTools_AlgoTools.def_static("MakePCurve_", [](const TopoDS_Edge & a0, const TopoDS_Face & a1, const TopoDS_Face & a2, const IntTools_Curve & a3, const Standard_Boolean a4, const Standard_Boolean a5) -> void { return BOPTools_AlgoTools::MakePCurve(a0, a1, a2, a3, a4, a5); }, py::arg("theE"), py::arg("theF1"), py::arg("theF2"), py::arg("theCurve"), py::arg("thePC1"), py::arg("thePC2"));
	cls_BOPTools_AlgoTools.def_static("MakePCurve_", (void (*)(const TopoDS_Edge &, const TopoDS_Face &, const TopoDS_Face &, const IntTools_Curve &, const Standard_Boolean, const Standard_Boolean, const opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools::MakePCurve, "Makes 2d curve of the edge <theE> on the faces <theF1> and <theF2>. <theContext> - storage for caching the geometrical tools", py::arg("theE"), py::arg("theF1"), py::arg("theF2"), py::arg("theCurve"), py::arg("thePC1"), py::arg("thePC2"), py::arg("theContext"));
	cls_BOPTools_AlgoTools.def_static("MakeContainer_", (void (*)(const TopAbs_ShapeEnum, TopoDS_Shape &)) &BOPTools_AlgoTools::MakeContainer, "None", py::arg("theType"), py::arg("theShape"));
	cls_BOPTools_AlgoTools.def_static("IsHole_", (Standard_Boolean (*)(const TopoDS_Shape &, const TopoDS_Shape &)) &BOPTools_AlgoTools::IsHole, "None", py::arg("aW"), py::arg("aF"));
	cls_BOPTools_AlgoTools.def_static("IsSplitToReverse_", (Standard_Boolean (*)(const TopoDS_Shape &, const TopoDS_Shape &, opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools::IsSplitToReverse, "Returns True if the shape theSplit has opposite direction than theShape theContext - cashed geometrical tools", py::arg("theSplit"), py::arg("theShape"), py::arg("theContext"));
	cls_BOPTools_AlgoTools.def_static("IsSplitToReverse_", (Standard_Boolean (*)(const TopoDS_Face &, const TopoDS_Face &, opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools::IsSplitToReverse, "Returns True if normal direction of the face theShape is not the same as for the face theSplit theContext - cashed geometrical tools", py::arg("theSplit"), py::arg("theShape"), py::arg("theContext"));
	cls_BOPTools_AlgoTools.def_static("IsSplitToReverse_", (Standard_Boolean (*)(const TopoDS_Edge &, const TopoDS_Edge &, opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools::IsSplitToReverse, "None", py::arg("aE1"), py::arg("aE2"), py::arg("aContext"));
	cls_BOPTools_AlgoTools.def_static("AreFacesSameDomain_", [](const TopoDS_Face & a0, const TopoDS_Face & a1, opencascade::handle<IntTools_Context> & a2) -> Standard_Boolean { return BOPTools_AlgoTools::AreFacesSameDomain(a0, a1, a2); }, py::arg("theF1"), py::arg("theF2"), py::arg("theContext"));
	cls_BOPTools_AlgoTools.def_static("AreFacesSameDomain_", (Standard_Boolean (*)(const TopoDS_Face &, const TopoDS_Face &, opencascade::handle<IntTools_Context> &, const Standard_Real)) &BOPTools_AlgoTools::AreFacesSameDomain, "None", py::arg("theF1"), py::arg("theF2"), py::arg("theContext"), py::arg("theFuzz"));
	cls_BOPTools_AlgoTools.def_static("CheckSameGeom_", (Standard_Boolean (*)(const TopoDS_Face &, const TopoDS_Face &, opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools::CheckSameGeom, "None", py::arg("theF1"), py::arg("theF2"), py::arg("theContext"));
	cls_BOPTools_AlgoTools.def_static("Sense_", [](const TopoDS_Face & a0, const TopoDS_Face & a1) -> Standard_Integer { return BOPTools_AlgoTools::Sense(a0, a1); }, py::arg("theF1"), py::arg("theF2"));
	cls_BOPTools_AlgoTools.def_static("Sense_", (Standard_Integer (*)(const TopoDS_Face &, const TopoDS_Face &, const opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools::Sense, "Basing on the normals directions of the faces the method Defines whether to reverse the second face or not. <theContext> - storage for caching the geometrical tools", py::arg("theF1"), py::arg("theF2"), py::arg("theContext"));
	cls_BOPTools_AlgoTools.def_static("GetEdgeOff_", (Standard_Boolean (*)(const TopoDS_Edge &, const TopoDS_Face &, TopoDS_Edge &)) &BOPTools_AlgoTools::GetEdgeOff, "Returns True if the face theFace contains the edge theEdge but with opposite orientation. If the method returns True theEdgeOff is the edge founded", py::arg("theEdge"), py::arg("theFace"), py::arg("theEdgeOff"));
	cls_BOPTools_AlgoTools.def_static("GetFaceOff_", (Standard_Boolean (*)(const TopoDS_Edge &, const TopoDS_Face &, BOPTools_ListOfCoupleOfShape &, TopoDS_Face &, opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools::GetFaceOff, "For the face theFace and its edge theEdge finds the face suitable to produce shell. theLCEF - set of faces to search. All faces from theLCEF must share edge theEdge", py::arg("theEdge"), py::arg("theFace"), py::arg("theLCEF"), py::arg("theFaceOff"), py::arg("theContext"));
	cls_BOPTools_AlgoTools.def_static("IsInternalFace_", (Standard_Integer (*)(const TopoDS_Face &, const TopoDS_Edge &, const TopoDS_Face &, const TopoDS_Face &, opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools::IsInternalFace, "Returns True if the face theFace is inside of the couple of faces theFace1, theFace2. The faces theFace, theFace1, theFace2 must share the edge theEdge Return values: * 0 state is not IN * 1 state is IN * 2 state can not be found by the method of angles", py::arg("theFace"), py::arg("theEdge"), py::arg("theFace1"), py::arg("theFace2"), py::arg("theContext"));
	cls_BOPTools_AlgoTools.def_static("IsInternalFace_", (Standard_Integer (*)(const TopoDS_Face &, const TopoDS_Edge &, BOPCol_ListOfShape &, opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools::IsInternalFace, "Returns True if the face theFace is inside of the appropriate couple of faces (from the set theLF) . The faces of the set theLF and theFace must share the edge theEdge * 0 state is not IN * 1 state is IN * 2 state can not be found by the method of angles", py::arg("theFace"), py::arg("theEdge"), py::arg("theLF"), py::arg("theContext"));
	cls_BOPTools_AlgoTools.def_static("IsInternalFace_", (Standard_Boolean (*)(const TopoDS_Face &, const TopoDS_Solid &, BOPCol_IndexedDataMapOfShapeListOfShape &, const Standard_Real, opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools::IsInternalFace, "Returns True if the face theFace is inside the solid theSolid. theMEF - Map Edge/Faces for theSolid theTol - value of precision of computation theContext- cahed geometrical tools", py::arg("theFace"), py::arg("theSolid"), py::arg("theMEF"), py::arg("theTol"), py::arg("theContext"));
	cls_BOPTools_AlgoTools.def_static("GetEdgeOnFace_", (Standard_Boolean (*)(const TopoDS_Edge &, const TopoDS_Face &, TopoDS_Edge &)) &BOPTools_AlgoTools::GetEdgeOnFace, "For the face theFace gets the edge theEdgeOnF that is the same as theEdge Returns True if such edge exists Returns False if there is no such edge", py::arg("theEdge"), py::arg("theFace"), py::arg("theEdgeOnF"));
	cls_BOPTools_AlgoTools.def_static("ComputeState_", (TopAbs_State (*)(const gp_Pnt &, const TopoDS_Solid &, const Standard_Real, opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools::ComputeState, "Computes the 3-D state of the point thePoint toward solid theSolid. theTol - value of precision of computation theContext- cahed geometrical tools Returns 3-D state.", py::arg("thePoint"), py::arg("theSolid"), py::arg("theTol"), py::arg("theContext"));
	cls_BOPTools_AlgoTools.def_static("ComputeState_", (TopAbs_State (*)(const TopoDS_Vertex &, const TopoDS_Solid &, const Standard_Real, opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools::ComputeState, "Computes the 3-D state of the vertex theVertex toward solid theSolid. theTol - value of precision of computation theContext- cahed geometrical tools Returns 3-D state.", py::arg("theVertex"), py::arg("theSolid"), py::arg("theTol"), py::arg("theContext"));
	cls_BOPTools_AlgoTools.def_static("ComputeState_", (TopAbs_State (*)(const TopoDS_Edge &, const TopoDS_Solid &, const Standard_Real, opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools::ComputeState, "Computes the 3-D state of the edge theEdge toward solid theSolid. theTol - value of precision of computation theContext- cahed geometrical tools Returns 3-D state.", py::arg("theEdge"), py::arg("theSolid"), py::arg("theTol"), py::arg("theContext"));
	cls_BOPTools_AlgoTools.def_static("ComputeState_", (TopAbs_State (*)(const TopoDS_Face &, const TopoDS_Solid &, const Standard_Real, BOPCol_IndexedMapOfShape &, opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools::ComputeState, "Computes the 3-D state of the face theFace toward solid theSolid. theTol - value of precision of computation theBounds - set of edges of theFace to avoid theContext- cahed geometrical tools Returns 3-D state.", py::arg("theFace"), py::arg("theSolid"), py::arg("theTol"), py::arg("theBounds"), py::arg("theContext"));
	cls_BOPTools_AlgoTools.def_static("ComputeStateByOnePoint_", (TopAbs_State (*)(const TopoDS_Shape &, const TopoDS_Solid &, const Standard_Real, opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools::ComputeStateByOnePoint, "Computes the 3-D state of the shape theShape toward solid theSolid. theTol - value of precision of computation theContext- cahed geometrical tools Returns 3-D state.", py::arg("theShape"), py::arg("theSolid"), py::arg("theTol"), py::arg("theContext"));
	cls_BOPTools_AlgoTools.def_static("MakeConnexityBlock_", (void (*)(BOPCol_ListOfShape &, BOPCol_IndexedMapOfShape &, BOPCol_ListOfShape &, const BOPCol_BaseAllocator &)) &BOPTools_AlgoTools::MakeConnexityBlock, "For the list of faces theLS build block theLSCB in terms of connexity by edges theMapAvoid - set of edges to avoid for the treatment", py::arg("theLS"), py::arg("theMapAvoid"), py::arg("theLSCB"), py::arg("theAllocator"));
	cls_BOPTools_AlgoTools.def_static("MakeConnexityBlocks_", (void (*)(const TopoDS_Shape &, const TopAbs_ShapeEnum, const TopAbs_ShapeEnum, BOPCol_ListOfShape &)) &BOPTools_AlgoTools::MakeConnexityBlocks, "For the compound theS build the blocks theLCB (as list of compounds) in terms of connexity by the shapes of theType", py::arg("theS"), py::arg("theType1"), py::arg("theType2"), py::arg("theLCB"));
	cls_BOPTools_AlgoTools.def_static("OrientEdgesOnWire_", (void (*)(TopoDS_Shape &)) &BOPTools_AlgoTools::OrientEdgesOnWire, "Correctly orients edges on the wire", py::arg("theWire"));
	cls_BOPTools_AlgoTools.def_static("OrientFacesOnShell_", (void (*)(TopoDS_Shape &)) &BOPTools_AlgoTools::OrientFacesOnShell, "Correctly orients faces on the shell", py::arg("theShell"));
	cls_BOPTools_AlgoTools.def_static("CorrectTolerances_", [](const TopoDS_Shape & a0, const BOPCol_IndexedMapOfShape & a1) -> void { return BOPTools_AlgoTools::CorrectTolerances(a0, a1); }, py::arg("theS"), py::arg("theMapToAvoid"));
	cls_BOPTools_AlgoTools.def_static("CorrectTolerances_", [](const TopoDS_Shape & a0, const BOPCol_IndexedMapOfShape & a1, const Standard_Real a2) -> void { return BOPTools_AlgoTools::CorrectTolerances(a0, a1, a2); }, py::arg("theS"), py::arg("theMapToAvoid"), py::arg("theTolMax"));
	cls_BOPTools_AlgoTools.def_static("CorrectTolerances_", (void (*)(const TopoDS_Shape &, const BOPCol_IndexedMapOfShape &, const Standard_Real, const Standard_Boolean)) &BOPTools_AlgoTools::CorrectTolerances, "Provides valid values of tolerances for the shape <theS> <theTolMax> is max value of the tolerance that can be accepted for correction. If real value of the tolerance will be greater than <aTolMax>, the correction does not perform.", py::arg("theS"), py::arg("theMapToAvoid"), py::arg("theTolMax"), py::arg("theRunParallel"));
	cls_BOPTools_AlgoTools.def_static("CorrectCurveOnSurface_", [](const TopoDS_Shape & a0, const BOPCol_IndexedMapOfShape & a1) -> void { return BOPTools_AlgoTools::CorrectCurveOnSurface(a0, a1); }, py::arg("theS"), py::arg("theMapToAvoid"));
	cls_BOPTools_AlgoTools.def_static("CorrectCurveOnSurface_", [](const TopoDS_Shape & a0, const BOPCol_IndexedMapOfShape & a1, const Standard_Real a2) -> void { return BOPTools_AlgoTools::CorrectCurveOnSurface(a0, a1, a2); }, py::arg("theS"), py::arg("theMapToAvoid"), py::arg("theTolMax"));
	cls_BOPTools_AlgoTools.def_static("CorrectCurveOnSurface_", (void (*)(const TopoDS_Shape &, const BOPCol_IndexedMapOfShape &, const Standard_Real, const Standard_Boolean)) &BOPTools_AlgoTools::CorrectCurveOnSurface, "Provides valid values of tolerances for the shape <theS> in terms of BRepCheck_InvalidCurveOnSurface.", py::arg("theS"), py::arg("theMapToAvoid"), py::arg("theTolMax"), py::arg("theRunParallel"));
	cls_BOPTools_AlgoTools.def_static("CorrectPointOnCurve_", [](const TopoDS_Shape & a0, const BOPCol_IndexedMapOfShape & a1) -> void { return BOPTools_AlgoTools::CorrectPointOnCurve(a0, a1); }, py::arg("theS"), py::arg("theMapToAvoid"));
	cls_BOPTools_AlgoTools.def_static("CorrectPointOnCurve_", [](const TopoDS_Shape & a0, const BOPCol_IndexedMapOfShape & a1, const Standard_Real a2) -> void { return BOPTools_AlgoTools::CorrectPointOnCurve(a0, a1, a2); }, py::arg("theS"), py::arg("theMapToAvoid"), py::arg("theTolMax"));
	cls_BOPTools_AlgoTools.def_static("CorrectPointOnCurve_", (void (*)(const TopoDS_Shape &, const BOPCol_IndexedMapOfShape &, const Standard_Real, const Standard_Boolean)) &BOPTools_AlgoTools::CorrectPointOnCurve, "Provides valid values of tolerances for the shape <theS> in terms of BRepCheck_InvalidPointOnCurve.", py::arg("theS"), py::arg("theMapToAvoid"), py::arg("theTolMax"), py::arg("theRunParallel"));
	cls_BOPTools_AlgoTools.def_static("MakeNewVertex_", (void (*)(const gp_Pnt &, const Standard_Real, TopoDS_Vertex &)) &BOPTools_AlgoTools::MakeNewVertex, "Make a vertex using 3D-point <aP1> and 3D-tolerance value <aTol>", py::arg("aP1"), py::arg("aTol"), py::arg("aNewVertex"));
	cls_BOPTools_AlgoTools.def_static("MakeNewVertex_", (void (*)(const TopoDS_Vertex &, const TopoDS_Vertex &, TopoDS_Vertex &)) &BOPTools_AlgoTools::MakeNewVertex, "Make a vertex using couple of vertices <aV1, aV2>", py::arg("aV1"), py::arg("aV2"), py::arg("aNewVertex"));
	cls_BOPTools_AlgoTools.def_static("MakeNewVertex_", (void (*)(const TopoDS_Edge &, const Standard_Real, const TopoDS_Edge &, const Standard_Real, TopoDS_Vertex &)) &BOPTools_AlgoTools::MakeNewVertex, "Make a vertex in place of intersection between two edges <aE1, aE2> with parameters <aP1, aP2>", py::arg("aE1"), py::arg("aP1"), py::arg("aE2"), py::arg("aP2"), py::arg("aNewVertex"));
	cls_BOPTools_AlgoTools.def_static("MakeNewVertex_", (void (*)(const TopoDS_Edge &, const Standard_Real, const TopoDS_Face &, TopoDS_Vertex &)) &BOPTools_AlgoTools::MakeNewVertex, "Make a vertex in place of intersection between the edge <aE1> with parameter <aP1> and the face <aF2>", py::arg("aE1"), py::arg("aP1"), py::arg("aF2"), py::arg("aNewVertex"));
	cls_BOPTools_AlgoTools.def_static("PointOnEdge_", (void (*)(const TopoDS_Edge &, const Standard_Real, gp_Pnt &)) &BOPTools_AlgoTools::PointOnEdge, "Compute a 3D-point on the edge <aEdge> at parameter <aPrm>", py::arg("aEdge"), py::arg("aPrm"), py::arg("aP"));
	cls_BOPTools_AlgoTools.def_static("MakeSplitEdge_", (void (*)(const TopoDS_Edge &, const TopoDS_Vertex &, const Standard_Real, const TopoDS_Vertex &, const Standard_Real, TopoDS_Edge &)) &BOPTools_AlgoTools::MakeSplitEdge, "Make the edge from base edge <aE1> and two vertices <aV1,aV2> at parameters <aP1,aP2>", py::arg("aE1"), py::arg("aV1"), py::arg("aP1"), py::arg("aV2"), py::arg("aP2"), py::arg("aNewEdge"));
	cls_BOPTools_AlgoTools.def_static("MakeSectEdge_", (void (*)(const IntTools_Curve &, const TopoDS_Vertex &, const Standard_Real, const TopoDS_Vertex &, const Standard_Real, TopoDS_Edge &)) &BOPTools_AlgoTools::MakeSectEdge, "Make the edge from 3D-Curve <aIC> and two vertices <aV1,aV2> at parameters <aP1,aP2>", py::arg("aIC"), py::arg("aV1"), py::arg("aP1"), py::arg("aV2"), py::arg("aP2"), py::arg("aNewEdge"));
	cls_BOPTools_AlgoTools.def_static("UpdateVertex_", (void (*)(const IntTools_Curve &, const Standard_Real, const TopoDS_Vertex &)) &BOPTools_AlgoTools::UpdateVertex, "Update the tolerance value for vertex <aV> taking into account the fact that <aV> lays on the curve <aIC>", py::arg("aIC"), py::arg("aT"), py::arg("aV"));
	cls_BOPTools_AlgoTools.def_static("UpdateVertex_", (void (*)(const TopoDS_Edge &, const Standard_Real, const TopoDS_Vertex &)) &BOPTools_AlgoTools::UpdateVertex, "Update the tolerance value for vertex <aV> taking into account the fact that <aV> lays on the edge <aE>", py::arg("aE"), py::arg("aT"), py::arg("aV"));
	cls_BOPTools_AlgoTools.def_static("UpdateVertex_", (void (*)(const TopoDS_Vertex &, const TopoDS_Vertex &)) &BOPTools_AlgoTools::UpdateVertex, "Update the tolerance value for vertex <aVN> taking into account the fact that <aVN> should cover tolerance zone of <aVF>", py::arg("aVF"), py::arg("aVN"));
	cls_BOPTools_AlgoTools.def_static("CorrectRange_", (void (*)(const TopoDS_Edge &, const TopoDS_Edge &, const IntTools_Range &, IntTools_Range &)) &BOPTools_AlgoTools::CorrectRange, "Correct shrunk range <aSR> taking into account 3D-curve resolution and corresp. tolerances' values of <aE1>, <aE2>", py::arg("aE1"), py::arg("aE2"), py::arg("aSR"), py::arg("aNewSR"));
	cls_BOPTools_AlgoTools.def_static("CorrectRange_", (void (*)(const TopoDS_Edge &, const TopoDS_Face &, const IntTools_Range &, IntTools_Range &)) &BOPTools_AlgoTools::CorrectRange, "Correct shrunk range <aSR> taking into account 3D-curve resolution and corresp. tolerances' values of <aE>, <aF>", py::arg("aE"), py::arg("aF"), py::arg("aSR"), py::arg("aNewSR"));
	cls_BOPTools_AlgoTools.def_static("IsBlockInOnFace_", (Standard_Boolean (*)(const IntTools_Range &, const TopoDS_Face &, const TopoDS_Edge &, opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools::IsBlockInOnFace, "Returns TRUE if PaveBlock <aPB> lays on the face <aF>, i.e the <PB> is IN or ON in 2D of <aF>", py::arg("aShR"), py::arg("aF"), py::arg("aE"), py::arg("aContext"));
	cls_BOPTools_AlgoTools.def_static("IsMicroEdge_", [](const TopoDS_Edge & a0, const opencascade::handle<IntTools_Context> & a1) -> Standard_Boolean { return BOPTools_AlgoTools::IsMicroEdge(a0, a1); }, py::arg("theEdge"), py::arg("theContext"));
	cls_BOPTools_AlgoTools.def_static("IsMicroEdge_", (Standard_Boolean (*)(const TopoDS_Edge &, const opencascade::handle<IntTools_Context> &, const Standard_Boolean)) &BOPTools_AlgoTools::IsMicroEdge, "Checks if it is possible to compute shrunk range for the edge <aE> Flag <theCheckSplittable> defines whether to take into account the possiblity to split the edge or not.", py::arg("theEdge"), py::arg("theContext"), py::arg("theCheckSplittable"));
	cls_BOPTools_AlgoTools.def_static("CorrectShapeTolerances_", [](const TopoDS_Shape & a0, const BOPCol_IndexedMapOfShape & a1) -> void { return BOPTools_AlgoTools::CorrectShapeTolerances(a0, a1); }, py::arg("theS"), py::arg("theMapToAvoid"));
	cls_BOPTools_AlgoTools.def_static("CorrectShapeTolerances_", (void (*)(const TopoDS_Shape &, const BOPCol_IndexedMapOfShape &, const Standard_Boolean)) &BOPTools_AlgoTools::CorrectShapeTolerances, "Corrects tolerance values of the sub-shapes of the shape <theS> if needed.", py::arg("theS"), py::arg("theMapToAvoid"), py::arg("theRunParallel"));
	cls_BOPTools_AlgoTools.def_static("Dimension_", (Standard_Integer (*)(const TopoDS_Shape &)) &BOPTools_AlgoTools::Dimension, "Retutns dimension of the shape <theS>.", py::arg("theS"));
	cls_BOPTools_AlgoTools.def_static("IsOpenShell_", (Standard_Boolean (*)(const TopoDS_Shell &)) &BOPTools_AlgoTools::IsOpenShell, "Returns true if the shell <theShell> is open", py::arg("theShell"));
	cls_BOPTools_AlgoTools.def_static("IsInvertedSolid_", (Standard_Boolean (*)(const TopoDS_Solid &)) &BOPTools_AlgoTools::IsInvertedSolid, "Returns true if the solid <theSolid> is inverted", py::arg("theSolid"));
	cls_BOPTools_AlgoTools.def_static("ComputeTolerance_", (Standard_Boolean (*)(const TopoDS_Face &, const TopoDS_Edge &, Standard_Real &, Standard_Real &)) &BOPTools_AlgoTools::ComputeTolerance, "Computes the necessary value of the tolerance for the edge", py::arg("theFace"), py::arg("theEdge"), py::arg("theMaxDist"), py::arg("theMaxPar"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\BOPTools_Set.hxx
	py::class_<BOPTools_Set, std::unique_ptr<BOPTools_Set, Deleter<BOPTools_Set>>> cls_BOPTools_Set(mod, "BOPTools_Set", "None");
	cls_BOPTools_Set.def(py::init<>());
	cls_BOPTools_Set.def(py::init<const BOPCol_BaseAllocator &>(), py::arg("theAllocator"));
	cls_BOPTools_Set.def("Assign", (BOPTools_Set & (BOPTools_Set::*)(const BOPTools_Set &)) &BOPTools_Set::Assign, "None", py::arg("Other"));
	cls_BOPTools_Set.def("assign", (BOPTools_Set & (BOPTools_Set::*)(const BOPTools_Set &)) &BOPTools_Set::operator=, py::is_operator(), "None", py::arg("Other"));
	cls_BOPTools_Set.def("Shape", (const TopoDS_Shape & (BOPTools_Set::*)() const ) &BOPTools_Set::Shape, "None");
	cls_BOPTools_Set.def("Add", (void (BOPTools_Set::*)(const TopoDS_Shape &, const TopAbs_ShapeEnum)) &BOPTools_Set::Add, "None", py::arg("theS"), py::arg("theType"));
	cls_BOPTools_Set.def("NbShapes", (Standard_Integer (BOPTools_Set::*)() const ) &BOPTools_Set::NbShapes, "None");
	cls_BOPTools_Set.def("IsEqual", (Standard_Boolean (BOPTools_Set::*)(const BOPTools_Set &) const ) &BOPTools_Set::IsEqual, "None", py::arg("aOther"));
	cls_BOPTools_Set.def("HashCode", (Standard_Integer (BOPTools_Set::*)(const Standard_Integer) const ) &BOPTools_Set::HashCode, "None", py::arg("Upper"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\BOPTools_SetMapHasher.hxx
	py::class_<BOPTools_SetMapHasher, std::unique_ptr<BOPTools_SetMapHasher, Deleter<BOPTools_SetMapHasher>>> cls_BOPTools_SetMapHasher(mod, "BOPTools_SetMapHasher", "None");
	cls_BOPTools_SetMapHasher.def(py::init<>());
	cls_BOPTools_SetMapHasher.def_static("HashCode_", (Standard_Integer (*)(const BOPTools_Set &, const Standard_Integer)) &BOPTools_SetMapHasher::HashCode, "None", py::arg("aSet"), py::arg("Upper"));
	cls_BOPTools_SetMapHasher.def_static("IsEqual_", (Standard_Boolean (*)(const BOPTools_Set &, const BOPTools_Set &)) &BOPTools_SetMapHasher::IsEqual, "None", py::arg("aSet1"), py::arg("aSet2"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\BOPTools_AlgoTools2D.hxx
	py::class_<BOPTools_AlgoTools2D, std::unique_ptr<BOPTools_AlgoTools2D, Deleter<BOPTools_AlgoTools2D>>> cls_BOPTools_AlgoTools2D(mod, "BOPTools_AlgoTools2D", "The class contains handy static functions dealing with the topology This is the copy of the BOPTools_AlgoTools2D.cdl");
	cls_BOPTools_AlgoTools2D.def(py::init<>());
	cls_BOPTools_AlgoTools2D.def_static("BuildPCurveForEdgeOnFace_", [](const TopoDS_Edge & a0, const TopoDS_Face & a1) -> void { return BOPTools_AlgoTools2D::BuildPCurveForEdgeOnFace(a0, a1); }, py::arg("aE"), py::arg("aF"));
	cls_BOPTools_AlgoTools2D.def_static("BuildPCurveForEdgeOnFace_", (void (*)(const TopoDS_Edge &, const TopoDS_Face &, const opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools2D::BuildPCurveForEdgeOnFace, "Compute P-Curve for the edge <aE> on the face <aF>. Raises exception Standard_ConstructionError if projection algorithm fails. <theContext> - storage for caching the geometrical tools", py::arg("aE"), py::arg("aF"), py::arg("theContext"));
	// FIXME cls_BOPTools_AlgoTools2D.def_static("EdgeTangent_", (Standard_Boolean (*)(const TopoDS_Edge &, const Standard_Real, gp_Vec &)) &BOPTools_AlgoTools2D::EdgeTangent, "Compute tangent for the edge <aE> [in 3D] at parameter <aT>", py::arg("anE"), py::arg("aT"), py::arg("Tau"));
	cls_BOPTools_AlgoTools2D.def_static("PointOnSurface_", [](const TopoDS_Edge & a0, const TopoDS_Face & a1, const Standard_Real a2, Standard_Real & a3, Standard_Real & a4) -> void { return BOPTools_AlgoTools2D::PointOnSurface(a0, a1, a2, a3, a4); }, py::arg("aE"), py::arg("aF"), py::arg("aT"), py::arg("U"), py::arg("V"));
	cls_BOPTools_AlgoTools2D.def_static("PointOnSurface_", (void (*)(const TopoDS_Edge &, const TopoDS_Face &, const Standard_Real, Standard_Real &, Standard_Real &, const opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools2D::PointOnSurface, "Compute surface parameters <U,V> of the face <aF> for the point from the edge <aE> at parameter <aT>. If <aE> has't pcurve on surface, algorithm tries to get it by projection and can raise exception Standard_ConstructionError if projection algorithm fails. <theContext> - storage for caching the geometrical tools", py::arg("aE"), py::arg("aF"), py::arg("aT"), py::arg("U"), py::arg("V"), py::arg("theContext"));
	cls_BOPTools_AlgoTools2D.def_static("CurveOnSurface_", [](const TopoDS_Edge & a0, const TopoDS_Face & a1, opencascade::handle<Geom2d_Curve> & a2, Standard_Real & a3) -> void { return BOPTools_AlgoTools2D::CurveOnSurface(a0, a1, a2, a3); }, py::arg("aE"), py::arg("aF"), py::arg("aC"), py::arg("aToler"));
	// FIXME cls_BOPTools_AlgoTools2D.def_static("CurveOnSurface_", (void (*)(const TopoDS_Edge &, const TopoDS_Face &, opencascade::handle<Geom2d_Curve> &, Standard_Real &, const opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools2D::CurveOnSurface, "Get P-Curve <aC> for the edge <aE> on surface <aF> . If the P-Curve does not exist, build it using Make2D(). [aToler] - reached tolerance Raises exception Standard_ConstructionError if algorithm Make2D() fails. <theContext> - storage for caching the geometrical tools", py::arg("aE"), py::arg("aF"), py::arg("aC"), py::arg("aToler"), py::arg("theContext"));
	cls_BOPTools_AlgoTools2D.def_static("CurveOnSurface_", [](const TopoDS_Edge & a0, const TopoDS_Face & a1, opencascade::handle<Geom2d_Curve> & a2, Standard_Real & a3, Standard_Real & a4, Standard_Real & a5) -> void { return BOPTools_AlgoTools2D::CurveOnSurface(a0, a1, a2, a3, a4, a5); }, py::arg("aE"), py::arg("aF"), py::arg("aC"), py::arg("aFirst"), py::arg("aLast"), py::arg("aToler"));
	// FIXME cls_BOPTools_AlgoTools2D.def_static("CurveOnSurface_", (void (*)(const TopoDS_Edge &, const TopoDS_Face &, opencascade::handle<Geom2d_Curve> &, Standard_Real &, Standard_Real &, Standard_Real &, const opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools2D::CurveOnSurface, "Get P-Curve <aC> for the edge <aE> on surface <aF> . If the P-Curve does not exist, build it using Make2D(). [aFirst, aLast] - range of the P-Curve [aToler] - reached tolerance Raises exception Standard_ConstructionError if algorithm Make2D() fails. <theContext> - storage for caching the geometrical tools", py::arg("aE"), py::arg("aF"), py::arg("aC"), py::arg("aFirst"), py::arg("aLast"), py::arg("aToler"), py::arg("theContext"));
	// FIXME cls_BOPTools_AlgoTools2D.def_static("HasCurveOnSurface_", (Standard_Boolean (*)(const TopoDS_Edge &, const TopoDS_Face &, opencascade::handle<Geom2d_Curve> &, Standard_Real &, Standard_Real &, Standard_Real &)) &BOPTools_AlgoTools2D::HasCurveOnSurface, "Returns TRUE if the edge <aE> has P-Curve <aC> on surface <aF> . [aFirst, aLast] - range of the P-Curve [aToler] - reached tolerance If the P-Curve does not exist, aC.IsNull()=TRUE.", py::arg("aE"), py::arg("aF"), py::arg("aC"), py::arg("aFirst"), py::arg("aLast"), py::arg("aToler"));
	cls_BOPTools_AlgoTools2D.def_static("HasCurveOnSurface_", (Standard_Boolean (*)(const TopoDS_Edge &, const TopoDS_Face &)) &BOPTools_AlgoTools2D::HasCurveOnSurface, "Returns TRUE if the edge <aE> has P-Curve <aC> on surface <aF> . If the P-Curve does not exist, aC.IsNull()=TRUE.", py::arg("aE"), py::arg("aF"));
	cls_BOPTools_AlgoTools2D.def_static("AdjustPCurveOnFace_", [](const TopoDS_Face & a0, const opencascade::handle<Geom_Curve> & a1, const opencascade::handle<Geom2d_Curve> & a2, opencascade::handle<Geom2d_Curve> & a3) -> void { return BOPTools_AlgoTools2D::AdjustPCurveOnFace(a0, a1, a2, a3); }, py::arg("theF"), py::arg("theC3D"), py::arg("theC2D"), py::arg("theC2DA"));
	cls_BOPTools_AlgoTools2D.def_static("AdjustPCurveOnFace_", (void (*)(const TopoDS_Face &, const opencascade::handle<Geom_Curve> &, const opencascade::handle<Geom2d_Curve> &, opencascade::handle<Geom2d_Curve> &, const opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools2D::AdjustPCurveOnFace, "Adjust P-Curve <theC2D> (3D-curve <theC3D>) on surface of the face <theF>. <theContext> - storage for caching the geometrical tools", py::arg("theF"), py::arg("theC3D"), py::arg("theC2D"), py::arg("theC2DA"), py::arg("theContext"));
	cls_BOPTools_AlgoTools2D.def_static("AdjustPCurveOnFace_", [](const TopoDS_Face & a0, const Standard_Real a1, const Standard_Real a2, const opencascade::handle<Geom2d_Curve> & a3, opencascade::handle<Geom2d_Curve> & a4) -> void { return BOPTools_AlgoTools2D::AdjustPCurveOnFace(a0, a1, a2, a3, a4); }, py::arg("theF"), py::arg("theFirst"), py::arg("theLast"), py::arg("theC2D"), py::arg("theC2DA"));
	// FIXME cls_BOPTools_AlgoTools2D.def_static("AdjustPCurveOnFace_", (void (*)(const TopoDS_Face &, const Standard_Real, const Standard_Real, const opencascade::handle<Geom2d_Curve> &, opencascade::handle<Geom2d_Curve> &, const opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools2D::AdjustPCurveOnFace, "Adjust P-Curve <aC2D> (3D-curve <C3D>) on surface <aF> . [aT1, aT2] - range to adjust <theContext> - storage for caching the geometrical tools", py::arg("theF"), py::arg("theFirst"), py::arg("theLast"), py::arg("theC2D"), py::arg("theC2DA"), py::arg("theContext"));
	// FIXME cls_BOPTools_AlgoTools2D.def_static("AdjustPCurveOnSurf_", (void (*)(const BRepAdaptor_Surface &, const Standard_Real, const Standard_Real, const opencascade::handle<Geom2d_Curve> &, opencascade::handle<Geom2d_Curve> &)) &BOPTools_AlgoTools2D::AdjustPCurveOnSurf, "Adjust P-Curve <aC2D> (3D-curve <C3D>) on surface <aF> . [aT1, aT2] - range to adjust", py::arg("aF"), py::arg("aT1"), py::arg("aT2"), py::arg("aC2D"), py::arg("aC2DA"));
	// FIXME cls_BOPTools_AlgoTools2D.def_static("IntermediatePoint_", (Standard_Real (*)(const Standard_Real, const Standard_Real)) &BOPTools_AlgoTools2D::IntermediatePoint, "Compute intermediate value in between [aFirst, aLast] .", py::arg("aFirst"), py::arg("aLast"));
	cls_BOPTools_AlgoTools2D.def_static("IntermediatePoint_", (Standard_Real (*)(const TopoDS_Edge &)) &BOPTools_AlgoTools2D::IntermediatePoint, "Compute intermediate value of parameter for the edge <anE>.", py::arg("anE"));
	cls_BOPTools_AlgoTools2D.def_static("BuildPCurveForEdgeOnPlane_", (void (*)(const TopoDS_Edge &, const TopoDS_Face &)) &BOPTools_AlgoTools2D::BuildPCurveForEdgeOnPlane, "Build pcurve of edge on face if the surface is plane, and update the edge.", py::arg("theE"), py::arg("theF"));
	cls_BOPTools_AlgoTools2D.def_static("BuildPCurveForEdgeOnPlane_", (void (*)(const TopoDS_Edge &, const TopoDS_Face &, opencascade::handle<Geom2d_Curve> &, Standard_Boolean &)) &BOPTools_AlgoTools2D::BuildPCurveForEdgeOnPlane, "Build pcurve of edge on face if the surface is plane, but do not update the edge. The output are the pcurve and the flag telling that pcurve was built.", py::arg("theE"), py::arg("theF"), py::arg("aC2D"), py::arg("bToUpdate"));
	cls_BOPTools_AlgoTools2D.def_static("BuildPCurveForEdgesOnPlane_", (void (*)(const BOPCol_ListOfShape &, const TopoDS_Face &)) &BOPTools_AlgoTools2D::BuildPCurveForEdgesOnPlane, "None", py::arg("theLE"), py::arg("theF"));
	cls_BOPTools_AlgoTools2D.def_static("Make2D_", [](const TopoDS_Edge & a0, const TopoDS_Face & a1, opencascade::handle<Geom2d_Curve> & a2, Standard_Real & a3, Standard_Real & a4, Standard_Real & a5) -> void { return BOPTools_AlgoTools2D::Make2D(a0, a1, a2, a3, a4, a5); }, py::arg("aE"), py::arg("aF"), py::arg("aC"), py::arg("aFirst"), py::arg("aLast"), py::arg("aToler"));
	// FIXME cls_BOPTools_AlgoTools2D.def_static("Make2D_", (void (*)(const TopoDS_Edge &, const TopoDS_Face &, opencascade::handle<Geom2d_Curve> &, Standard_Real &, Standard_Real &, Standard_Real &, const opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools2D::Make2D, "Make P-Curve <aC> for the edge <aE> on surface <aF> . [aFirst, aLast] - range of the P-Curve [aToler] - reached tolerance Raises exception Standard_ConstructionError if algorithm fails. <theContext> - storage for caching the geometrical tools", py::arg("aE"), py::arg("aF"), py::arg("aC"), py::arg("aFirst"), py::arg("aLast"), py::arg("aToler"), py::arg("theContext"));
	cls_BOPTools_AlgoTools2D.def_static("MakePCurveOnFace_", [](const TopoDS_Face & a0, const opencascade::handle<Geom_Curve> & a1, opencascade::handle<Geom2d_Curve> & a2, Standard_Real & a3) -> void { return BOPTools_AlgoTools2D::MakePCurveOnFace(a0, a1, a2, a3); }, py::arg("aF"), py::arg("C3D"), py::arg("aC"), py::arg("aToler"));
	// FIXME cls_BOPTools_AlgoTools2D.def_static("MakePCurveOnFace_", (void (*)(const TopoDS_Face &, const opencascade::handle<Geom_Curve> &, opencascade::handle<Geom2d_Curve> &, Standard_Real &, const opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools2D::MakePCurveOnFace, "Make P-Curve <aC> for the 3D-curve <C3D> on surface <aF> . [aToler] - reached tolerance Raises exception Standard_ConstructionError if projection algorithm fails. <theContext> - storage for caching the geometrical tools", py::arg("aF"), py::arg("C3D"), py::arg("aC"), py::arg("aToler"), py::arg("theContext"));
	cls_BOPTools_AlgoTools2D.def_static("MakePCurveOnFace_", [](const TopoDS_Face & a0, const opencascade::handle<Geom_Curve> & a1, const Standard_Real a2, const Standard_Real a3, opencascade::handle<Geom2d_Curve> & a4, Standard_Real & a5) -> void { return BOPTools_AlgoTools2D::MakePCurveOnFace(a0, a1, a2, a3, a4, a5); }, py::arg("aF"), py::arg("C3D"), py::arg("aT1"), py::arg("aT2"), py::arg("aC"), py::arg("aToler"));
	// FIXME cls_BOPTools_AlgoTools2D.def_static("MakePCurveOnFace_", (void (*)(const TopoDS_Face &, const opencascade::handle<Geom_Curve> &, const Standard_Real, const Standard_Real, opencascade::handle<Geom2d_Curve> &, Standard_Real &, const opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools2D::MakePCurveOnFace, "Make P-Curve <aC> for the 3D-curve <C3D> on surface <aF> . [aT1, aT2] - range to build [aToler] - reached tolerance Raises exception Standard_ConstructionError if projection algorithm fails. <theContext> - storage for caching the geometrical tools", py::arg("aF"), py::arg("C3D"), py::arg("aT1"), py::arg("aT2"), py::arg("aC"), py::arg("aToler"), py::arg("theContext"));
	cls_BOPTools_AlgoTools2D.def_static("AttachExistingPCurve_", (Standard_Integer (*)(const TopoDS_Edge &, const TopoDS_Edge &, const TopoDS_Face &, const opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools2D::AttachExistingPCurve, "Attach P-Curve from the edge <aEold> on surface <aF> to the edge <aEnew> Returns 0 in case of success", py::arg("aEold"), py::arg("aEnew"), py::arg("aF"), py::arg("aCtx"));
	cls_BOPTools_AlgoTools2D.def_static("IsEdgeIsoline_", (void (*)(const TopoDS_Edge &, const TopoDS_Face &, Standard_Boolean &, Standard_Boolean &)) &BOPTools_AlgoTools2D::IsEdgeIsoline, "Checks if CurveOnSurface of theE on theF matches with isoline of theF surface. Sets corresponding values for isTheUIso and isTheVIso variables. ATTENTION!!! This method is based on comparation between direction of surface (which theF is based on) iso-lines and the direction of the edge p-curve (on theF) in middle-point of the p-curve. This method should be used carefully (e.g. BRep_Tool::IsClosed(...) together) in order to avoid false classification some p-curves as isoline (e.g. circle on a plane).", py::arg("theE"), py::arg("theF"), py::arg("isTheUIso"), py::arg("isTheVIso"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\BOPTools_AlgoTools3D.hxx
	py::class_<BOPTools_AlgoTools3D, std::unique_ptr<BOPTools_AlgoTools3D, Deleter<BOPTools_AlgoTools3D>>> cls_BOPTools_AlgoTools3D(mod, "BOPTools_AlgoTools3D", "The class contains handy static functions dealing with the topology This is the copy of BOPTools_AlgoTools3D.cdl file");
	cls_BOPTools_AlgoTools3D.def(py::init<>());
	cls_BOPTools_AlgoTools3D.def_static("DoSplitSEAMOnFace_", (void (*)(const TopoDS_Edge &, const TopoDS_Face &)) &BOPTools_AlgoTools3D::DoSplitSEAMOnFace, "Make the edge <aSp> seam edge for the face <aF>", py::arg("aSp"), py::arg("aF"));
	cls_BOPTools_AlgoTools3D.def_static("GetNormalToFaceOnEdge_", [](const TopoDS_Edge & a0, const TopoDS_Face & a1, const Standard_Real a2, gp_Dir & a3) -> void { return BOPTools_AlgoTools3D::GetNormalToFaceOnEdge(a0, a1, a2, a3); }, py::arg("aE"), py::arg("aF"), py::arg("aT"), py::arg("aD"));
	cls_BOPTools_AlgoTools3D.def_static("GetNormalToFaceOnEdge_", (void (*)(const TopoDS_Edge &, const TopoDS_Face &, const Standard_Real, gp_Dir &, const opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools3D::GetNormalToFaceOnEdge, "Computes normal to the face <aF> for the point on the edge <aE> at parameter <aT>. <theContext> - storage for caching the geometrical tools", py::arg("aE"), py::arg("aF"), py::arg("aT"), py::arg("aD"), py::arg("theContext"));
	cls_BOPTools_AlgoTools3D.def_static("GetNormalToFaceOnEdge_", [](const TopoDS_Edge & a0, const TopoDS_Face & a1, gp_Dir & a2) -> void { return BOPTools_AlgoTools3D::GetNormalToFaceOnEdge(a0, a1, a2); }, py::arg("aE"), py::arg("aF"), py::arg("aD"));
	cls_BOPTools_AlgoTools3D.def_static("GetNormalToFaceOnEdge_", (void (*)(const TopoDS_Edge &, const TopoDS_Face &, gp_Dir &, const opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools3D::GetNormalToFaceOnEdge, "Computes normal to the face <aF> for the point on the edge <aE> at arbitrary intermediate parameter. <theContext> - storage for caching the geometrical tools", py::arg("aE"), py::arg("aF"), py::arg("aD"), py::arg("theContext"));
	cls_BOPTools_AlgoTools3D.def_static("SenseFlag_", (Standard_Integer (*)(const gp_Dir &, const gp_Dir &)) &BOPTools_AlgoTools3D::SenseFlag, "Returns 1 if scalar product aNF1* aNF2>0. Returns 0 if directions aNF1 aNF2 coincide Returns -1 if scalar product aNF1* aNF2<0.", py::arg("aNF1"), py::arg("aNF2"));
	cls_BOPTools_AlgoTools3D.def_static("GetNormalToSurface_", (Standard_Boolean (*)(const opencascade::handle<Geom_Surface> &, const Standard_Real, const Standard_Real, gp_Dir &)) &BOPTools_AlgoTools3D::GetNormalToSurface, "Compute normal <aD> to surface <aS> in point (U,V) Returns TRUE if directions aD1U, aD1V coincide", py::arg("aS"), py::arg("U"), py::arg("V"), py::arg("aD"));
	cls_BOPTools_AlgoTools3D.def_static("GetApproxNormalToFaceOnEdge_", (Standard_Boolean (*)(const TopoDS_Edge &, const TopoDS_Face &, const Standard_Real, gp_Pnt &, gp_Dir &, opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools3D::GetApproxNormalToFaceOnEdge, "Computes normal to the face <aF> for the 3D-point that belongs to the edge <aE> at parameter <aT>. Output: aPx - the 3D-point where the normal computed aD - the normal; Warning: The normal is computed not exactly in the point on the edge, but in point that is near to the edge towards to the face material (so, we'll have approx. normal); The point is computed using PointNearEdge function, with the shifting value BOPTools_AlgoTools3D::MinStepIn2d(), from the edge, but if this value is too big, the point will be computed using Hatcher (PointInFace function). Returns TRUE in case of success.", py::arg("aE"), py::arg("aF"), py::arg("aT"), py::arg("aPx"), py::arg("aD"), py::arg("theContext"));
	cls_BOPTools_AlgoTools3D.def_static("GetApproxNormalToFaceOnEdge_", (Standard_Boolean (*)(const TopoDS_Edge &, const TopoDS_Face &, const Standard_Real, gp_Pnt &, gp_Dir &, const Standard_Real)) &BOPTools_AlgoTools3D::GetApproxNormalToFaceOnEdge, "Computes normal to the face <aF> for the 3D-point that belongs to the edge <aE> at parameter <aT>. Output: aPx - the 3D-point where the normal computed aD - the normal; Warning: The normal is computed not exactly in the point on the edge, but in point that is near to the edge towards to the face material (so, we'll have approx. normal); The point is computed using PointNearEdge function with the shifting value <aDt2D> from the edge; No checks on this value will be done. Returns TRUE in case of success.", py::arg("theE"), py::arg("theF"), py::arg("aT"), py::arg("aP"), py::arg("aDNF"), py::arg("aDt2D"));
	cls_BOPTools_AlgoTools3D.def_static("GetApproxNormalToFaceOnEdge_", (Standard_Boolean (*)(const TopoDS_Edge &, const TopoDS_Face &, const Standard_Real, const Standard_Real, gp_Pnt &, gp_Dir &, opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools3D::GetApproxNormalToFaceOnEdge, "Computes normal to the face <aF> for the 3D-point that belongs to the edge <aE> at parameter <aT>. Output: aPx - the 3D-point where the normal computed aD - the normal; Warning: The normal is computed not exactly in the point on the edge, but in point that is near to the edge towards to the face material (so, we'll have approx. normal); The point is computed using PointNearEdge function with the shifting value <aDt2D> from the edge, but if this value is too big the point will be computed using Hatcher (PointInFace function). Returns TRUE in case of success.", py::arg("theE"), py::arg("theF"), py::arg("aT"), py::arg("aDt2D"), py::arg("aP"), py::arg("aDNF"), py::arg("theContext"));
	cls_BOPTools_AlgoTools3D.def_static("PointNearEdge_", (Standard_Integer (*)(const TopoDS_Edge &, const TopoDS_Face &, const Standard_Real, const Standard_Real, gp_Pnt2d &, gp_Pnt &, opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools3D::PointNearEdge, "Compute the point <aPx>, (<aP2D>) that is near to the edge <aE> at parameter <aT> towards to the material of the face <aF>. The value of shifting in 2D is <aDt2D> If the value of shifting is too big the point will be computed using Hatcher (PointInFace function). Returns error status: 0 - in case of success; 1 - <aE> does not have 2d curve on the face <aF>; 2 - the computed point is out of the face.", py::arg("aE"), py::arg("aF"), py::arg("aT"), py::arg("aDt2D"), py::arg("aP2D"), py::arg("aPx"), py::arg("theContext"));
	cls_BOPTools_AlgoTools3D.def_static("PointNearEdge_", (Standard_Integer (*)(const TopoDS_Edge &, const TopoDS_Face &, const Standard_Real, const Standard_Real, gp_Pnt2d &, gp_Pnt &)) &BOPTools_AlgoTools3D::PointNearEdge, "Compute the point <aPx>, (<aP2D>) that is near to the edge <aE> at parameter <aT> towards to the material of the face <aF>. The value of shifting in 2D is <aDt2D>. No checks on this value will be done. Returns error status: 0 - in case of success; 1 - <aE> does not have 2d curve on the face <aF>.", py::arg("aE"), py::arg("aF"), py::arg("aT"), py::arg("aDt2D"), py::arg("aP2D"), py::arg("aPx"));
	cls_BOPTools_AlgoTools3D.def_static("PointNearEdge_", (Standard_Integer (*)(const TopoDS_Edge &, const TopoDS_Face &, const Standard_Real, gp_Pnt2d &, gp_Pnt &, opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools3D::PointNearEdge, "Computes the point <aPx>, (<aP2D>) that is near to the edge <aE> at parameter <aT> towards to the material of the face <aF>. The value of shifting in 2D is dt2D=BOPTools_AlgoTools3D::MinStepIn2d() If the value of shifting is too big the point will be computed using Hatcher (PointInFace function). Returns error status: 0 - in case of success; 1 - <aE> does not have 2d curve on the face <aF>; 2 - the computed point is out of the face.", py::arg("aE"), py::arg("aF"), py::arg("aT"), py::arg("aP2D"), py::arg("aPx"), py::arg("theContext"));
	cls_BOPTools_AlgoTools3D.def_static("PointNearEdge_", (Standard_Integer (*)(const TopoDS_Edge &, const TopoDS_Face &, gp_Pnt2d &, gp_Pnt &, opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools3D::PointNearEdge, "Compute the point <aPx>, (<aP2D>) that is near to the edge <aE> at arbitrary parameter towards to the material of the face <aF>. The value of shifting in 2D is dt2D=BOPTools_AlgoTools3D::MinStepIn2d(). If the value of shifting is too big the point will be computed using Hatcher (PointInFace function). Returns error status: 0 - in case of success; 1 - <aE> does not have 2d curve on the face <aF>; 2 - the computed point is out of the face.", py::arg("aE"), py::arg("aF"), py::arg("aP2D"), py::arg("aPx"), py::arg("theContext"));
	cls_BOPTools_AlgoTools3D.def_static("MinStepIn2d_", (Standard_Real (*)()) &BOPTools_AlgoTools3D::MinStepIn2d, "Returns simple step value that is used in 2D-computations = 1.e-5");
	cls_BOPTools_AlgoTools3D.def_static("IsEmptyShape_", (Standard_Boolean (*)(const TopoDS_Shape &)) &BOPTools_AlgoTools3D::IsEmptyShape, "Returns TRUE if the shape <aS> does not contain geometry information (e.g. empty compound)", py::arg("aS"));
	cls_BOPTools_AlgoTools3D.def_static("OrientEdgeOnFace_", (void (*)(const TopoDS_Edge &, const TopoDS_Face &, TopoDS_Edge &)) &BOPTools_AlgoTools3D::OrientEdgeOnFace, "Get the edge <aER> from the face <aF> that is the same as the edge <aE>", py::arg("aE"), py::arg("aF"), py::arg("aER"));
	cls_BOPTools_AlgoTools3D.def_static("PointInFace_", (Standard_Integer (*)(const TopoDS_Face &, gp_Pnt &, gp_Pnt2d &, opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools3D::PointInFace, "Computes arbitrary point <theP> inside the face <theF>. <theP2D> - 2D representation of <theP> on the surface of <theF> Returns 0 in case of success.", py::arg("theF"), py::arg("theP"), py::arg("theP2D"), py::arg("theContext"));
	cls_BOPTools_AlgoTools3D.def_static("PointInFace_", (Standard_Integer (*)(const TopoDS_Face &, const TopoDS_Edge &, const Standard_Real, const Standard_Real, gp_Pnt &, gp_Pnt2d &, opencascade::handle<IntTools_Context> &)) &BOPTools_AlgoTools3D::PointInFace, "Computes a point <theP> inside the face <theF> using starting point taken by the parameter <theT> from the 2d curve of the edge <theE> on the face <theF> in the direction perpendicular to the tangent vector of the 2d curve of the edge. The point will be distanced on <theDt2D> from the 2d curve. <theP2D> - 2D representation of <theP> on the surface of <theF> Returns 0 in case of success.", py::arg("theF"), py::arg("theE"), py::arg("theT"), py::arg("theDt2D"), py::arg("theP"), py::arg("theP2D"), py::arg("theContext"));
	cls_BOPTools_AlgoTools3D.def_static("PointInFace_", [](const TopoDS_Face & a0, const opencascade::handle<Geom2d_Curve> & a1, gp_Pnt & a2, gp_Pnt2d & a3, opencascade::handle<IntTools_Context> & a4) -> Standard_Integer { return BOPTools_AlgoTools3D::PointInFace(a0, a1, a2, a3, a4); }, py::arg("theF"), py::arg("theL"), py::arg("theP"), py::arg("theP2D"), py::arg("theContext"));
	cls_BOPTools_AlgoTools3D.def_static("PointInFace_", (Standard_Integer (*)(const TopoDS_Face &, const opencascade::handle<Geom2d_Curve> &, gp_Pnt &, gp_Pnt2d &, opencascade::handle<IntTools_Context> &, const Standard_Real)) &BOPTools_AlgoTools3D::PointInFace, "Computes a point <theP> inside the face <theF> using the line <theL> so that 2D point <theP2D>, 2D representation of <theP> on the surface of <theF>, lies on that line. Returns 0 in case of success.", py::arg("theF"), py::arg("theL"), py::arg("theP"), py::arg("theP2D"), py::arg("theContext"), py::arg("theDt2D"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\BOPTools.hxx
	py::class_<BOPTools, std::unique_ptr<BOPTools, Deleter<BOPTools>>> cls_BOPTools(mod, "BOPTools", "None");
	cls_BOPTools.def(py::init<>());
	cls_BOPTools.def_static("MapShapes_", (void (*)(const TopoDS_Shape &, BOPCol_MapOfShape &)) &BOPTools::MapShapes, "None", py::arg("S"), py::arg("M"));
	cls_BOPTools.def_static("MapShapes_", (void (*)(const TopoDS_Shape &, BOPCol_IndexedMapOfShape &)) &BOPTools::MapShapes, "None", py::arg("S"), py::arg("M"));
	cls_BOPTools.def_static("MapShapes_", (void (*)(const TopoDS_Shape &, const TopAbs_ShapeEnum, BOPCol_IndexedMapOfShape &)) &BOPTools::MapShapes, "None", py::arg("S"), py::arg("T"), py::arg("M"));
	cls_BOPTools.def_static("MapShapesAndAncestors_", (void (*)(const TopoDS_Shape &, const TopAbs_ShapeEnum, const TopAbs_ShapeEnum, BOPCol_IndexedDataMapOfShapeListOfShape &)) &BOPTools::MapShapesAndAncestors, "None", py::arg("S"), py::arg("TS"), py::arg("TA"), py::arg("M"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\BOPTools_CoupleOfShape.hxx
	py::class_<BOPTools_CoupleOfShape, std::unique_ptr<BOPTools_CoupleOfShape, Deleter<BOPTools_CoupleOfShape>>> cls_BOPTools_CoupleOfShape(mod, "BOPTools_CoupleOfShape", "None");
	cls_BOPTools_CoupleOfShape.def(py::init<>());
	cls_BOPTools_CoupleOfShape.def("SetShape1", (void (BOPTools_CoupleOfShape::*)(const TopoDS_Shape &)) &BOPTools_CoupleOfShape::SetShape1, "None", py::arg("theShape"));
	cls_BOPTools_CoupleOfShape.def("Shape1", (const TopoDS_Shape & (BOPTools_CoupleOfShape::*)() const ) &BOPTools_CoupleOfShape::Shape1, "None");
	cls_BOPTools_CoupleOfShape.def("SetShape2", (void (BOPTools_CoupleOfShape::*)(const TopoDS_Shape &)) &BOPTools_CoupleOfShape::SetShape2, "None", py::arg("theShape"));
	cls_BOPTools_CoupleOfShape.def("Shape2", (const TopoDS_Shape & (BOPTools_CoupleOfShape::*)() const ) &BOPTools_CoupleOfShape::Shape2, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_List.hxx
	py::class_<BOPTools_ListOfConnexityBlock, std::unique_ptr<BOPTools_ListOfConnexityBlock, Deleter<BOPTools_ListOfConnexityBlock>>, NCollection_BaseList> cls_BOPTools_ListOfConnexityBlock(mod, "BOPTools_ListOfConnexityBlock", "Purpose: Simple list to link items together keeping the first and the last one. Inherits BaseList, adding the data item to each node.");
	cls_BOPTools_ListOfConnexityBlock.def(py::init<>());
	cls_BOPTools_ListOfConnexityBlock.def(py::init<const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("theAllocator"));
	cls_BOPTools_ListOfConnexityBlock.def(py::init([] (const BOPTools_ListOfConnexityBlock &other) {return new BOPTools_ListOfConnexityBlock(other);}), "Copy constructor", py::arg("other"));
	cls_BOPTools_ListOfConnexityBlock.def("begin", (BOPTools_ListOfConnexityBlock::iterator (BOPTools_ListOfConnexityBlock::*)() const ) &BOPTools_ListOfConnexityBlock::begin, "Returns an iterator pointing to the first element in the list.");
	cls_BOPTools_ListOfConnexityBlock.def("end", (BOPTools_ListOfConnexityBlock::iterator (BOPTools_ListOfConnexityBlock::*)() const ) &BOPTools_ListOfConnexityBlock::end, "Returns an iterator referring to the past-the-end element in the list.");
	cls_BOPTools_ListOfConnexityBlock.def("cbegin", (BOPTools_ListOfConnexityBlock::const_iterator (BOPTools_ListOfConnexityBlock::*)() const ) &BOPTools_ListOfConnexityBlock::cbegin, "Returns a const iterator pointing to the first element in the list.");
	cls_BOPTools_ListOfConnexityBlock.def("cend", (BOPTools_ListOfConnexityBlock::const_iterator (BOPTools_ListOfConnexityBlock::*)() const ) &BOPTools_ListOfConnexityBlock::cend, "Returns a const iterator referring to the past-the-end element in the list.");
	cls_BOPTools_ListOfConnexityBlock.def("Size", (Standard_Integer (BOPTools_ListOfConnexityBlock::*)() const ) &BOPTools_ListOfConnexityBlock::Size, "Size - Number of items");
	cls_BOPTools_ListOfConnexityBlock.def("Assign", (BOPTools_ListOfConnexityBlock & (BOPTools_ListOfConnexityBlock::*)(const BOPTools_ListOfConnexityBlock &)) &BOPTools_ListOfConnexityBlock::Assign, "Replace this list by the items of another list (theOther parameter). This method does not change the internal allocator.", py::arg("theOther"));
	cls_BOPTools_ListOfConnexityBlock.def("assign", (BOPTools_ListOfConnexityBlock & (BOPTools_ListOfConnexityBlock::*)(const BOPTools_ListOfConnexityBlock &)) &BOPTools_ListOfConnexityBlock::operator=, py::is_operator(), "Replacement operator", py::arg("theOther"));
	cls_BOPTools_ListOfConnexityBlock.def("Clear", [](BOPTools_ListOfConnexityBlock &self) -> void { return self.Clear(); });
	cls_BOPTools_ListOfConnexityBlock.def("Clear", (void (BOPTools_ListOfConnexityBlock::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &BOPTools_ListOfConnexityBlock::Clear, "Clear this list", py::arg("theAllocator"));
	cls_BOPTools_ListOfConnexityBlock.def("First", (const BOPTools_ConnexityBlock & (BOPTools_ListOfConnexityBlock::*)() const ) &BOPTools_ListOfConnexityBlock::First, "First item");
	cls_BOPTools_ListOfConnexityBlock.def("First", (BOPTools_ConnexityBlock & (BOPTools_ListOfConnexityBlock::*)()) &BOPTools_ListOfConnexityBlock::First, "First item (non-const)");
	cls_BOPTools_ListOfConnexityBlock.def("Last", (const BOPTools_ConnexityBlock & (BOPTools_ListOfConnexityBlock::*)() const ) &BOPTools_ListOfConnexityBlock::Last, "Last item");
	cls_BOPTools_ListOfConnexityBlock.def("Last", (BOPTools_ConnexityBlock & (BOPTools_ListOfConnexityBlock::*)()) &BOPTools_ListOfConnexityBlock::Last, "Last item (non-const)");
	cls_BOPTools_ListOfConnexityBlock.def("Append", (BOPTools_ConnexityBlock & (BOPTools_ListOfConnexityBlock::*)(const BOPTools_ConnexityBlock &)) &BOPTools_ListOfConnexityBlock::Append, "Append one item at the end", py::arg("theItem"));
	cls_BOPTools_ListOfConnexityBlock.def("Append", (void (BOPTools_ListOfConnexityBlock::*)(const BOPTools_ConnexityBlock &, BOPTools_ListOfConnexityBlock::Iterator &)) &BOPTools_ListOfConnexityBlock::Append, "Append one item at the end and output iterator pointing at the appended item", py::arg("theItem"), py::arg("theIter"));
	cls_BOPTools_ListOfConnexityBlock.def("Append", (void (BOPTools_ListOfConnexityBlock::*)(BOPTools_ListOfConnexityBlock &)) &BOPTools_ListOfConnexityBlock::Append, "Append another list at the end", py::arg("theOther"));
	cls_BOPTools_ListOfConnexityBlock.def("Prepend", (BOPTools_ConnexityBlock & (BOPTools_ListOfConnexityBlock::*)(const BOPTools_ConnexityBlock &)) &BOPTools_ListOfConnexityBlock::Prepend, "Prepend one item at the beginning", py::arg("theItem"));
	cls_BOPTools_ListOfConnexityBlock.def("Prepend", (void (BOPTools_ListOfConnexityBlock::*)(BOPTools_ListOfConnexityBlock &)) &BOPTools_ListOfConnexityBlock::Prepend, "Prepend another list at the beginning", py::arg("theOther"));
	cls_BOPTools_ListOfConnexityBlock.def("RemoveFirst", (void (BOPTools_ListOfConnexityBlock::*)()) &BOPTools_ListOfConnexityBlock::RemoveFirst, "RemoveFirst item");
	cls_BOPTools_ListOfConnexityBlock.def("Remove", (void (BOPTools_ListOfConnexityBlock::*)(BOPTools_ListOfConnexityBlock::Iterator &)) &BOPTools_ListOfConnexityBlock::Remove, "Remove item pointed by iterator theIter; theIter is then set to the next item", py::arg("theIter"));
	cls_BOPTools_ListOfConnexityBlock.def("InsertBefore", (BOPTools_ConnexityBlock & (BOPTools_ListOfConnexityBlock::*)(const BOPTools_ConnexityBlock &, BOPTools_ListOfConnexityBlock::Iterator &)) &BOPTools_ListOfConnexityBlock::InsertBefore, "InsertBefore", py::arg("theItem"), py::arg("theIter"));
	cls_BOPTools_ListOfConnexityBlock.def("InsertBefore", (void (BOPTools_ListOfConnexityBlock::*)(BOPTools_ListOfConnexityBlock &, BOPTools_ListOfConnexityBlock::Iterator &)) &BOPTools_ListOfConnexityBlock::InsertBefore, "InsertBefore", py::arg("theOther"), py::arg("theIter"));
	cls_BOPTools_ListOfConnexityBlock.def("InsertAfter", (BOPTools_ConnexityBlock & (BOPTools_ListOfConnexityBlock::*)(const BOPTools_ConnexityBlock &, BOPTools_ListOfConnexityBlock::Iterator &)) &BOPTools_ListOfConnexityBlock::InsertAfter, "InsertAfter", py::arg("theItem"), py::arg("theIter"));
	cls_BOPTools_ListOfConnexityBlock.def("InsertAfter", (void (BOPTools_ListOfConnexityBlock::*)(BOPTools_ListOfConnexityBlock &, BOPTools_ListOfConnexityBlock::Iterator &)) &BOPTools_ListOfConnexityBlock::InsertAfter, "InsertAfter", py::arg("theOther"), py::arg("theIter"));
	cls_BOPTools_ListOfConnexityBlock.def("Reverse", (void (BOPTools_ListOfConnexityBlock::*)()) &BOPTools_ListOfConnexityBlock::Reverse, "Reverse the list");
	cls_BOPTools_ListOfConnexityBlock.def("__iter__", [](const BOPTools_ListOfConnexityBlock &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_TListIterator.hxx
	py::class_<BOPTools_ListIteratorOfListOfConnexityBlock, std::unique_ptr<BOPTools_ListIteratorOfListOfConnexityBlock, Deleter<BOPTools_ListIteratorOfListOfConnexityBlock>>> cls_BOPTools_ListIteratorOfListOfConnexityBlock(mod, "BOPTools_ListIteratorOfListOfConnexityBlock", "Purpose: This Iterator class iterates on BaseList of TListNode and is instantiated in List/Set/Queue/Stack Remark: TListIterator is internal class");
	cls_BOPTools_ListIteratorOfListOfConnexityBlock.def(py::init<>());
	cls_BOPTools_ListIteratorOfListOfConnexityBlock.def(py::init<const NCollection_BaseList &>(), py::arg("theList"));
	cls_BOPTools_ListIteratorOfListOfConnexityBlock.def("More", (Standard_Boolean (BOPTools_ListIteratorOfListOfConnexityBlock::*)() const ) &BOPTools_ListIteratorOfListOfConnexityBlock::More, "Check end");
	cls_BOPTools_ListIteratorOfListOfConnexityBlock.def("Next", (void (BOPTools_ListIteratorOfListOfConnexityBlock::*)()) &BOPTools_ListIteratorOfListOfConnexityBlock::Next, "Make step");
	cls_BOPTools_ListIteratorOfListOfConnexityBlock.def("Value", (const BOPTools_ConnexityBlock & (BOPTools_ListIteratorOfListOfConnexityBlock::*)() const ) &BOPTools_ListIteratorOfListOfConnexityBlock::Value, "Constant Value access");
	cls_BOPTools_ListIteratorOfListOfConnexityBlock.def("Value", (BOPTools_ConnexityBlock & (BOPTools_ListIteratorOfListOfConnexityBlock::*)()) &BOPTools_ListIteratorOfListOfConnexityBlock::Value, "Non-const Value access");
	cls_BOPTools_ListIteratorOfListOfConnexityBlock.def("ChangeValue", (BOPTools_ConnexityBlock & (BOPTools_ListIteratorOfListOfConnexityBlock::*)() const ) &BOPTools_ListIteratorOfListOfConnexityBlock::ChangeValue, "Non-const Value access");

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_List.hxx
	py::class_<BOPTools_ListOfCoupleOfShape, std::unique_ptr<BOPTools_ListOfCoupleOfShape, Deleter<BOPTools_ListOfCoupleOfShape>>, NCollection_BaseList> cls_BOPTools_ListOfCoupleOfShape(mod, "BOPTools_ListOfCoupleOfShape", "Purpose: Simple list to link items together keeping the first and the last one. Inherits BaseList, adding the data item to each node.");
	cls_BOPTools_ListOfCoupleOfShape.def(py::init<>());
	cls_BOPTools_ListOfCoupleOfShape.def(py::init<const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("theAllocator"));
	cls_BOPTools_ListOfCoupleOfShape.def(py::init([] (const BOPTools_ListOfCoupleOfShape &other) {return new BOPTools_ListOfCoupleOfShape(other);}), "Copy constructor", py::arg("other"));
	cls_BOPTools_ListOfCoupleOfShape.def("begin", (BOPTools_ListOfCoupleOfShape::iterator (BOPTools_ListOfCoupleOfShape::*)() const ) &BOPTools_ListOfCoupleOfShape::begin, "Returns an iterator pointing to the first element in the list.");
	cls_BOPTools_ListOfCoupleOfShape.def("end", (BOPTools_ListOfCoupleOfShape::iterator (BOPTools_ListOfCoupleOfShape::*)() const ) &BOPTools_ListOfCoupleOfShape::end, "Returns an iterator referring to the past-the-end element in the list.");
	cls_BOPTools_ListOfCoupleOfShape.def("cbegin", (BOPTools_ListOfCoupleOfShape::const_iterator (BOPTools_ListOfCoupleOfShape::*)() const ) &BOPTools_ListOfCoupleOfShape::cbegin, "Returns a const iterator pointing to the first element in the list.");
	cls_BOPTools_ListOfCoupleOfShape.def("cend", (BOPTools_ListOfCoupleOfShape::const_iterator (BOPTools_ListOfCoupleOfShape::*)() const ) &BOPTools_ListOfCoupleOfShape::cend, "Returns a const iterator referring to the past-the-end element in the list.");
	cls_BOPTools_ListOfCoupleOfShape.def("Size", (Standard_Integer (BOPTools_ListOfCoupleOfShape::*)() const ) &BOPTools_ListOfCoupleOfShape::Size, "Size - Number of items");
	cls_BOPTools_ListOfCoupleOfShape.def("Assign", (BOPTools_ListOfCoupleOfShape & (BOPTools_ListOfCoupleOfShape::*)(const BOPTools_ListOfCoupleOfShape &)) &BOPTools_ListOfCoupleOfShape::Assign, "Replace this list by the items of another list (theOther parameter). This method does not change the internal allocator.", py::arg("theOther"));
	cls_BOPTools_ListOfCoupleOfShape.def("assign", (BOPTools_ListOfCoupleOfShape & (BOPTools_ListOfCoupleOfShape::*)(const BOPTools_ListOfCoupleOfShape &)) &BOPTools_ListOfCoupleOfShape::operator=, py::is_operator(), "Replacement operator", py::arg("theOther"));
	cls_BOPTools_ListOfCoupleOfShape.def("Clear", [](BOPTools_ListOfCoupleOfShape &self) -> void { return self.Clear(); });
	cls_BOPTools_ListOfCoupleOfShape.def("Clear", (void (BOPTools_ListOfCoupleOfShape::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &BOPTools_ListOfCoupleOfShape::Clear, "Clear this list", py::arg("theAllocator"));
	cls_BOPTools_ListOfCoupleOfShape.def("First", (const BOPTools_CoupleOfShape & (BOPTools_ListOfCoupleOfShape::*)() const ) &BOPTools_ListOfCoupleOfShape::First, "First item");
	cls_BOPTools_ListOfCoupleOfShape.def("First", (BOPTools_CoupleOfShape & (BOPTools_ListOfCoupleOfShape::*)()) &BOPTools_ListOfCoupleOfShape::First, "First item (non-const)");
	cls_BOPTools_ListOfCoupleOfShape.def("Last", (const BOPTools_CoupleOfShape & (BOPTools_ListOfCoupleOfShape::*)() const ) &BOPTools_ListOfCoupleOfShape::Last, "Last item");
	cls_BOPTools_ListOfCoupleOfShape.def("Last", (BOPTools_CoupleOfShape & (BOPTools_ListOfCoupleOfShape::*)()) &BOPTools_ListOfCoupleOfShape::Last, "Last item (non-const)");
	cls_BOPTools_ListOfCoupleOfShape.def("Append", (BOPTools_CoupleOfShape & (BOPTools_ListOfCoupleOfShape::*)(const BOPTools_CoupleOfShape &)) &BOPTools_ListOfCoupleOfShape::Append, "Append one item at the end", py::arg("theItem"));
	cls_BOPTools_ListOfCoupleOfShape.def("Append", (void (BOPTools_ListOfCoupleOfShape::*)(const BOPTools_CoupleOfShape &, BOPTools_ListOfCoupleOfShape::Iterator &)) &BOPTools_ListOfCoupleOfShape::Append, "Append one item at the end and output iterator pointing at the appended item", py::arg("theItem"), py::arg("theIter"));
	cls_BOPTools_ListOfCoupleOfShape.def("Append", (void (BOPTools_ListOfCoupleOfShape::*)(BOPTools_ListOfCoupleOfShape &)) &BOPTools_ListOfCoupleOfShape::Append, "Append another list at the end", py::arg("theOther"));
	cls_BOPTools_ListOfCoupleOfShape.def("Prepend", (BOPTools_CoupleOfShape & (BOPTools_ListOfCoupleOfShape::*)(const BOPTools_CoupleOfShape &)) &BOPTools_ListOfCoupleOfShape::Prepend, "Prepend one item at the beginning", py::arg("theItem"));
	cls_BOPTools_ListOfCoupleOfShape.def("Prepend", (void (BOPTools_ListOfCoupleOfShape::*)(BOPTools_ListOfCoupleOfShape &)) &BOPTools_ListOfCoupleOfShape::Prepend, "Prepend another list at the beginning", py::arg("theOther"));
	cls_BOPTools_ListOfCoupleOfShape.def("RemoveFirst", (void (BOPTools_ListOfCoupleOfShape::*)()) &BOPTools_ListOfCoupleOfShape::RemoveFirst, "RemoveFirst item");
	cls_BOPTools_ListOfCoupleOfShape.def("Remove", (void (BOPTools_ListOfCoupleOfShape::*)(BOPTools_ListOfCoupleOfShape::Iterator &)) &BOPTools_ListOfCoupleOfShape::Remove, "Remove item pointed by iterator theIter; theIter is then set to the next item", py::arg("theIter"));
	cls_BOPTools_ListOfCoupleOfShape.def("InsertBefore", (BOPTools_CoupleOfShape & (BOPTools_ListOfCoupleOfShape::*)(const BOPTools_CoupleOfShape &, BOPTools_ListOfCoupleOfShape::Iterator &)) &BOPTools_ListOfCoupleOfShape::InsertBefore, "InsertBefore", py::arg("theItem"), py::arg("theIter"));
	cls_BOPTools_ListOfCoupleOfShape.def("InsertBefore", (void (BOPTools_ListOfCoupleOfShape::*)(BOPTools_ListOfCoupleOfShape &, BOPTools_ListOfCoupleOfShape::Iterator &)) &BOPTools_ListOfCoupleOfShape::InsertBefore, "InsertBefore", py::arg("theOther"), py::arg("theIter"));
	cls_BOPTools_ListOfCoupleOfShape.def("InsertAfter", (BOPTools_CoupleOfShape & (BOPTools_ListOfCoupleOfShape::*)(const BOPTools_CoupleOfShape &, BOPTools_ListOfCoupleOfShape::Iterator &)) &BOPTools_ListOfCoupleOfShape::InsertAfter, "InsertAfter", py::arg("theItem"), py::arg("theIter"));
	cls_BOPTools_ListOfCoupleOfShape.def("InsertAfter", (void (BOPTools_ListOfCoupleOfShape::*)(BOPTools_ListOfCoupleOfShape &, BOPTools_ListOfCoupleOfShape::Iterator &)) &BOPTools_ListOfCoupleOfShape::InsertAfter, "InsertAfter", py::arg("theOther"), py::arg("theIter"));
	cls_BOPTools_ListOfCoupleOfShape.def("Reverse", (void (BOPTools_ListOfCoupleOfShape::*)()) &BOPTools_ListOfCoupleOfShape::Reverse, "Reverse the list");
	cls_BOPTools_ListOfCoupleOfShape.def("__iter__", [](const BOPTools_ListOfCoupleOfShape &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_TListIterator.hxx
	py::class_<BOPTools_ListIteratorOfListOfCoupleOfShape, std::unique_ptr<BOPTools_ListIteratorOfListOfCoupleOfShape, Deleter<BOPTools_ListIteratorOfListOfCoupleOfShape>>> cls_BOPTools_ListIteratorOfListOfCoupleOfShape(mod, "BOPTools_ListIteratorOfListOfCoupleOfShape", "Purpose: This Iterator class iterates on BaseList of TListNode and is instantiated in List/Set/Queue/Stack Remark: TListIterator is internal class");
	cls_BOPTools_ListIteratorOfListOfCoupleOfShape.def(py::init<>());
	cls_BOPTools_ListIteratorOfListOfCoupleOfShape.def(py::init<const NCollection_BaseList &>(), py::arg("theList"));
	cls_BOPTools_ListIteratorOfListOfCoupleOfShape.def("More", (Standard_Boolean (BOPTools_ListIteratorOfListOfCoupleOfShape::*)() const ) &BOPTools_ListIteratorOfListOfCoupleOfShape::More, "Check end");
	cls_BOPTools_ListIteratorOfListOfCoupleOfShape.def("Next", (void (BOPTools_ListIteratorOfListOfCoupleOfShape::*)()) &BOPTools_ListIteratorOfListOfCoupleOfShape::Next, "Make step");
	cls_BOPTools_ListIteratorOfListOfCoupleOfShape.def("Value", (const BOPTools_CoupleOfShape & (BOPTools_ListIteratorOfListOfCoupleOfShape::*)() const ) &BOPTools_ListIteratorOfListOfCoupleOfShape::Value, "Constant Value access");
	cls_BOPTools_ListIteratorOfListOfCoupleOfShape.def("Value", (BOPTools_CoupleOfShape & (BOPTools_ListIteratorOfListOfCoupleOfShape::*)()) &BOPTools_ListIteratorOfListOfCoupleOfShape::Value, "Non-const Value access");
	cls_BOPTools_ListIteratorOfListOfCoupleOfShape.def("ChangeValue", (BOPTools_CoupleOfShape & (BOPTools_ListIteratorOfListOfCoupleOfShape::*)() const ) &BOPTools_ListIteratorOfListOfCoupleOfShape::ChangeValue, "Non-const Value access");

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_DataMap.hxx
	py::class_<BOPTools_DataMapOfShapeSet, std::unique_ptr<BOPTools_DataMapOfShapeSet, Deleter<BOPTools_DataMapOfShapeSet>>, NCollection_BaseMap> cls_BOPTools_DataMapOfShapeSet(mod, "BOPTools_DataMapOfShapeSet", "Purpose: The DataMap is a Map to store keys with associated Items. See Map from NCollection for a discussion about the number of buckets.");
	cls_BOPTools_DataMapOfShapeSet.def(py::init<>());
	cls_BOPTools_DataMapOfShapeSet.def(py::init<const Standard_Integer>(), py::arg("NbBuckets"));
	cls_BOPTools_DataMapOfShapeSet.def(py::init<const Standard_Integer, const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("NbBuckets"), py::arg("theAllocator"));
	cls_BOPTools_DataMapOfShapeSet.def(py::init([] (const BOPTools_DataMapOfShapeSet &other) {return new BOPTools_DataMapOfShapeSet(other);}), "Copy constructor", py::arg("other"));
	cls_BOPTools_DataMapOfShapeSet.def("begin", (BOPTools_DataMapOfShapeSet::iterator (BOPTools_DataMapOfShapeSet::*)() const ) &BOPTools_DataMapOfShapeSet::begin, "Returns an iterator pointing to the first element in the map.");
	cls_BOPTools_DataMapOfShapeSet.def("end", (BOPTools_DataMapOfShapeSet::iterator (BOPTools_DataMapOfShapeSet::*)() const ) &BOPTools_DataMapOfShapeSet::end, "Returns an iterator referring to the past-the-end element in the map.");
	cls_BOPTools_DataMapOfShapeSet.def("cbegin", (BOPTools_DataMapOfShapeSet::const_iterator (BOPTools_DataMapOfShapeSet::*)() const ) &BOPTools_DataMapOfShapeSet::cbegin, "Returns a const iterator pointing to the first element in the map.");
	cls_BOPTools_DataMapOfShapeSet.def("cend", (BOPTools_DataMapOfShapeSet::const_iterator (BOPTools_DataMapOfShapeSet::*)() const ) &BOPTools_DataMapOfShapeSet::cend, "Returns a const iterator referring to the past-the-end element in the map.");
	cls_BOPTools_DataMapOfShapeSet.def("Exchange", (void (BOPTools_DataMapOfShapeSet::*)(BOPTools_DataMapOfShapeSet &)) &BOPTools_DataMapOfShapeSet::Exchange, "Exchange the content of two maps without re-allocations. Notice that allocators will be swapped as well!", py::arg("theOther"));
	cls_BOPTools_DataMapOfShapeSet.def("Assign", (BOPTools_DataMapOfShapeSet & (BOPTools_DataMapOfShapeSet::*)(const BOPTools_DataMapOfShapeSet &)) &BOPTools_DataMapOfShapeSet::Assign, "Assignment. This method does not change the internal allocator.", py::arg("theOther"));
	cls_BOPTools_DataMapOfShapeSet.def("assign", (BOPTools_DataMapOfShapeSet & (BOPTools_DataMapOfShapeSet::*)(const BOPTools_DataMapOfShapeSet &)) &BOPTools_DataMapOfShapeSet::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	cls_BOPTools_DataMapOfShapeSet.def("ReSize", (void (BOPTools_DataMapOfShapeSet::*)(const Standard_Integer)) &BOPTools_DataMapOfShapeSet::ReSize, "ReSize", py::arg("N"));
	cls_BOPTools_DataMapOfShapeSet.def("Bind", (Standard_Boolean (BOPTools_DataMapOfShapeSet::*)(const TopoDS_Shape &, const BOPTools_Set &)) &BOPTools_DataMapOfShapeSet::Bind, "Bind binds Item to Key in map. Returns Standard_True if Key was not exist in the map. If the Key was already bound, the Item will be rebinded and Standard_False will be returned.", py::arg("theKey"), py::arg("theItem"));
	// FIXME cls_BOPTools_DataMapOfShapeSet.def("Bound", (BOPTools_Set * (BOPTools_DataMapOfShapeSet::*)(const TopoDS_Shape &, const BOPTools_Set &)) &BOPTools_DataMapOfShapeSet::Bound, "Bound binds Item to Key in map. Returns modifiable Item", py::arg("theKey"), py::arg("theItem"));
	cls_BOPTools_DataMapOfShapeSet.def("IsBound", (Standard_Boolean (BOPTools_DataMapOfShapeSet::*)(const TopoDS_Shape &) const ) &BOPTools_DataMapOfShapeSet::IsBound, "IsBound", py::arg("theKey"));
	cls_BOPTools_DataMapOfShapeSet.def("UnBind", (Standard_Boolean (BOPTools_DataMapOfShapeSet::*)(const TopoDS_Shape &)) &BOPTools_DataMapOfShapeSet::UnBind, "UnBind removes Item Key pair from map", py::arg("theKey"));
	// FIXME cls_BOPTools_DataMapOfShapeSet.def("Seek", (const BOPTools_Set * (BOPTools_DataMapOfShapeSet::*)(const TopoDS_Shape &) const ) &BOPTools_DataMapOfShapeSet::Seek, "Seek returns pointer to Item by Key. Returns NULL is Key was not bound.", py::arg("theKey"));
	// FIXME cls_BOPTools_DataMapOfShapeSet.def("Find", (const BOPTools_Set & (BOPTools_DataMapOfShapeSet::*)(const TopoDS_Shape &) const ) &BOPTools_DataMapOfShapeSet::Find, "Find returns the Item for Key. Raises if Key was not bound", py::arg("theKey"));
	// FIXME cls_BOPTools_DataMapOfShapeSet.def("Find", (Standard_Boolean (BOPTools_DataMapOfShapeSet::*)(const TopoDS_Shape &, BOPTools_Set &) const ) &BOPTools_DataMapOfShapeSet::Find, "Find Item for key with copying.", py::arg("theKey"), py::arg("theValue"));
	cls_BOPTools_DataMapOfShapeSet.def("__call__", (const BOPTools_Set & (BOPTools_DataMapOfShapeSet::*)(const TopoDS_Shape &) const ) &BOPTools_DataMapOfShapeSet::operator(), py::is_operator(), "operator ()", py::arg("theKey"));
	// FIXME cls_BOPTools_DataMapOfShapeSet.def("ChangeSeek", (BOPTools_Set * (BOPTools_DataMapOfShapeSet::*)(const TopoDS_Shape &)) &BOPTools_DataMapOfShapeSet::ChangeSeek, "ChangeSeek returns modifiable pointer to Item by Key. Returns NULL is Key was not bound.", py::arg("theKey"));
	cls_BOPTools_DataMapOfShapeSet.def("ChangeFind", (BOPTools_Set & (BOPTools_DataMapOfShapeSet::*)(const TopoDS_Shape &)) &BOPTools_DataMapOfShapeSet::ChangeFind, "ChangeFind returns mofifiable Item by Key. Raises if Key was not bound", py::arg("theKey"));
	cls_BOPTools_DataMapOfShapeSet.def("__call__", (BOPTools_Set & (BOPTools_DataMapOfShapeSet::*)(const TopoDS_Shape &)) &BOPTools_DataMapOfShapeSet::operator(), py::is_operator(), "operator ()", py::arg("theKey"));
	cls_BOPTools_DataMapOfShapeSet.def("Clear", [](BOPTools_DataMapOfShapeSet &self) -> void { return self.Clear(); });
	cls_BOPTools_DataMapOfShapeSet.def("Clear", (void (BOPTools_DataMapOfShapeSet::*)(const Standard_Boolean)) &BOPTools_DataMapOfShapeSet::Clear, "Clear data. If doReleaseMemory is false then the table of buckets is not released and will be reused.", py::arg("doReleaseMemory"));
	cls_BOPTools_DataMapOfShapeSet.def("Clear", (void (BOPTools_DataMapOfShapeSet::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &BOPTools_DataMapOfShapeSet::Clear, "Clear data and reset allocator", py::arg("theAllocator"));
	cls_BOPTools_DataMapOfShapeSet.def("Size", (Standard_Integer (BOPTools_DataMapOfShapeSet::*)() const ) &BOPTools_DataMapOfShapeSet::Size, "Size");
	cls_BOPTools_DataMapOfShapeSet.def("__iter__", [](const BOPTools_DataMapOfShapeSet &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\BOPTools_DataMapOfShapeSet.hxx
	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_List.hxx
	py::class_<BOPTools_ListOfEdgeSet, std::unique_ptr<BOPTools_ListOfEdgeSet, Deleter<BOPTools_ListOfEdgeSet>>, NCollection_BaseList> cls_BOPTools_ListOfEdgeSet(mod, "BOPTools_ListOfEdgeSet", "Purpose: Simple list to link items together keeping the first and the last one. Inherits BaseList, adding the data item to each node.");
	cls_BOPTools_ListOfEdgeSet.def(py::init<>());
	cls_BOPTools_ListOfEdgeSet.def(py::init<const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("theAllocator"));
	cls_BOPTools_ListOfEdgeSet.def(py::init([] (const BOPTools_ListOfEdgeSet &other) {return new BOPTools_ListOfEdgeSet(other);}), "Copy constructor", py::arg("other"));
	cls_BOPTools_ListOfEdgeSet.def("begin", (BOPTools_ListOfEdgeSet::iterator (BOPTools_ListOfEdgeSet::*)() const ) &BOPTools_ListOfEdgeSet::begin, "Returns an iterator pointing to the first element in the list.");
	cls_BOPTools_ListOfEdgeSet.def("end", (BOPTools_ListOfEdgeSet::iterator (BOPTools_ListOfEdgeSet::*)() const ) &BOPTools_ListOfEdgeSet::end, "Returns an iterator referring to the past-the-end element in the list.");
	cls_BOPTools_ListOfEdgeSet.def("cbegin", (BOPTools_ListOfEdgeSet::const_iterator (BOPTools_ListOfEdgeSet::*)() const ) &BOPTools_ListOfEdgeSet::cbegin, "Returns a const iterator pointing to the first element in the list.");
	cls_BOPTools_ListOfEdgeSet.def("cend", (BOPTools_ListOfEdgeSet::const_iterator (BOPTools_ListOfEdgeSet::*)() const ) &BOPTools_ListOfEdgeSet::cend, "Returns a const iterator referring to the past-the-end element in the list.");
	cls_BOPTools_ListOfEdgeSet.def("Size", (Standard_Integer (BOPTools_ListOfEdgeSet::*)() const ) &BOPTools_ListOfEdgeSet::Size, "Size - Number of items");
	cls_BOPTools_ListOfEdgeSet.def("Assign", (BOPTools_ListOfEdgeSet & (BOPTools_ListOfEdgeSet::*)(const BOPTools_ListOfEdgeSet &)) &BOPTools_ListOfEdgeSet::Assign, "Replace this list by the items of another list (theOther parameter). This method does not change the internal allocator.", py::arg("theOther"));
	cls_BOPTools_ListOfEdgeSet.def("assign", (BOPTools_ListOfEdgeSet & (BOPTools_ListOfEdgeSet::*)(const BOPTools_ListOfEdgeSet &)) &BOPTools_ListOfEdgeSet::operator=, py::is_operator(), "Replacement operator", py::arg("theOther"));
	cls_BOPTools_ListOfEdgeSet.def("Clear", [](BOPTools_ListOfEdgeSet &self) -> void { return self.Clear(); });
	cls_BOPTools_ListOfEdgeSet.def("Clear", (void (BOPTools_ListOfEdgeSet::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &BOPTools_ListOfEdgeSet::Clear, "Clear this list", py::arg("theAllocator"));
	cls_BOPTools_ListOfEdgeSet.def("First", (const BOPTools_EdgeSet & (BOPTools_ListOfEdgeSet::*)() const ) &BOPTools_ListOfEdgeSet::First, "First item");
	cls_BOPTools_ListOfEdgeSet.def("First", (BOPTools_EdgeSet & (BOPTools_ListOfEdgeSet::*)()) &BOPTools_ListOfEdgeSet::First, "First item (non-const)");
	cls_BOPTools_ListOfEdgeSet.def("Last", (const BOPTools_EdgeSet & (BOPTools_ListOfEdgeSet::*)() const ) &BOPTools_ListOfEdgeSet::Last, "Last item");
	cls_BOPTools_ListOfEdgeSet.def("Last", (BOPTools_EdgeSet & (BOPTools_ListOfEdgeSet::*)()) &BOPTools_ListOfEdgeSet::Last, "Last item (non-const)");
	cls_BOPTools_ListOfEdgeSet.def("Append", (BOPTools_EdgeSet & (BOPTools_ListOfEdgeSet::*)(const BOPTools_EdgeSet &)) &BOPTools_ListOfEdgeSet::Append, "Append one item at the end", py::arg("theItem"));
	cls_BOPTools_ListOfEdgeSet.def("Append", (void (BOPTools_ListOfEdgeSet::*)(const BOPTools_EdgeSet &, BOPTools_ListOfEdgeSet::Iterator &)) &BOPTools_ListOfEdgeSet::Append, "Append one item at the end and output iterator pointing at the appended item", py::arg("theItem"), py::arg("theIter"));
	cls_BOPTools_ListOfEdgeSet.def("Append", (void (BOPTools_ListOfEdgeSet::*)(BOPTools_ListOfEdgeSet &)) &BOPTools_ListOfEdgeSet::Append, "Append another list at the end", py::arg("theOther"));
	cls_BOPTools_ListOfEdgeSet.def("Prepend", (BOPTools_EdgeSet & (BOPTools_ListOfEdgeSet::*)(const BOPTools_EdgeSet &)) &BOPTools_ListOfEdgeSet::Prepend, "Prepend one item at the beginning", py::arg("theItem"));
	cls_BOPTools_ListOfEdgeSet.def("Prepend", (void (BOPTools_ListOfEdgeSet::*)(BOPTools_ListOfEdgeSet &)) &BOPTools_ListOfEdgeSet::Prepend, "Prepend another list at the beginning", py::arg("theOther"));
	cls_BOPTools_ListOfEdgeSet.def("RemoveFirst", (void (BOPTools_ListOfEdgeSet::*)()) &BOPTools_ListOfEdgeSet::RemoveFirst, "RemoveFirst item");
	cls_BOPTools_ListOfEdgeSet.def("Remove", (void (BOPTools_ListOfEdgeSet::*)(BOPTools_ListOfEdgeSet::Iterator &)) &BOPTools_ListOfEdgeSet::Remove, "Remove item pointed by iterator theIter; theIter is then set to the next item", py::arg("theIter"));
	cls_BOPTools_ListOfEdgeSet.def("InsertBefore", (BOPTools_EdgeSet & (BOPTools_ListOfEdgeSet::*)(const BOPTools_EdgeSet &, BOPTools_ListOfEdgeSet::Iterator &)) &BOPTools_ListOfEdgeSet::InsertBefore, "InsertBefore", py::arg("theItem"), py::arg("theIter"));
	cls_BOPTools_ListOfEdgeSet.def("InsertBefore", (void (BOPTools_ListOfEdgeSet::*)(BOPTools_ListOfEdgeSet &, BOPTools_ListOfEdgeSet::Iterator &)) &BOPTools_ListOfEdgeSet::InsertBefore, "InsertBefore", py::arg("theOther"), py::arg("theIter"));
	cls_BOPTools_ListOfEdgeSet.def("InsertAfter", (BOPTools_EdgeSet & (BOPTools_ListOfEdgeSet::*)(const BOPTools_EdgeSet &, BOPTools_ListOfEdgeSet::Iterator &)) &BOPTools_ListOfEdgeSet::InsertAfter, "InsertAfter", py::arg("theItem"), py::arg("theIter"));
	cls_BOPTools_ListOfEdgeSet.def("InsertAfter", (void (BOPTools_ListOfEdgeSet::*)(BOPTools_ListOfEdgeSet &, BOPTools_ListOfEdgeSet::Iterator &)) &BOPTools_ListOfEdgeSet::InsertAfter, "InsertAfter", py::arg("theOther"), py::arg("theIter"));
	cls_BOPTools_ListOfEdgeSet.def("Reverse", (void (BOPTools_ListOfEdgeSet::*)()) &BOPTools_ListOfEdgeSet::Reverse, "Reverse the list");
	cls_BOPTools_ListOfEdgeSet.def("__iter__", [](const BOPTools_ListOfEdgeSet &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_TListIterator.hxx
	py::class_<BOPTools_ListIteratorOfListOfEdgeSet, std::unique_ptr<BOPTools_ListIteratorOfListOfEdgeSet, Deleter<BOPTools_ListIteratorOfListOfEdgeSet>>> cls_BOPTools_ListIteratorOfListOfEdgeSet(mod, "BOPTools_ListIteratorOfListOfEdgeSet", "Purpose: This Iterator class iterates on BaseList of TListNode and is instantiated in List/Set/Queue/Stack Remark: TListIterator is internal class");
	cls_BOPTools_ListIteratorOfListOfEdgeSet.def(py::init<>());
	cls_BOPTools_ListIteratorOfListOfEdgeSet.def(py::init<const NCollection_BaseList &>(), py::arg("theList"));
	cls_BOPTools_ListIteratorOfListOfEdgeSet.def("More", (Standard_Boolean (BOPTools_ListIteratorOfListOfEdgeSet::*)() const ) &BOPTools_ListIteratorOfListOfEdgeSet::More, "Check end");
	cls_BOPTools_ListIteratorOfListOfEdgeSet.def("Next", (void (BOPTools_ListIteratorOfListOfEdgeSet::*)()) &BOPTools_ListIteratorOfListOfEdgeSet::Next, "Make step");
	cls_BOPTools_ListIteratorOfListOfEdgeSet.def("Value", (const BOPTools_EdgeSet & (BOPTools_ListIteratorOfListOfEdgeSet::*)() const ) &BOPTools_ListIteratorOfListOfEdgeSet::Value, "Constant Value access");
	cls_BOPTools_ListIteratorOfListOfEdgeSet.def("Value", (BOPTools_EdgeSet & (BOPTools_ListIteratorOfListOfEdgeSet::*)()) &BOPTools_ListIteratorOfListOfEdgeSet::Value, "Non-const Value access");
	cls_BOPTools_ListIteratorOfListOfEdgeSet.def("ChangeValue", (BOPTools_EdgeSet & (BOPTools_ListIteratorOfListOfEdgeSet::*)() const ) &BOPTools_ListIteratorOfListOfEdgeSet::ChangeValue, "Non-const Value access");

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_List.hxx
	py::class_<BOPTools_ListOfShapeSet, std::unique_ptr<BOPTools_ListOfShapeSet, Deleter<BOPTools_ListOfShapeSet>>, NCollection_BaseList> cls_BOPTools_ListOfShapeSet(mod, "BOPTools_ListOfShapeSet", "Purpose: Simple list to link items together keeping the first and the last one. Inherits BaseList, adding the data item to each node.");
	cls_BOPTools_ListOfShapeSet.def(py::init<>());
	cls_BOPTools_ListOfShapeSet.def(py::init<const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("theAllocator"));
	cls_BOPTools_ListOfShapeSet.def(py::init([] (const BOPTools_ListOfShapeSet &other) {return new BOPTools_ListOfShapeSet(other);}), "Copy constructor", py::arg("other"));
	cls_BOPTools_ListOfShapeSet.def("begin", (BOPTools_ListOfShapeSet::iterator (BOPTools_ListOfShapeSet::*)() const ) &BOPTools_ListOfShapeSet::begin, "Returns an iterator pointing to the first element in the list.");
	cls_BOPTools_ListOfShapeSet.def("end", (BOPTools_ListOfShapeSet::iterator (BOPTools_ListOfShapeSet::*)() const ) &BOPTools_ListOfShapeSet::end, "Returns an iterator referring to the past-the-end element in the list.");
	cls_BOPTools_ListOfShapeSet.def("cbegin", (BOPTools_ListOfShapeSet::const_iterator (BOPTools_ListOfShapeSet::*)() const ) &BOPTools_ListOfShapeSet::cbegin, "Returns a const iterator pointing to the first element in the list.");
	cls_BOPTools_ListOfShapeSet.def("cend", (BOPTools_ListOfShapeSet::const_iterator (BOPTools_ListOfShapeSet::*)() const ) &BOPTools_ListOfShapeSet::cend, "Returns a const iterator referring to the past-the-end element in the list.");
	cls_BOPTools_ListOfShapeSet.def("Size", (Standard_Integer (BOPTools_ListOfShapeSet::*)() const ) &BOPTools_ListOfShapeSet::Size, "Size - Number of items");
	cls_BOPTools_ListOfShapeSet.def("Assign", (BOPTools_ListOfShapeSet & (BOPTools_ListOfShapeSet::*)(const BOPTools_ListOfShapeSet &)) &BOPTools_ListOfShapeSet::Assign, "Replace this list by the items of another list (theOther parameter). This method does not change the internal allocator.", py::arg("theOther"));
	cls_BOPTools_ListOfShapeSet.def("assign", (BOPTools_ListOfShapeSet & (BOPTools_ListOfShapeSet::*)(const BOPTools_ListOfShapeSet &)) &BOPTools_ListOfShapeSet::operator=, py::is_operator(), "Replacement operator", py::arg("theOther"));
	cls_BOPTools_ListOfShapeSet.def("Clear", [](BOPTools_ListOfShapeSet &self) -> void { return self.Clear(); });
	cls_BOPTools_ListOfShapeSet.def("Clear", (void (BOPTools_ListOfShapeSet::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &BOPTools_ListOfShapeSet::Clear, "Clear this list", py::arg("theAllocator"));
	cls_BOPTools_ListOfShapeSet.def("First", (const BOPTools_ShapeSet & (BOPTools_ListOfShapeSet::*)() const ) &BOPTools_ListOfShapeSet::First, "First item");
	cls_BOPTools_ListOfShapeSet.def("First", (BOPTools_ShapeSet & (BOPTools_ListOfShapeSet::*)()) &BOPTools_ListOfShapeSet::First, "First item (non-const)");
	cls_BOPTools_ListOfShapeSet.def("Last", (const BOPTools_ShapeSet & (BOPTools_ListOfShapeSet::*)() const ) &BOPTools_ListOfShapeSet::Last, "Last item");
	cls_BOPTools_ListOfShapeSet.def("Last", (BOPTools_ShapeSet & (BOPTools_ListOfShapeSet::*)()) &BOPTools_ListOfShapeSet::Last, "Last item (non-const)");
	cls_BOPTools_ListOfShapeSet.def("Append", (BOPTools_ShapeSet & (BOPTools_ListOfShapeSet::*)(const BOPTools_ShapeSet &)) &BOPTools_ListOfShapeSet::Append, "Append one item at the end", py::arg("theItem"));
	cls_BOPTools_ListOfShapeSet.def("Append", (void (BOPTools_ListOfShapeSet::*)(const BOPTools_ShapeSet &, BOPTools_ListOfShapeSet::Iterator &)) &BOPTools_ListOfShapeSet::Append, "Append one item at the end and output iterator pointing at the appended item", py::arg("theItem"), py::arg("theIter"));
	cls_BOPTools_ListOfShapeSet.def("Append", (void (BOPTools_ListOfShapeSet::*)(BOPTools_ListOfShapeSet &)) &BOPTools_ListOfShapeSet::Append, "Append another list at the end", py::arg("theOther"));
	cls_BOPTools_ListOfShapeSet.def("Prepend", (BOPTools_ShapeSet & (BOPTools_ListOfShapeSet::*)(const BOPTools_ShapeSet &)) &BOPTools_ListOfShapeSet::Prepend, "Prepend one item at the beginning", py::arg("theItem"));
	cls_BOPTools_ListOfShapeSet.def("Prepend", (void (BOPTools_ListOfShapeSet::*)(BOPTools_ListOfShapeSet &)) &BOPTools_ListOfShapeSet::Prepend, "Prepend another list at the beginning", py::arg("theOther"));
	cls_BOPTools_ListOfShapeSet.def("RemoveFirst", (void (BOPTools_ListOfShapeSet::*)()) &BOPTools_ListOfShapeSet::RemoveFirst, "RemoveFirst item");
	cls_BOPTools_ListOfShapeSet.def("Remove", (void (BOPTools_ListOfShapeSet::*)(BOPTools_ListOfShapeSet::Iterator &)) &BOPTools_ListOfShapeSet::Remove, "Remove item pointed by iterator theIter; theIter is then set to the next item", py::arg("theIter"));
	cls_BOPTools_ListOfShapeSet.def("InsertBefore", (BOPTools_ShapeSet & (BOPTools_ListOfShapeSet::*)(const BOPTools_ShapeSet &, BOPTools_ListOfShapeSet::Iterator &)) &BOPTools_ListOfShapeSet::InsertBefore, "InsertBefore", py::arg("theItem"), py::arg("theIter"));
	cls_BOPTools_ListOfShapeSet.def("InsertBefore", (void (BOPTools_ListOfShapeSet::*)(BOPTools_ListOfShapeSet &, BOPTools_ListOfShapeSet::Iterator &)) &BOPTools_ListOfShapeSet::InsertBefore, "InsertBefore", py::arg("theOther"), py::arg("theIter"));
	cls_BOPTools_ListOfShapeSet.def("InsertAfter", (BOPTools_ShapeSet & (BOPTools_ListOfShapeSet::*)(const BOPTools_ShapeSet &, BOPTools_ListOfShapeSet::Iterator &)) &BOPTools_ListOfShapeSet::InsertAfter, "InsertAfter", py::arg("theItem"), py::arg("theIter"));
	cls_BOPTools_ListOfShapeSet.def("InsertAfter", (void (BOPTools_ListOfShapeSet::*)(BOPTools_ListOfShapeSet &, BOPTools_ListOfShapeSet::Iterator &)) &BOPTools_ListOfShapeSet::InsertAfter, "InsertAfter", py::arg("theOther"), py::arg("theIter"));
	cls_BOPTools_ListOfShapeSet.def("Reverse", (void (BOPTools_ListOfShapeSet::*)()) &BOPTools_ListOfShapeSet::Reverse, "Reverse the list");
	cls_BOPTools_ListOfShapeSet.def("__iter__", [](const BOPTools_ListOfShapeSet &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_TListIterator.hxx
	py::class_<BOPTools_ListIteratorOfListOfShapeSet, std::unique_ptr<BOPTools_ListIteratorOfListOfShapeSet, Deleter<BOPTools_ListIteratorOfListOfShapeSet>>> cls_BOPTools_ListIteratorOfListOfShapeSet(mod, "BOPTools_ListIteratorOfListOfShapeSet", "Purpose: This Iterator class iterates on BaseList of TListNode and is instantiated in List/Set/Queue/Stack Remark: TListIterator is internal class");
	cls_BOPTools_ListIteratorOfListOfShapeSet.def(py::init<>());
	cls_BOPTools_ListIteratorOfListOfShapeSet.def(py::init<const NCollection_BaseList &>(), py::arg("theList"));
	cls_BOPTools_ListIteratorOfListOfShapeSet.def("More", (Standard_Boolean (BOPTools_ListIteratorOfListOfShapeSet::*)() const ) &BOPTools_ListIteratorOfListOfShapeSet::More, "Check end");
	cls_BOPTools_ListIteratorOfListOfShapeSet.def("Next", (void (BOPTools_ListIteratorOfListOfShapeSet::*)()) &BOPTools_ListIteratorOfListOfShapeSet::Next, "Make step");
	cls_BOPTools_ListIteratorOfListOfShapeSet.def("Value", (const BOPTools_ShapeSet & (BOPTools_ListIteratorOfListOfShapeSet::*)() const ) &BOPTools_ListIteratorOfListOfShapeSet::Value, "Constant Value access");
	cls_BOPTools_ListIteratorOfListOfShapeSet.def("Value", (BOPTools_ShapeSet & (BOPTools_ListIteratorOfListOfShapeSet::*)()) &BOPTools_ListIteratorOfListOfShapeSet::Value, "Non-const Value access");
	cls_BOPTools_ListIteratorOfListOfShapeSet.def("ChangeValue", (BOPTools_ShapeSet & (BOPTools_ListIteratorOfListOfShapeSet::*)() const ) &BOPTools_ListIteratorOfListOfShapeSet::ChangeValue, "Non-const Value access");

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_Map.hxx
	py::class_<BOPTools_MapOfSet, std::unique_ptr<BOPTools_MapOfSet, Deleter<BOPTools_MapOfSet>>, NCollection_BaseMap> cls_BOPTools_MapOfSet(mod, "BOPTools_MapOfSet", "Purpose: Single hashed Map. This Map is used to store and retrieve keys in linear time.");
	cls_BOPTools_MapOfSet.def(py::init<>());
	cls_BOPTools_MapOfSet.def(py::init<const Standard_Integer>(), py::arg("NbBuckets"));
	cls_BOPTools_MapOfSet.def(py::init<const Standard_Integer, const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("NbBuckets"), py::arg("theAllocator"));
	cls_BOPTools_MapOfSet.def(py::init([] (const BOPTools_MapOfSet &other) {return new BOPTools_MapOfSet(other);}), "Copy constructor", py::arg("other"));
	cls_BOPTools_MapOfSet.def("cbegin", (BOPTools_MapOfSet::const_iterator (BOPTools_MapOfSet::*)() const ) &BOPTools_MapOfSet::cbegin, "Returns a const iterator pointing to the first element in the map.");
	cls_BOPTools_MapOfSet.def("cend", (BOPTools_MapOfSet::const_iterator (BOPTools_MapOfSet::*)() const ) &BOPTools_MapOfSet::cend, "Returns a const iterator referring to the past-the-end element in the map.");
	cls_BOPTools_MapOfSet.def("Exchange", (void (BOPTools_MapOfSet::*)(BOPTools_MapOfSet &)) &BOPTools_MapOfSet::Exchange, "Exchange the content of two maps without re-allocations. Notice that allocators will be swapped as well!", py::arg("theOther"));
	cls_BOPTools_MapOfSet.def("Assign", (BOPTools_MapOfSet & (BOPTools_MapOfSet::*)(const BOPTools_MapOfSet &)) &BOPTools_MapOfSet::Assign, "Assign. This method does not change the internal allocator.", py::arg("theOther"));
	cls_BOPTools_MapOfSet.def("assign", (BOPTools_MapOfSet & (BOPTools_MapOfSet::*)(const BOPTools_MapOfSet &)) &BOPTools_MapOfSet::operator=, py::is_operator(), "Assign operator", py::arg("theOther"));
	cls_BOPTools_MapOfSet.def("ReSize", (void (BOPTools_MapOfSet::*)(const Standard_Integer)) &BOPTools_MapOfSet::ReSize, "ReSize", py::arg("N"));
	cls_BOPTools_MapOfSet.def("Add", (Standard_Boolean (BOPTools_MapOfSet::*)(const BOPTools_Set &)) &BOPTools_MapOfSet::Add, "Add", py::arg("K"));
	cls_BOPTools_MapOfSet.def("Added", (const BOPTools_Set & (BOPTools_MapOfSet::*)(const BOPTools_Set &)) &BOPTools_MapOfSet::Added, "Added: add a new key if not yet in the map, and return reference to either newly added or previously existing object", py::arg("K"));
	cls_BOPTools_MapOfSet.def("Contains", (Standard_Boolean (BOPTools_MapOfSet::*)(const BOPTools_Set &) const ) &BOPTools_MapOfSet::Contains, "Contains", py::arg("K"));
	cls_BOPTools_MapOfSet.def("Remove", (Standard_Boolean (BOPTools_MapOfSet::*)(const BOPTools_Set &)) &BOPTools_MapOfSet::Remove, "Remove", py::arg("K"));
	cls_BOPTools_MapOfSet.def("Clear", [](BOPTools_MapOfSet &self) -> void { return self.Clear(); });
	cls_BOPTools_MapOfSet.def("Clear", (void (BOPTools_MapOfSet::*)(const Standard_Boolean)) &BOPTools_MapOfSet::Clear, "Clear data. If doReleaseMemory is false then the table of buckets is not released and will be reused.", py::arg("doReleaseMemory"));
	cls_BOPTools_MapOfSet.def("Clear", (void (BOPTools_MapOfSet::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &BOPTools_MapOfSet::Clear, "Clear data and reset allocator", py::arg("theAllocator"));
	cls_BOPTools_MapOfSet.def("Size", (Standard_Integer (BOPTools_MapOfSet::*)() const ) &BOPTools_MapOfSet::Size, "Size");
	cls_BOPTools_MapOfSet.def("IsEqual", (Standard_Boolean (BOPTools_MapOfSet::*)(const BOPTools_MapOfSet &) const ) &BOPTools_MapOfSet::IsEqual, "Returns true if two maps contains exactly the same keys", py::arg("theOther"));
	cls_BOPTools_MapOfSet.def("Contains", (Standard_Boolean (BOPTools_MapOfSet::*)(const BOPTools_MapOfSet &) const ) &BOPTools_MapOfSet::Contains, "Returns true if this map contains ALL keys of another map.", py::arg("theOther"));
	cls_BOPTools_MapOfSet.def("Union", (void (BOPTools_MapOfSet::*)(const BOPTools_MapOfSet &, const BOPTools_MapOfSet &)) &BOPTools_MapOfSet::Union, "Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps The new Map contains the values that are contained either in the first map or in the second map or in both. All previous content of this Map is cleared. This map (result of the boolean operation) can also be passed as one of operands.", py::arg("theLeft"), py::arg("theRight"));
	cls_BOPTools_MapOfSet.def("Unite", (Standard_Boolean (BOPTools_MapOfSet::*)(const BOPTools_MapOfSet &)) &BOPTools_MapOfSet::Unite, "Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map. The result contains the values that were previously contained in this map or contained in the given (operand) map. This algorithm is similar to method Union(). Returns True if contents of this map is changed.", py::arg("theOther"));
	cls_BOPTools_MapOfSet.def("HasIntersection", (Standard_Boolean (BOPTools_MapOfSet::*)(const BOPTools_MapOfSet &) const ) &BOPTools_MapOfSet::HasIntersection, "Returns true if this and theMap have common elements.", py::arg("theMap"));
	cls_BOPTools_MapOfSet.def("Intersection", (void (BOPTools_MapOfSet::*)(const BOPTools_MapOfSet &, const BOPTools_MapOfSet &)) &BOPTools_MapOfSet::Intersection, "Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps. The new Map contains only the values that are contained in both map operands. All previous content of this Map is cleared. This same map (result of the boolean operation) can also be used as one of operands.", py::arg("theLeft"), py::arg("theRight"));
	cls_BOPTools_MapOfSet.def("Intersect", (Standard_Boolean (BOPTools_MapOfSet::*)(const BOPTools_MapOfSet &)) &BOPTools_MapOfSet::Intersect, "Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map. The result contains only the values that are contained in both this and the given maps. This algorithm is similar to method Intersection(). Returns True if contents of this map is changed.", py::arg("theOther"));
	cls_BOPTools_MapOfSet.def("Subtraction", (void (BOPTools_MapOfSet::*)(const BOPTools_MapOfSet &, const BOPTools_MapOfSet &)) &BOPTools_MapOfSet::Subtraction, "Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement, exclude, cut, boolean NOT) operation between two given Maps. The new Map contains only the values that are contained in the first map operands and not contained in the second one. All previous content of this Map is cleared.", py::arg("theLeft"), py::arg("theRight"));
	cls_BOPTools_MapOfSet.def("Subtract", (Standard_Boolean (BOPTools_MapOfSet::*)(const BOPTools_MapOfSet &)) &BOPTools_MapOfSet::Subtract, "Apply to this Map the subtraction (aka set-theoretic difference, relative complement, exclude, cut, boolean NOT) operation with another (given) Map. The result contains only the values that were previously contained in this map and not contained in this map. This algorithm is similar to method Subtract() with two operands. Returns True if contents of this map is changed.", py::arg("theOther"));
	cls_BOPTools_MapOfSet.def("Difference", (void (BOPTools_MapOfSet::*)(const BOPTools_MapOfSet &, const BOPTools_MapOfSet &)) &BOPTools_MapOfSet::Difference, "Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps. The new Map contains the values that are contained only in the first or the second operand maps but not in both. All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands.", py::arg("theLeft"), py::arg("theRight"));
	cls_BOPTools_MapOfSet.def("Differ", (Standard_Boolean (BOPTools_MapOfSet::*)(const BOPTools_MapOfSet &)) &BOPTools_MapOfSet::Differ, "Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map. The result contains the values that are contained only in this or the operand map, but not in both. This algorithm is similar to method Difference(). Returns True if contents of this map is changed.", py::arg("theOther"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\BOPTools_MapOfSet.hxx

}
