#include <pybind11/pybind11.h>
namespace py = pybind11;

#include <Standard_Handle.hxx>
PYBIND11_DECLARE_HOLDER_TYPE(T, opencascade::handle<T>, true);
PYBIND11_DECLARE_HOLDER_TYPE(T, T*);
using opencascade::handle;

// Deleter template for mixed holder types with public/hidden destructors.
template<typename T> struct Deleter { void operator() (T *o) const { delete o; } };

#include <Standard_Transient.hxx>
#include <Standard_Handle.hxx>
#include <TCollection_HAsciiString.hxx>
#include <StepRepr_RepresentationItem.hxx>
#include <StepRepr_Representation.hxx>
#include <Standard_Type.hxx>
#include <StepElement_AnalysisItemWithinRepresentation.hxx>
#include <StepElement_ElementDescriptor.hxx>
#include <StepElement_ElementOrder.hxx>
#include <StepElement_HArray1OfHSequenceOfCurveElementPurposeMember.hxx>
#include <StepElement_Curve3dElementDescriptor.hxx>
#include <StepElement_CurveElementFreedom.hxx>
#include <Standard_TypeDef.hxx>
#include <StepElement_CurveElementEndReleasePacket.hxx>
#include <StepElement_CurveElementSectionDefinition.hxx>
#include <StepElement_HArray1OfMeasureOrUnspecifiedValue.hxx>
#include <TColStd_HArray1OfReal.hxx>
#include <StepElement_MeasureOrUnspecifiedValue.hxx>
#include <StepElement_CurveElementSectionDerivedDefinitions.hxx>
#include <StepRepr_HArray1OfMaterialPropertyRepresentation.hxx>
#include <StepElement_ElementMaterial.hxx>
#include <StepElement_HArray1OfHSequenceOfSurfaceElementPurposeMember.hxx>
#include <StepElement_Element2dShape.hxx>
#include <StepElement_Surface3dElementDescriptor.hxx>
#include <StepElement_SurfaceSectionField.hxx>
#include <StepElement_SurfaceElementProperty.hxx>
#include <StepElement_SurfaceSection.hxx>
#include <StepElement_SurfaceSectionFieldConstant.hxx>
#include <StepElement_HArray1OfSurfaceSection.hxx>
#include <StepElement_SurfaceSectionFieldVarying.hxx>
#include <StepElement_UniformSurfaceSection.hxx>
#include <StepElement_HArray1OfVolumeElementPurposeMember.hxx>
#include <StepElement_Volume3dElementShape.hxx>
#include <StepElement_Volume3dElementDescriptor.hxx>
#include <NCollection_BaseSequence.hxx>
#include <NCollection_BaseAllocator.hxx>
#include <NCollection_Sequence.hxx>
#include <StepElement_SequenceOfElementMaterial.hxx>
#include <StepElement_HSequenceOfElementMaterial.hxx>
#include <StepElement_ElementVolume.hxx>
#include <StepElement_CurveEdge.hxx>
#include <StepData_SelectType.hxx>
#include <StepData_SelectMember.hxx>
#include <StepElement_ElementAspect.hxx>
#include <StepElement_SequenceOfCurveElementSectionDefinition.hxx>
#include <StepElement_HSequenceOfCurveElementSectionDefinition.hxx>
#include <StepElement_EnumeratedCurveElementFreedom.hxx>
#include <NCollection_Array1.hxx>
#include <StepElement_Array1OfCurveElementEndReleasePacket.hxx>
#include <StepElement_Array1OfCurveElementSectionDefinition.hxx>
#include <StepData_SelectNamed.hxx>
#include <StepElement_CurveElementPurposeMember.hxx>
#include <StepElement_SequenceOfCurveElementPurposeMember.hxx>
#include <StepElement_HSequenceOfCurveElementPurposeMember.hxx>
#include <StepElement_Array1OfHSequenceOfCurveElementPurposeMember.hxx>
#include <StepElement_SurfaceElementPurposeMember.hxx>
#include <StepElement_SequenceOfSurfaceElementPurposeMember.hxx>
#include <StepElement_HSequenceOfSurfaceElementPurposeMember.hxx>
#include <StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.hxx>
#include <StepElement_UnspecifiedValue.hxx>
#include <StepElement_Array1OfMeasureOrUnspecifiedValue.hxx>
#include <StepElement_Array1OfSurfaceSection.hxx>
#include <StepElement_EnumeratedVolumeElementPurpose.hxx>
#include <StepElement_VolumeElementPurpose.hxx>
#include <StepElement_Array1OfVolumeElementPurpose.hxx>
#include <StepElement_VolumeElementPurposeMember.hxx>
#include <StepElement_Array1OfVolumeElementPurposeMember.hxx>
#include <NCollection_Array2.hxx>
#include <StepElement_Array2OfCurveElementPurposeMember.hxx>
#include <StepElement_EnumeratedSurfaceElementPurpose.hxx>
#include <StepElement_SurfaceElementPurpose.hxx>
#include <StepElement_Array2OfSurfaceElementPurpose.hxx>
#include <StepElement_Array2OfSurfaceElementPurposeMember.hxx>
#include <StepElement_CurveElementFreedomMember.hxx>
#include <StepElement_EnumeratedCurveElementPurpose.hxx>
#include <StepElement_CurveElementPurpose.hxx>
#include <StepElement_ElementAspectMember.hxx>
#include <StepElement_HArray1OfCurveElementEndReleasePacket.hxx>
#include <StepElement_HArray1OfCurveElementSectionDefinition.hxx>
#include <StepElement_HArray1OfVolumeElementPurpose.hxx>
#include <StepElement_HArray2OfCurveElementPurposeMember.hxx>
#include <StepElement_HArray2OfSurfaceElementPurpose.hxx>
#include <StepElement_HArray2OfSurfaceElementPurposeMember.hxx>
#include <StepElement_MeasureOrUnspecifiedValueMember.hxx>

PYBIND11_MODULE(StepElement, mod) {

	// IMPORT
	py::module::import("OCCT.Standard");
	py::module::import("OCCT.TCollection");
	py::module::import("OCCT.StepRepr");
	py::module::import("OCCT.TColStd");
	py::module::import("OCCT.NCollection");
	py::module::import("OCCT.StepData");

	py::module other_mod;

	// IMPORT GUARDS

	// ENUMS
	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_ElementVolume.hxx
	py::enum_<StepElement_ElementVolume>(mod, "StepElement_ElementVolume", "None")
		.value("StepElement_Volume", StepElement_ElementVolume::StepElement_Volume)
		.export_values();
	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_CurveEdge.hxx
	py::enum_<StepElement_CurveEdge>(mod, "StepElement_CurveEdge", "None")
		.value("StepElement_ElementEdge", StepElement_CurveEdge::StepElement_ElementEdge)
		.export_values();
	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_EnumeratedCurveElementFreedom.hxx
	py::enum_<StepElement_EnumeratedCurveElementFreedom>(mod, "StepElement_EnumeratedCurveElementFreedom", "None")
		.value("StepElement_XTranslation", StepElement_EnumeratedCurveElementFreedom::StepElement_XTranslation)
		.value("StepElement_YTranslation", StepElement_EnumeratedCurveElementFreedom::StepElement_YTranslation)
		.value("StepElement_ZTranslation", StepElement_EnumeratedCurveElementFreedom::StepElement_ZTranslation)
		.value("StepElement_XRotation", StepElement_EnumeratedCurveElementFreedom::StepElement_XRotation)
		.value("StepElement_YRotation", StepElement_EnumeratedCurveElementFreedom::StepElement_YRotation)
		.value("StepElement_ZRotation", StepElement_EnumeratedCurveElementFreedom::StepElement_ZRotation)
		.value("StepElement_Warp", StepElement_EnumeratedCurveElementFreedom::StepElement_Warp)
		.value("StepElement_None", StepElement_EnumeratedCurveElementFreedom::StepElement_None)
		.export_values();
	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_UnspecifiedValue.hxx
	py::enum_<StepElement_UnspecifiedValue>(mod, "StepElement_UnspecifiedValue", "None")
		.value("StepElement_Unspecified", StepElement_UnspecifiedValue::StepElement_Unspecified)
		.export_values();
	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_EnumeratedVolumeElementPurpose.hxx
	py::enum_<StepElement_EnumeratedVolumeElementPurpose>(mod, "StepElement_EnumeratedVolumeElementPurpose", "None")
		.value("StepElement_StressDisplacement", StepElement_EnumeratedVolumeElementPurpose::StepElement_StressDisplacement)
		.export_values();
	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_EnumeratedSurfaceElementPurpose.hxx
	py::enum_<StepElement_EnumeratedSurfaceElementPurpose>(mod, "StepElement_EnumeratedSurfaceElementPurpose", "None")
		.value("StepElement_MembraneDirect", StepElement_EnumeratedSurfaceElementPurpose::StepElement_MembraneDirect)
		.value("StepElement_MembraneShear", StepElement_EnumeratedSurfaceElementPurpose::StepElement_MembraneShear)
		.value("StepElement_BendingDirect", StepElement_EnumeratedSurfaceElementPurpose::StepElement_BendingDirect)
		.value("StepElement_BendingTorsion", StepElement_EnumeratedSurfaceElementPurpose::StepElement_BendingTorsion)
		.value("StepElement_NormalToPlaneShear", StepElement_EnumeratedSurfaceElementPurpose::StepElement_NormalToPlaneShear)
		.export_values();
	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_ElementOrder.hxx
	py::enum_<StepElement_ElementOrder>(mod, "StepElement_ElementOrder", "None")
		.value("StepElement_Linear", StepElement_ElementOrder::StepElement_Linear)
		.value("StepElement_Quadratic", StepElement_ElementOrder::StepElement_Quadratic)
		.value("StepElement_Cubic", StepElement_ElementOrder::StepElement_Cubic)
		.export_values();
	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_EnumeratedCurveElementPurpose.hxx
	py::enum_<StepElement_EnumeratedCurveElementPurpose>(mod, "StepElement_EnumeratedCurveElementPurpose", "None")
		.value("StepElement_Axial", StepElement_EnumeratedCurveElementPurpose::StepElement_Axial)
		.value("StepElement_YYBending", StepElement_EnumeratedCurveElementPurpose::StepElement_YYBending)
		.value("StepElement_ZZBending", StepElement_EnumeratedCurveElementPurpose::StepElement_ZZBending)
		.value("StepElement_Torsion", StepElement_EnumeratedCurveElementPurpose::StepElement_Torsion)
		.value("StepElement_XYShear", StepElement_EnumeratedCurveElementPurpose::StepElement_XYShear)
		.value("StepElement_XZShear", StepElement_EnumeratedCurveElementPurpose::StepElement_XZShear)
		.value("StepElement_Warping", StepElement_EnumeratedCurveElementPurpose::StepElement_Warping)
		.export_values();
	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_Element2dShape.hxx
	py::enum_<StepElement_Element2dShape>(mod, "StepElement_Element2dShape", "None")
		.value("StepElement_Quadrilateral", StepElement_Element2dShape::StepElement_Quadrilateral)
		.value("StepElement_Triangle", StepElement_Element2dShape::StepElement_Triangle)
		.export_values();
	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_Volume3dElementShape.hxx
	py::enum_<StepElement_Volume3dElementShape>(mod, "StepElement_Volume3dElementShape", "None")
		.value("StepElement_Hexahedron", StepElement_Volume3dElementShape::StepElement_Hexahedron)
		.value("StepElement_Wedge", StepElement_Volume3dElementShape::StepElement_Wedge)
		.value("StepElement_Tetrahedron", StepElement_Volume3dElementShape::StepElement_Tetrahedron)
		.value("StepElement_Pyramid", StepElement_Volume3dElementShape::StepElement_Pyramid)
		.export_values();

	// FUNCTIONS

	// CLASSES
	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_AnalysisItemWithinRepresentation.hxx
	py::class_<StepElement_AnalysisItemWithinRepresentation, opencascade::handle<StepElement_AnalysisItemWithinRepresentation>, Standard_Transient> cls_StepElement_AnalysisItemWithinRepresentation(mod, "StepElement_AnalysisItemWithinRepresentation", "Representation of STEP entity AnalysisItemWithinRepresentation");
	cls_StepElement_AnalysisItemWithinRepresentation.def(py::init<>());
	cls_StepElement_AnalysisItemWithinRepresentation.def("Init", (void (StepElement_AnalysisItemWithinRepresentation::*)(const opencascade::handle<TCollection_HAsciiString> &, const opencascade::handle<TCollection_HAsciiString> &, const opencascade::handle<StepRepr_RepresentationItem> &, const opencascade::handle<StepRepr_Representation> &)) &StepElement_AnalysisItemWithinRepresentation::Init, "Initialize all fields (own and inherited)", py::arg("aName"), py::arg("aDescription"), py::arg("aItem"), py::arg("aRep"));
	cls_StepElement_AnalysisItemWithinRepresentation.def("Name", (opencascade::handle<TCollection_HAsciiString> (StepElement_AnalysisItemWithinRepresentation::*)() const ) &StepElement_AnalysisItemWithinRepresentation::Name, "Returns field Name");
	cls_StepElement_AnalysisItemWithinRepresentation.def("SetName", (void (StepElement_AnalysisItemWithinRepresentation::*)(const opencascade::handle<TCollection_HAsciiString> &)) &StepElement_AnalysisItemWithinRepresentation::SetName, "Set field Name", py::arg("Name"));
	cls_StepElement_AnalysisItemWithinRepresentation.def("Description", (opencascade::handle<TCollection_HAsciiString> (StepElement_AnalysisItemWithinRepresentation::*)() const ) &StepElement_AnalysisItemWithinRepresentation::Description, "Returns field Description");
	cls_StepElement_AnalysisItemWithinRepresentation.def("SetDescription", (void (StepElement_AnalysisItemWithinRepresentation::*)(const opencascade::handle<TCollection_HAsciiString> &)) &StepElement_AnalysisItemWithinRepresentation::SetDescription, "Set field Description", py::arg("Description"));
	cls_StepElement_AnalysisItemWithinRepresentation.def("Item", (opencascade::handle<StepRepr_RepresentationItem> (StepElement_AnalysisItemWithinRepresentation::*)() const ) &StepElement_AnalysisItemWithinRepresentation::Item, "Returns field Item");
	cls_StepElement_AnalysisItemWithinRepresentation.def("SetItem", (void (StepElement_AnalysisItemWithinRepresentation::*)(const opencascade::handle<StepRepr_RepresentationItem> &)) &StepElement_AnalysisItemWithinRepresentation::SetItem, "Set field Item", py::arg("Item"));
	cls_StepElement_AnalysisItemWithinRepresentation.def("Rep", (opencascade::handle<StepRepr_Representation> (StepElement_AnalysisItemWithinRepresentation::*)() const ) &StepElement_AnalysisItemWithinRepresentation::Rep, "Returns field Rep");
	cls_StepElement_AnalysisItemWithinRepresentation.def("SetRep", (void (StepElement_AnalysisItemWithinRepresentation::*)(const opencascade::handle<StepRepr_Representation> &)) &StepElement_AnalysisItemWithinRepresentation::SetRep, "Set field Rep", py::arg("Rep"));
	cls_StepElement_AnalysisItemWithinRepresentation.def_static("get_type_name_", (const char * (*)()) &StepElement_AnalysisItemWithinRepresentation::get_type_name, "None");
	cls_StepElement_AnalysisItemWithinRepresentation.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_AnalysisItemWithinRepresentation::get_type_descriptor, "None");
	cls_StepElement_AnalysisItemWithinRepresentation.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_AnalysisItemWithinRepresentation::*)() const ) &StepElement_AnalysisItemWithinRepresentation::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_ElementDescriptor.hxx
	py::class_<StepElement_ElementDescriptor, opencascade::handle<StepElement_ElementDescriptor>, Standard_Transient> cls_StepElement_ElementDescriptor(mod, "StepElement_ElementDescriptor", "Representation of STEP entity ElementDescriptor");
	cls_StepElement_ElementDescriptor.def(py::init<>());
	cls_StepElement_ElementDescriptor.def("Init", (void (StepElement_ElementDescriptor::*)(const StepElement_ElementOrder, const opencascade::handle<TCollection_HAsciiString> &)) &StepElement_ElementDescriptor::Init, "Initialize all fields (own and inherited)", py::arg("aTopologyOrder"), py::arg("aDescription"));
	cls_StepElement_ElementDescriptor.def("TopologyOrder", (StepElement_ElementOrder (StepElement_ElementDescriptor::*)() const ) &StepElement_ElementDescriptor::TopologyOrder, "Returns field TopologyOrder");
	cls_StepElement_ElementDescriptor.def("SetTopologyOrder", (void (StepElement_ElementDescriptor::*)(const StepElement_ElementOrder)) &StepElement_ElementDescriptor::SetTopologyOrder, "Set field TopologyOrder", py::arg("TopologyOrder"));
	cls_StepElement_ElementDescriptor.def("Description", (opencascade::handle<TCollection_HAsciiString> (StepElement_ElementDescriptor::*)() const ) &StepElement_ElementDescriptor::Description, "Returns field Description");
	cls_StepElement_ElementDescriptor.def("SetDescription", (void (StepElement_ElementDescriptor::*)(const opencascade::handle<TCollection_HAsciiString> &)) &StepElement_ElementDescriptor::SetDescription, "Set field Description", py::arg("Description"));
	cls_StepElement_ElementDescriptor.def_static("get_type_name_", (const char * (*)()) &StepElement_ElementDescriptor::get_type_name, "None");
	cls_StepElement_ElementDescriptor.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_ElementDescriptor::get_type_descriptor, "None");
	cls_StepElement_ElementDescriptor.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_ElementDescriptor::*)() const ) &StepElement_ElementDescriptor::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_CurveElementEndReleasePacket.hxx
	py::class_<StepElement_CurveElementEndReleasePacket, opencascade::handle<StepElement_CurveElementEndReleasePacket>, Standard_Transient> cls_StepElement_CurveElementEndReleasePacket(mod, "StepElement_CurveElementEndReleasePacket", "Representation of STEP entity CurveElementEndReleasePacket");
	cls_StepElement_CurveElementEndReleasePacket.def(py::init<>());
	cls_StepElement_CurveElementEndReleasePacket.def("Init", (void (StepElement_CurveElementEndReleasePacket::*)(const StepElement_CurveElementFreedom &, const Standard_Real)) &StepElement_CurveElementEndReleasePacket::Init, "Initialize all fields (own and inherited)", py::arg("aReleaseFreedom"), py::arg("aReleaseStiffness"));
	cls_StepElement_CurveElementEndReleasePacket.def("ReleaseFreedom", (StepElement_CurveElementFreedom (StepElement_CurveElementEndReleasePacket::*)() const ) &StepElement_CurveElementEndReleasePacket::ReleaseFreedom, "Returns field ReleaseFreedom");
	cls_StepElement_CurveElementEndReleasePacket.def("SetReleaseFreedom", (void (StepElement_CurveElementEndReleasePacket::*)(const StepElement_CurveElementFreedom &)) &StepElement_CurveElementEndReleasePacket::SetReleaseFreedom, "Set field ReleaseFreedom", py::arg("ReleaseFreedom"));
	cls_StepElement_CurveElementEndReleasePacket.def("ReleaseStiffness", (Standard_Real (StepElement_CurveElementEndReleasePacket::*)() const ) &StepElement_CurveElementEndReleasePacket::ReleaseStiffness, "Returns field ReleaseStiffness");
	cls_StepElement_CurveElementEndReleasePacket.def("SetReleaseStiffness", (void (StepElement_CurveElementEndReleasePacket::*)(const Standard_Real)) &StepElement_CurveElementEndReleasePacket::SetReleaseStiffness, "Set field ReleaseStiffness", py::arg("ReleaseStiffness"));
	cls_StepElement_CurveElementEndReleasePacket.def_static("get_type_name_", (const char * (*)()) &StepElement_CurveElementEndReleasePacket::get_type_name, "None");
	cls_StepElement_CurveElementEndReleasePacket.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_CurveElementEndReleasePacket::get_type_descriptor, "None");
	cls_StepElement_CurveElementEndReleasePacket.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_CurveElementEndReleasePacket::*)() const ) &StepElement_CurveElementEndReleasePacket::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_CurveElementSectionDefinition.hxx
	py::class_<StepElement_CurveElementSectionDefinition, opencascade::handle<StepElement_CurveElementSectionDefinition>, Standard_Transient> cls_StepElement_CurveElementSectionDefinition(mod, "StepElement_CurveElementSectionDefinition", "Representation of STEP entity CurveElementSectionDefinition");
	cls_StepElement_CurveElementSectionDefinition.def(py::init<>());
	cls_StepElement_CurveElementSectionDefinition.def("Init", (void (StepElement_CurveElementSectionDefinition::*)(const opencascade::handle<TCollection_HAsciiString> &, const Standard_Real)) &StepElement_CurveElementSectionDefinition::Init, "Initialize all fields (own and inherited)", py::arg("aDescription"), py::arg("aSectionAngle"));
	cls_StepElement_CurveElementSectionDefinition.def("Description", (opencascade::handle<TCollection_HAsciiString> (StepElement_CurveElementSectionDefinition::*)() const ) &StepElement_CurveElementSectionDefinition::Description, "Returns field Description");
	cls_StepElement_CurveElementSectionDefinition.def("SetDescription", (void (StepElement_CurveElementSectionDefinition::*)(const opencascade::handle<TCollection_HAsciiString> &)) &StepElement_CurveElementSectionDefinition::SetDescription, "Set field Description", py::arg("Description"));
	cls_StepElement_CurveElementSectionDefinition.def("SectionAngle", (Standard_Real (StepElement_CurveElementSectionDefinition::*)() const ) &StepElement_CurveElementSectionDefinition::SectionAngle, "Returns field SectionAngle");
	cls_StepElement_CurveElementSectionDefinition.def("SetSectionAngle", (void (StepElement_CurveElementSectionDefinition::*)(const Standard_Real)) &StepElement_CurveElementSectionDefinition::SetSectionAngle, "Set field SectionAngle", py::arg("SectionAngle"));
	cls_StepElement_CurveElementSectionDefinition.def_static("get_type_name_", (const char * (*)()) &StepElement_CurveElementSectionDefinition::get_type_name, "None");
	cls_StepElement_CurveElementSectionDefinition.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_CurveElementSectionDefinition::get_type_descriptor, "None");
	cls_StepElement_CurveElementSectionDefinition.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_CurveElementSectionDefinition::*)() const ) &StepElement_CurveElementSectionDefinition::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_CurveElementSectionDerivedDefinitions.hxx
	py::class_<StepElement_CurveElementSectionDerivedDefinitions, opencascade::handle<StepElement_CurveElementSectionDerivedDefinitions>, StepElement_CurveElementSectionDefinition> cls_StepElement_CurveElementSectionDerivedDefinitions(mod, "StepElement_CurveElementSectionDerivedDefinitions", "Representation of STEP entity CurveElementSectionDerivedDefinitions");
	cls_StepElement_CurveElementSectionDerivedDefinitions.def(py::init<>());
	cls_StepElement_CurveElementSectionDerivedDefinitions.def("Init", (void (StepElement_CurveElementSectionDerivedDefinitions::*)(const opencascade::handle<TCollection_HAsciiString> &, const Standard_Real, const Standard_Real, const opencascade::handle<StepElement_HArray1OfMeasureOrUnspecifiedValue> &, const opencascade::handle<TColStd_HArray1OfReal> &, const Standard_Real, const StepElement_MeasureOrUnspecifiedValue &, const opencascade::handle<StepElement_HArray1OfMeasureOrUnspecifiedValue> &, const opencascade::handle<StepElement_HArray1OfMeasureOrUnspecifiedValue> &, const opencascade::handle<StepElement_HArray1OfMeasureOrUnspecifiedValue> &, const StepElement_MeasureOrUnspecifiedValue &, const StepElement_MeasureOrUnspecifiedValue &)) &StepElement_CurveElementSectionDerivedDefinitions::Init, "Initialize all fields (own and inherited)", py::arg("aCurveElementSectionDefinition_Description"), py::arg("aCurveElementSectionDefinition_SectionAngle"), py::arg("aCrossSectionalArea"), py::arg("aShearArea"), py::arg("aSecondMomentOfArea"), py::arg("aTorsionalConstant"), py::arg("aWarpingConstant"), py::arg("aLocationOfCentroid"), py::arg("aLocationOfShearCentre"), py::arg("aLocationOfNonStructuralMass"), py::arg("aNonStructuralMass"), py::arg("aPolarMoment"));
	cls_StepElement_CurveElementSectionDerivedDefinitions.def("CrossSectionalArea", (Standard_Real (StepElement_CurveElementSectionDerivedDefinitions::*)() const ) &StepElement_CurveElementSectionDerivedDefinitions::CrossSectionalArea, "Returns field CrossSectionalArea");
	cls_StepElement_CurveElementSectionDerivedDefinitions.def("SetCrossSectionalArea", (void (StepElement_CurveElementSectionDerivedDefinitions::*)(const Standard_Real)) &StepElement_CurveElementSectionDerivedDefinitions::SetCrossSectionalArea, "Set field CrossSectionalArea", py::arg("CrossSectionalArea"));
	cls_StepElement_CurveElementSectionDerivedDefinitions.def("ShearArea", (opencascade::handle<StepElement_HArray1OfMeasureOrUnspecifiedValue> (StepElement_CurveElementSectionDerivedDefinitions::*)() const ) &StepElement_CurveElementSectionDerivedDefinitions::ShearArea, "Returns field ShearArea");
	cls_StepElement_CurveElementSectionDerivedDefinitions.def("SetShearArea", (void (StepElement_CurveElementSectionDerivedDefinitions::*)(const opencascade::handle<StepElement_HArray1OfMeasureOrUnspecifiedValue> &)) &StepElement_CurveElementSectionDerivedDefinitions::SetShearArea, "Set field ShearArea", py::arg("ShearArea"));
	cls_StepElement_CurveElementSectionDerivedDefinitions.def("SecondMomentOfArea", (opencascade::handle<TColStd_HArray1OfReal> (StepElement_CurveElementSectionDerivedDefinitions::*)() const ) &StepElement_CurveElementSectionDerivedDefinitions::SecondMomentOfArea, "Returns field SecondMomentOfArea");
	cls_StepElement_CurveElementSectionDerivedDefinitions.def("SetSecondMomentOfArea", (void (StepElement_CurveElementSectionDerivedDefinitions::*)(const opencascade::handle<TColStd_HArray1OfReal> &)) &StepElement_CurveElementSectionDerivedDefinitions::SetSecondMomentOfArea, "Set field SecondMomentOfArea", py::arg("SecondMomentOfArea"));
	cls_StepElement_CurveElementSectionDerivedDefinitions.def("TorsionalConstant", (Standard_Real (StepElement_CurveElementSectionDerivedDefinitions::*)() const ) &StepElement_CurveElementSectionDerivedDefinitions::TorsionalConstant, "Returns field TorsionalConstant");
	cls_StepElement_CurveElementSectionDerivedDefinitions.def("SetTorsionalConstant", (void (StepElement_CurveElementSectionDerivedDefinitions::*)(const Standard_Real)) &StepElement_CurveElementSectionDerivedDefinitions::SetTorsionalConstant, "Set field TorsionalConstant", py::arg("TorsionalConstant"));
	cls_StepElement_CurveElementSectionDerivedDefinitions.def("WarpingConstant", (StepElement_MeasureOrUnspecifiedValue (StepElement_CurveElementSectionDerivedDefinitions::*)() const ) &StepElement_CurveElementSectionDerivedDefinitions::WarpingConstant, "Returns field WarpingConstant");
	cls_StepElement_CurveElementSectionDerivedDefinitions.def("SetWarpingConstant", (void (StepElement_CurveElementSectionDerivedDefinitions::*)(const StepElement_MeasureOrUnspecifiedValue &)) &StepElement_CurveElementSectionDerivedDefinitions::SetWarpingConstant, "Set field WarpingConstant", py::arg("WarpingConstant"));
	cls_StepElement_CurveElementSectionDerivedDefinitions.def("LocationOfCentroid", (opencascade::handle<StepElement_HArray1OfMeasureOrUnspecifiedValue> (StepElement_CurveElementSectionDerivedDefinitions::*)() const ) &StepElement_CurveElementSectionDerivedDefinitions::LocationOfCentroid, "Returns field LocationOfCentroid");
	cls_StepElement_CurveElementSectionDerivedDefinitions.def("SetLocationOfCentroid", (void (StepElement_CurveElementSectionDerivedDefinitions::*)(const opencascade::handle<StepElement_HArray1OfMeasureOrUnspecifiedValue> &)) &StepElement_CurveElementSectionDerivedDefinitions::SetLocationOfCentroid, "Set field LocationOfCentroid", py::arg("LocationOfCentroid"));
	cls_StepElement_CurveElementSectionDerivedDefinitions.def("LocationOfShearCentre", (opencascade::handle<StepElement_HArray1OfMeasureOrUnspecifiedValue> (StepElement_CurveElementSectionDerivedDefinitions::*)() const ) &StepElement_CurveElementSectionDerivedDefinitions::LocationOfShearCentre, "Returns field LocationOfShearCentre");
	cls_StepElement_CurveElementSectionDerivedDefinitions.def("SetLocationOfShearCentre", (void (StepElement_CurveElementSectionDerivedDefinitions::*)(const opencascade::handle<StepElement_HArray1OfMeasureOrUnspecifiedValue> &)) &StepElement_CurveElementSectionDerivedDefinitions::SetLocationOfShearCentre, "Set field LocationOfShearCentre", py::arg("LocationOfShearCentre"));
	cls_StepElement_CurveElementSectionDerivedDefinitions.def("LocationOfNonStructuralMass", (opencascade::handle<StepElement_HArray1OfMeasureOrUnspecifiedValue> (StepElement_CurveElementSectionDerivedDefinitions::*)() const ) &StepElement_CurveElementSectionDerivedDefinitions::LocationOfNonStructuralMass, "Returns field LocationOfNonStructuralMass");
	cls_StepElement_CurveElementSectionDerivedDefinitions.def("SetLocationOfNonStructuralMass", (void (StepElement_CurveElementSectionDerivedDefinitions::*)(const opencascade::handle<StepElement_HArray1OfMeasureOrUnspecifiedValue> &)) &StepElement_CurveElementSectionDerivedDefinitions::SetLocationOfNonStructuralMass, "Set field LocationOfNonStructuralMass", py::arg("LocationOfNonStructuralMass"));
	cls_StepElement_CurveElementSectionDerivedDefinitions.def("NonStructuralMass", (StepElement_MeasureOrUnspecifiedValue (StepElement_CurveElementSectionDerivedDefinitions::*)() const ) &StepElement_CurveElementSectionDerivedDefinitions::NonStructuralMass, "Returns field NonStructuralMass");
	cls_StepElement_CurveElementSectionDerivedDefinitions.def("SetNonStructuralMass", (void (StepElement_CurveElementSectionDerivedDefinitions::*)(const StepElement_MeasureOrUnspecifiedValue &)) &StepElement_CurveElementSectionDerivedDefinitions::SetNonStructuralMass, "Set field NonStructuralMass", py::arg("NonStructuralMass"));
	cls_StepElement_CurveElementSectionDerivedDefinitions.def("PolarMoment", (StepElement_MeasureOrUnspecifiedValue (StepElement_CurveElementSectionDerivedDefinitions::*)() const ) &StepElement_CurveElementSectionDerivedDefinitions::PolarMoment, "Returns field PolarMoment");
	cls_StepElement_CurveElementSectionDerivedDefinitions.def("SetPolarMoment", (void (StepElement_CurveElementSectionDerivedDefinitions::*)(const StepElement_MeasureOrUnspecifiedValue &)) &StepElement_CurveElementSectionDerivedDefinitions::SetPolarMoment, "Set field PolarMoment", py::arg("PolarMoment"));
	cls_StepElement_CurveElementSectionDerivedDefinitions.def_static("get_type_name_", (const char * (*)()) &StepElement_CurveElementSectionDerivedDefinitions::get_type_name, "None");
	cls_StepElement_CurveElementSectionDerivedDefinitions.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_CurveElementSectionDerivedDefinitions::get_type_descriptor, "None");
	cls_StepElement_CurveElementSectionDerivedDefinitions.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_CurveElementSectionDerivedDefinitions::*)() const ) &StepElement_CurveElementSectionDerivedDefinitions::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_Curve3dElementDescriptor.hxx
	py::class_<StepElement_Curve3dElementDescriptor, opencascade::handle<StepElement_Curve3dElementDescriptor>, StepElement_ElementDescriptor> cls_StepElement_Curve3dElementDescriptor(mod, "StepElement_Curve3dElementDescriptor", "Representation of STEP entity Curve3dElementDescriptor");
	cls_StepElement_Curve3dElementDescriptor.def(py::init<>());
	cls_StepElement_Curve3dElementDescriptor.def("Init", (void (StepElement_Curve3dElementDescriptor::*)(const StepElement_ElementOrder, const opencascade::handle<TCollection_HAsciiString> &, const opencascade::handle<StepElement_HArray1OfHSequenceOfCurveElementPurposeMember> &)) &StepElement_Curve3dElementDescriptor::Init, "Initialize all fields (own and inherited)", py::arg("aElementDescriptor_TopologyOrder"), py::arg("aElementDescriptor_Description"), py::arg("aPurpose"));
	cls_StepElement_Curve3dElementDescriptor.def("Purpose", (opencascade::handle<StepElement_HArray1OfHSequenceOfCurveElementPurposeMember> (StepElement_Curve3dElementDescriptor::*)() const ) &StepElement_Curve3dElementDescriptor::Purpose, "Returns field Purpose");
	cls_StepElement_Curve3dElementDescriptor.def("SetPurpose", (void (StepElement_Curve3dElementDescriptor::*)(const opencascade::handle<StepElement_HArray1OfHSequenceOfCurveElementPurposeMember> &)) &StepElement_Curve3dElementDescriptor::SetPurpose, "Set field Purpose", py::arg("Purpose"));
	cls_StepElement_Curve3dElementDescriptor.def_static("get_type_name_", (const char * (*)()) &StepElement_Curve3dElementDescriptor::get_type_name, "None");
	cls_StepElement_Curve3dElementDescriptor.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_Curve3dElementDescriptor::get_type_descriptor, "None");
	cls_StepElement_Curve3dElementDescriptor.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_Curve3dElementDescriptor::*)() const ) &StepElement_Curve3dElementDescriptor::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_ElementMaterial.hxx
	py::class_<StepElement_ElementMaterial, opencascade::handle<StepElement_ElementMaterial>, Standard_Transient> cls_StepElement_ElementMaterial(mod, "StepElement_ElementMaterial", "Representation of STEP entity ElementMaterial");
	cls_StepElement_ElementMaterial.def(py::init<>());
	cls_StepElement_ElementMaterial.def("Init", (void (StepElement_ElementMaterial::*)(const opencascade::handle<TCollection_HAsciiString> &, const opencascade::handle<TCollection_HAsciiString> &, const opencascade::handle<StepRepr_HArray1OfMaterialPropertyRepresentation> &)) &StepElement_ElementMaterial::Init, "Initialize all fields (own and inherited)", py::arg("aMaterialId"), py::arg("aDescription"), py::arg("aProperties"));
	cls_StepElement_ElementMaterial.def("MaterialId", (opencascade::handle<TCollection_HAsciiString> (StepElement_ElementMaterial::*)() const ) &StepElement_ElementMaterial::MaterialId, "Returns field MaterialId");
	cls_StepElement_ElementMaterial.def("SetMaterialId", (void (StepElement_ElementMaterial::*)(const opencascade::handle<TCollection_HAsciiString> &)) &StepElement_ElementMaterial::SetMaterialId, "Set field MaterialId", py::arg("MaterialId"));
	cls_StepElement_ElementMaterial.def("Description", (opencascade::handle<TCollection_HAsciiString> (StepElement_ElementMaterial::*)() const ) &StepElement_ElementMaterial::Description, "Returns field Description");
	cls_StepElement_ElementMaterial.def("SetDescription", (void (StepElement_ElementMaterial::*)(const opencascade::handle<TCollection_HAsciiString> &)) &StepElement_ElementMaterial::SetDescription, "Set field Description", py::arg("Description"));
	cls_StepElement_ElementMaterial.def("Properties", (opencascade::handle<StepRepr_HArray1OfMaterialPropertyRepresentation> (StepElement_ElementMaterial::*)() const ) &StepElement_ElementMaterial::Properties, "Returns field Properties");
	cls_StepElement_ElementMaterial.def("SetProperties", (void (StepElement_ElementMaterial::*)(const opencascade::handle<StepRepr_HArray1OfMaterialPropertyRepresentation> &)) &StepElement_ElementMaterial::SetProperties, "Set field Properties", py::arg("Properties"));
	cls_StepElement_ElementMaterial.def_static("get_type_name_", (const char * (*)()) &StepElement_ElementMaterial::get_type_name, "None");
	cls_StepElement_ElementMaterial.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_ElementMaterial::get_type_descriptor, "None");
	cls_StepElement_ElementMaterial.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_ElementMaterial::*)() const ) &StepElement_ElementMaterial::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_Surface3dElementDescriptor.hxx
	py::class_<StepElement_Surface3dElementDescriptor, opencascade::handle<StepElement_Surface3dElementDescriptor>, StepElement_ElementDescriptor> cls_StepElement_Surface3dElementDescriptor(mod, "StepElement_Surface3dElementDescriptor", "Representation of STEP entity Surface3dElementDescriptor");
	cls_StepElement_Surface3dElementDescriptor.def(py::init<>());
	cls_StepElement_Surface3dElementDescriptor.def("Init", (void (StepElement_Surface3dElementDescriptor::*)(const StepElement_ElementOrder, const opencascade::handle<TCollection_HAsciiString> &, const opencascade::handle<StepElement_HArray1OfHSequenceOfSurfaceElementPurposeMember> &, const StepElement_Element2dShape)) &StepElement_Surface3dElementDescriptor::Init, "Initialize all fields (own and inherited)", py::arg("aElementDescriptor_TopologyOrder"), py::arg("aElementDescriptor_Description"), py::arg("aPurpose"), py::arg("aShape"));
	cls_StepElement_Surface3dElementDescriptor.def("Purpose", (opencascade::handle<StepElement_HArray1OfHSequenceOfSurfaceElementPurposeMember> (StepElement_Surface3dElementDescriptor::*)() const ) &StepElement_Surface3dElementDescriptor::Purpose, "Returns field Purpose");
	cls_StepElement_Surface3dElementDescriptor.def("SetPurpose", (void (StepElement_Surface3dElementDescriptor::*)(const opencascade::handle<StepElement_HArray1OfHSequenceOfSurfaceElementPurposeMember> &)) &StepElement_Surface3dElementDescriptor::SetPurpose, "Set field Purpose", py::arg("Purpose"));
	cls_StepElement_Surface3dElementDescriptor.def("Shape", (StepElement_Element2dShape (StepElement_Surface3dElementDescriptor::*)() const ) &StepElement_Surface3dElementDescriptor::Shape, "Returns field Shape");
	cls_StepElement_Surface3dElementDescriptor.def("SetShape", (void (StepElement_Surface3dElementDescriptor::*)(const StepElement_Element2dShape)) &StepElement_Surface3dElementDescriptor::SetShape, "Set field Shape", py::arg("Shape"));
	cls_StepElement_Surface3dElementDescriptor.def_static("get_type_name_", (const char * (*)()) &StepElement_Surface3dElementDescriptor::get_type_name, "None");
	cls_StepElement_Surface3dElementDescriptor.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_Surface3dElementDescriptor::get_type_descriptor, "None");
	cls_StepElement_Surface3dElementDescriptor.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_Surface3dElementDescriptor::*)() const ) &StepElement_Surface3dElementDescriptor::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_SurfaceElementProperty.hxx
	py::class_<StepElement_SurfaceElementProperty, opencascade::handle<StepElement_SurfaceElementProperty>, Standard_Transient> cls_StepElement_SurfaceElementProperty(mod, "StepElement_SurfaceElementProperty", "Representation of STEP entity SurfaceElementProperty");
	cls_StepElement_SurfaceElementProperty.def(py::init<>());
	cls_StepElement_SurfaceElementProperty.def("Init", (void (StepElement_SurfaceElementProperty::*)(const opencascade::handle<TCollection_HAsciiString> &, const opencascade::handle<TCollection_HAsciiString> &, const opencascade::handle<StepElement_SurfaceSectionField> &)) &StepElement_SurfaceElementProperty::Init, "Initialize all fields (own and inherited)", py::arg("aPropertyId"), py::arg("aDescription"), py::arg("aSection"));
	cls_StepElement_SurfaceElementProperty.def("PropertyId", (opencascade::handle<TCollection_HAsciiString> (StepElement_SurfaceElementProperty::*)() const ) &StepElement_SurfaceElementProperty::PropertyId, "Returns field PropertyId");
	cls_StepElement_SurfaceElementProperty.def("SetPropertyId", (void (StepElement_SurfaceElementProperty::*)(const opencascade::handle<TCollection_HAsciiString> &)) &StepElement_SurfaceElementProperty::SetPropertyId, "Set field PropertyId", py::arg("PropertyId"));
	cls_StepElement_SurfaceElementProperty.def("Description", (opencascade::handle<TCollection_HAsciiString> (StepElement_SurfaceElementProperty::*)() const ) &StepElement_SurfaceElementProperty::Description, "Returns field Description");
	cls_StepElement_SurfaceElementProperty.def("SetDescription", (void (StepElement_SurfaceElementProperty::*)(const opencascade::handle<TCollection_HAsciiString> &)) &StepElement_SurfaceElementProperty::SetDescription, "Set field Description", py::arg("Description"));
	cls_StepElement_SurfaceElementProperty.def("Section", (opencascade::handle<StepElement_SurfaceSectionField> (StepElement_SurfaceElementProperty::*)() const ) &StepElement_SurfaceElementProperty::Section, "Returns field Section");
	cls_StepElement_SurfaceElementProperty.def("SetSection", (void (StepElement_SurfaceElementProperty::*)(const opencascade::handle<StepElement_SurfaceSectionField> &)) &StepElement_SurfaceElementProperty::SetSection, "Set field Section", py::arg("Section"));
	cls_StepElement_SurfaceElementProperty.def_static("get_type_name_", (const char * (*)()) &StepElement_SurfaceElementProperty::get_type_name, "None");
	cls_StepElement_SurfaceElementProperty.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_SurfaceElementProperty::get_type_descriptor, "None");
	cls_StepElement_SurfaceElementProperty.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_SurfaceElementProperty::*)() const ) &StepElement_SurfaceElementProperty::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_SurfaceSection.hxx
	py::class_<StepElement_SurfaceSection, opencascade::handle<StepElement_SurfaceSection>, Standard_Transient> cls_StepElement_SurfaceSection(mod, "StepElement_SurfaceSection", "Representation of STEP entity SurfaceSection");
	cls_StepElement_SurfaceSection.def(py::init<>());
	cls_StepElement_SurfaceSection.def("Init", (void (StepElement_SurfaceSection::*)(const StepElement_MeasureOrUnspecifiedValue &, const StepElement_MeasureOrUnspecifiedValue &, const StepElement_MeasureOrUnspecifiedValue &)) &StepElement_SurfaceSection::Init, "Initialize all fields (own and inherited)", py::arg("aOffset"), py::arg("aNonStructuralMass"), py::arg("aNonStructuralMassOffset"));
	cls_StepElement_SurfaceSection.def("Offset", (StepElement_MeasureOrUnspecifiedValue (StepElement_SurfaceSection::*)() const ) &StepElement_SurfaceSection::Offset, "Returns field Offset");
	cls_StepElement_SurfaceSection.def("SetOffset", (void (StepElement_SurfaceSection::*)(const StepElement_MeasureOrUnspecifiedValue &)) &StepElement_SurfaceSection::SetOffset, "Set field Offset", py::arg("Offset"));
	cls_StepElement_SurfaceSection.def("NonStructuralMass", (StepElement_MeasureOrUnspecifiedValue (StepElement_SurfaceSection::*)() const ) &StepElement_SurfaceSection::NonStructuralMass, "Returns field NonStructuralMass");
	cls_StepElement_SurfaceSection.def("SetNonStructuralMass", (void (StepElement_SurfaceSection::*)(const StepElement_MeasureOrUnspecifiedValue &)) &StepElement_SurfaceSection::SetNonStructuralMass, "Set field NonStructuralMass", py::arg("NonStructuralMass"));
	cls_StepElement_SurfaceSection.def("NonStructuralMassOffset", (StepElement_MeasureOrUnspecifiedValue (StepElement_SurfaceSection::*)() const ) &StepElement_SurfaceSection::NonStructuralMassOffset, "Returns field NonStructuralMassOffset");
	cls_StepElement_SurfaceSection.def("SetNonStructuralMassOffset", (void (StepElement_SurfaceSection::*)(const StepElement_MeasureOrUnspecifiedValue &)) &StepElement_SurfaceSection::SetNonStructuralMassOffset, "Set field NonStructuralMassOffset", py::arg("NonStructuralMassOffset"));
	cls_StepElement_SurfaceSection.def_static("get_type_name_", (const char * (*)()) &StepElement_SurfaceSection::get_type_name, "None");
	cls_StepElement_SurfaceSection.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_SurfaceSection::get_type_descriptor, "None");
	cls_StepElement_SurfaceSection.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_SurfaceSection::*)() const ) &StepElement_SurfaceSection::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_SurfaceSectionField.hxx
	py::class_<StepElement_SurfaceSectionField, opencascade::handle<StepElement_SurfaceSectionField>, Standard_Transient> cls_StepElement_SurfaceSectionField(mod, "StepElement_SurfaceSectionField", "Representation of STEP entity SurfaceSectionField");
	cls_StepElement_SurfaceSectionField.def(py::init<>());
	cls_StepElement_SurfaceSectionField.def_static("get_type_name_", (const char * (*)()) &StepElement_SurfaceSectionField::get_type_name, "None");
	cls_StepElement_SurfaceSectionField.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_SurfaceSectionField::get_type_descriptor, "None");
	cls_StepElement_SurfaceSectionField.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_SurfaceSectionField::*)() const ) &StepElement_SurfaceSectionField::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_SurfaceSectionFieldConstant.hxx
	py::class_<StepElement_SurfaceSectionFieldConstant, opencascade::handle<StepElement_SurfaceSectionFieldConstant>, StepElement_SurfaceSectionField> cls_StepElement_SurfaceSectionFieldConstant(mod, "StepElement_SurfaceSectionFieldConstant", "Representation of STEP entity SurfaceSectionFieldConstant");
	cls_StepElement_SurfaceSectionFieldConstant.def(py::init<>());
	cls_StepElement_SurfaceSectionFieldConstant.def("Init", (void (StepElement_SurfaceSectionFieldConstant::*)(const opencascade::handle<StepElement_SurfaceSection> &)) &StepElement_SurfaceSectionFieldConstant::Init, "Initialize all fields (own and inherited)", py::arg("aDefinition"));
	cls_StepElement_SurfaceSectionFieldConstant.def("Definition", (opencascade::handle<StepElement_SurfaceSection> (StepElement_SurfaceSectionFieldConstant::*)() const ) &StepElement_SurfaceSectionFieldConstant::Definition, "Returns field Definition");
	cls_StepElement_SurfaceSectionFieldConstant.def("SetDefinition", (void (StepElement_SurfaceSectionFieldConstant::*)(const opencascade::handle<StepElement_SurfaceSection> &)) &StepElement_SurfaceSectionFieldConstant::SetDefinition, "Set field Definition", py::arg("Definition"));
	cls_StepElement_SurfaceSectionFieldConstant.def_static("get_type_name_", (const char * (*)()) &StepElement_SurfaceSectionFieldConstant::get_type_name, "None");
	cls_StepElement_SurfaceSectionFieldConstant.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_SurfaceSectionFieldConstant::get_type_descriptor, "None");
	cls_StepElement_SurfaceSectionFieldConstant.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_SurfaceSectionFieldConstant::*)() const ) &StepElement_SurfaceSectionFieldConstant::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_SurfaceSectionFieldVarying.hxx
	py::class_<StepElement_SurfaceSectionFieldVarying, opencascade::handle<StepElement_SurfaceSectionFieldVarying>, StepElement_SurfaceSectionField> cls_StepElement_SurfaceSectionFieldVarying(mod, "StepElement_SurfaceSectionFieldVarying", "Representation of STEP entity SurfaceSectionFieldVarying");
	cls_StepElement_SurfaceSectionFieldVarying.def(py::init<>());
	cls_StepElement_SurfaceSectionFieldVarying.def("Init", (void (StepElement_SurfaceSectionFieldVarying::*)(const opencascade::handle<StepElement_HArray1OfSurfaceSection> &, const Standard_Boolean)) &StepElement_SurfaceSectionFieldVarying::Init, "Initialize all fields (own and inherited)", py::arg("aDefinitions"), py::arg("aAdditionalNodeValues"));
	cls_StepElement_SurfaceSectionFieldVarying.def("Definitions", (opencascade::handle<StepElement_HArray1OfSurfaceSection> (StepElement_SurfaceSectionFieldVarying::*)() const ) &StepElement_SurfaceSectionFieldVarying::Definitions, "Returns field Definitions");
	cls_StepElement_SurfaceSectionFieldVarying.def("SetDefinitions", (void (StepElement_SurfaceSectionFieldVarying::*)(const opencascade::handle<StepElement_HArray1OfSurfaceSection> &)) &StepElement_SurfaceSectionFieldVarying::SetDefinitions, "Set field Definitions", py::arg("Definitions"));
	cls_StepElement_SurfaceSectionFieldVarying.def("AdditionalNodeValues", (Standard_Boolean (StepElement_SurfaceSectionFieldVarying::*)() const ) &StepElement_SurfaceSectionFieldVarying::AdditionalNodeValues, "Returns field AdditionalNodeValues");
	cls_StepElement_SurfaceSectionFieldVarying.def("SetAdditionalNodeValues", (void (StepElement_SurfaceSectionFieldVarying::*)(const Standard_Boolean)) &StepElement_SurfaceSectionFieldVarying::SetAdditionalNodeValues, "Set field AdditionalNodeValues", py::arg("AdditionalNodeValues"));
	cls_StepElement_SurfaceSectionFieldVarying.def_static("get_type_name_", (const char * (*)()) &StepElement_SurfaceSectionFieldVarying::get_type_name, "None");
	cls_StepElement_SurfaceSectionFieldVarying.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_SurfaceSectionFieldVarying::get_type_descriptor, "None");
	cls_StepElement_SurfaceSectionFieldVarying.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_SurfaceSectionFieldVarying::*)() const ) &StepElement_SurfaceSectionFieldVarying::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_UniformSurfaceSection.hxx
	py::class_<StepElement_UniformSurfaceSection, opencascade::handle<StepElement_UniformSurfaceSection>, StepElement_SurfaceSection> cls_StepElement_UniformSurfaceSection(mod, "StepElement_UniformSurfaceSection", "Representation of STEP entity UniformSurfaceSection");
	cls_StepElement_UniformSurfaceSection.def(py::init<>());
	cls_StepElement_UniformSurfaceSection.def("Init", (void (StepElement_UniformSurfaceSection::*)(const StepElement_MeasureOrUnspecifiedValue &, const StepElement_MeasureOrUnspecifiedValue &, const StepElement_MeasureOrUnspecifiedValue &, const Standard_Real, const StepElement_MeasureOrUnspecifiedValue &, const StepElement_MeasureOrUnspecifiedValue &)) &StepElement_UniformSurfaceSection::Init, "Initialize all fields (own and inherited)", py::arg("aSurfaceSection_Offset"), py::arg("aSurfaceSection_NonStructuralMass"), py::arg("aSurfaceSection_NonStructuralMassOffset"), py::arg("aThickness"), py::arg("aBendingThickness"), py::arg("aShearThickness"));
	cls_StepElement_UniformSurfaceSection.def("Thickness", (Standard_Real (StepElement_UniformSurfaceSection::*)() const ) &StepElement_UniformSurfaceSection::Thickness, "Returns field Thickness");
	cls_StepElement_UniformSurfaceSection.def("SetThickness", (void (StepElement_UniformSurfaceSection::*)(const Standard_Real)) &StepElement_UniformSurfaceSection::SetThickness, "Set field Thickness", py::arg("Thickness"));
	cls_StepElement_UniformSurfaceSection.def("BendingThickness", (StepElement_MeasureOrUnspecifiedValue (StepElement_UniformSurfaceSection::*)() const ) &StepElement_UniformSurfaceSection::BendingThickness, "Returns field BendingThickness");
	cls_StepElement_UniformSurfaceSection.def("SetBendingThickness", (void (StepElement_UniformSurfaceSection::*)(const StepElement_MeasureOrUnspecifiedValue &)) &StepElement_UniformSurfaceSection::SetBendingThickness, "Set field BendingThickness", py::arg("BendingThickness"));
	cls_StepElement_UniformSurfaceSection.def("ShearThickness", (StepElement_MeasureOrUnspecifiedValue (StepElement_UniformSurfaceSection::*)() const ) &StepElement_UniformSurfaceSection::ShearThickness, "Returns field ShearThickness");
	cls_StepElement_UniformSurfaceSection.def("SetShearThickness", (void (StepElement_UniformSurfaceSection::*)(const StepElement_MeasureOrUnspecifiedValue &)) &StepElement_UniformSurfaceSection::SetShearThickness, "Set field ShearThickness", py::arg("ShearThickness"));
	cls_StepElement_UniformSurfaceSection.def_static("get_type_name_", (const char * (*)()) &StepElement_UniformSurfaceSection::get_type_name, "None");
	cls_StepElement_UniformSurfaceSection.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_UniformSurfaceSection::get_type_descriptor, "None");
	cls_StepElement_UniformSurfaceSection.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_UniformSurfaceSection::*)() const ) &StepElement_UniformSurfaceSection::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_Volume3dElementDescriptor.hxx
	py::class_<StepElement_Volume3dElementDescriptor, opencascade::handle<StepElement_Volume3dElementDescriptor>, StepElement_ElementDescriptor> cls_StepElement_Volume3dElementDescriptor(mod, "StepElement_Volume3dElementDescriptor", "Representation of STEP entity Volume3dElementDescriptor");
	cls_StepElement_Volume3dElementDescriptor.def(py::init<>());
	cls_StepElement_Volume3dElementDescriptor.def("Init", (void (StepElement_Volume3dElementDescriptor::*)(const StepElement_ElementOrder, const opencascade::handle<TCollection_HAsciiString> &, const opencascade::handle<StepElement_HArray1OfVolumeElementPurposeMember> &, const StepElement_Volume3dElementShape)) &StepElement_Volume3dElementDescriptor::Init, "Initialize all fields (own and inherited)", py::arg("aElementDescriptor_TopologyOrder"), py::arg("aElementDescriptor_Description"), py::arg("aPurpose"), py::arg("aShape"));
	cls_StepElement_Volume3dElementDescriptor.def("Purpose", (opencascade::handle<StepElement_HArray1OfVolumeElementPurposeMember> (StepElement_Volume3dElementDescriptor::*)() const ) &StepElement_Volume3dElementDescriptor::Purpose, "Returns field Purpose");
	cls_StepElement_Volume3dElementDescriptor.def("SetPurpose", (void (StepElement_Volume3dElementDescriptor::*)(const opencascade::handle<StepElement_HArray1OfVolumeElementPurposeMember> &)) &StepElement_Volume3dElementDescriptor::SetPurpose, "Set field Purpose", py::arg("Purpose"));
	cls_StepElement_Volume3dElementDescriptor.def("Shape", (StepElement_Volume3dElementShape (StepElement_Volume3dElementDescriptor::*)() const ) &StepElement_Volume3dElementDescriptor::Shape, "Returns field Shape");
	cls_StepElement_Volume3dElementDescriptor.def("SetShape", (void (StepElement_Volume3dElementDescriptor::*)(const StepElement_Volume3dElementShape)) &StepElement_Volume3dElementDescriptor::SetShape, "Set field Shape", py::arg("Shape"));
	cls_StepElement_Volume3dElementDescriptor.def_static("get_type_name_", (const char * (*)()) &StepElement_Volume3dElementDescriptor::get_type_name, "None");
	cls_StepElement_Volume3dElementDescriptor.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_Volume3dElementDescriptor::get_type_descriptor, "None");
	cls_StepElement_Volume3dElementDescriptor.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_Volume3dElementDescriptor::*)() const ) &StepElement_Volume3dElementDescriptor::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_Sequence.hxx
	py::class_<StepElement_SequenceOfElementMaterial, std::unique_ptr<StepElement_SequenceOfElementMaterial, Deleter<StepElement_SequenceOfElementMaterial>>, NCollection_BaseSequence> cls_StepElement_SequenceOfElementMaterial(mod, "StepElement_SequenceOfElementMaterial", "Purpose: Definition of a sequence of elements indexed by an Integer in range of 1..n");
	cls_StepElement_SequenceOfElementMaterial.def(py::init<>());
	cls_StepElement_SequenceOfElementMaterial.def(py::init<const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("theAllocator"));
	cls_StepElement_SequenceOfElementMaterial.def(py::init([] (const StepElement_SequenceOfElementMaterial &other) {return new StepElement_SequenceOfElementMaterial(other);}), "Copy constructor", py::arg("other"));
	cls_StepElement_SequenceOfElementMaterial.def("begin", (StepElement_SequenceOfElementMaterial::iterator (StepElement_SequenceOfElementMaterial::*)() const ) &StepElement_SequenceOfElementMaterial::begin, "Returns an iterator pointing to the first element in the sequence.");
	cls_StepElement_SequenceOfElementMaterial.def("end", (StepElement_SequenceOfElementMaterial::iterator (StepElement_SequenceOfElementMaterial::*)() const ) &StepElement_SequenceOfElementMaterial::end, "Returns an iterator referring to the past-the-end element in the sequence.");
	cls_StepElement_SequenceOfElementMaterial.def("cbegin", (StepElement_SequenceOfElementMaterial::const_iterator (StepElement_SequenceOfElementMaterial::*)() const ) &StepElement_SequenceOfElementMaterial::cbegin, "Returns a const iterator pointing to the first element in the sequence.");
	cls_StepElement_SequenceOfElementMaterial.def("cend", (StepElement_SequenceOfElementMaterial::const_iterator (StepElement_SequenceOfElementMaterial::*)() const ) &StepElement_SequenceOfElementMaterial::cend, "Returns a const iterator referring to the past-the-end element in the sequence.");
	cls_StepElement_SequenceOfElementMaterial.def("Size", (Standard_Integer (StepElement_SequenceOfElementMaterial::*)() const ) &StepElement_SequenceOfElementMaterial::Size, "Number of items");
	cls_StepElement_SequenceOfElementMaterial.def("Length", (Standard_Integer (StepElement_SequenceOfElementMaterial::*)() const ) &StepElement_SequenceOfElementMaterial::Length, "Number of items");
	cls_StepElement_SequenceOfElementMaterial.def("Lower", (Standard_Integer (StepElement_SequenceOfElementMaterial::*)() const ) &StepElement_SequenceOfElementMaterial::Lower, "Method for consistency with other collections.");
	cls_StepElement_SequenceOfElementMaterial.def("Upper", (Standard_Integer (StepElement_SequenceOfElementMaterial::*)() const ) &StepElement_SequenceOfElementMaterial::Upper, "Method for consistency with other collections.");
	cls_StepElement_SequenceOfElementMaterial.def("IsEmpty", (Standard_Boolean (StepElement_SequenceOfElementMaterial::*)() const ) &StepElement_SequenceOfElementMaterial::IsEmpty, "Empty query");
	cls_StepElement_SequenceOfElementMaterial.def("Reverse", (void (StepElement_SequenceOfElementMaterial::*)()) &StepElement_SequenceOfElementMaterial::Reverse, "Reverse sequence");
	cls_StepElement_SequenceOfElementMaterial.def("Exchange", (void (StepElement_SequenceOfElementMaterial::*)(const Standard_Integer, const Standard_Integer)) &StepElement_SequenceOfElementMaterial::Exchange, "Exchange two members", py::arg("I"), py::arg("J"));
	cls_StepElement_SequenceOfElementMaterial.def_static("delNode_", (void (*)(NCollection_SeqNode *, opencascade::handle<NCollection_BaseAllocator> &)) &StepElement_SequenceOfElementMaterial::delNode, "Static deleter to be passed to BaseSequence", py::arg("theNode"), py::arg("theAl"));
	cls_StepElement_SequenceOfElementMaterial.def("Clear", [](StepElement_SequenceOfElementMaterial &self) -> void { return self.Clear(); });
	cls_StepElement_SequenceOfElementMaterial.def("Clear", (void (StepElement_SequenceOfElementMaterial::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &StepElement_SequenceOfElementMaterial::Clear, "Clear the items out, take a new allocator if non null", py::arg("theAllocator"));
	cls_StepElement_SequenceOfElementMaterial.def("Assign", (StepElement_SequenceOfElementMaterial & (StepElement_SequenceOfElementMaterial::*)(const StepElement_SequenceOfElementMaterial &)) &StepElement_SequenceOfElementMaterial::Assign, "Replace this sequence by the items of theOther. This method does not change the internal allocator.", py::arg("theOther"));
	cls_StepElement_SequenceOfElementMaterial.def("assign", (StepElement_SequenceOfElementMaterial & (StepElement_SequenceOfElementMaterial::*)(const StepElement_SequenceOfElementMaterial &)) &StepElement_SequenceOfElementMaterial::operator=, py::is_operator(), "Replacement operator", py::arg("theOther"));
	cls_StepElement_SequenceOfElementMaterial.def("Remove", (void (StepElement_SequenceOfElementMaterial::*)(StepElement_SequenceOfElementMaterial::Iterator &)) &StepElement_SequenceOfElementMaterial::Remove, "Remove one item", py::arg("thePosition"));
	cls_StepElement_SequenceOfElementMaterial.def("Remove", (void (StepElement_SequenceOfElementMaterial::*)(const Standard_Integer)) &StepElement_SequenceOfElementMaterial::Remove, "Remove one item", py::arg("theIndex"));
	cls_StepElement_SequenceOfElementMaterial.def("Remove", (void (StepElement_SequenceOfElementMaterial::*)(const Standard_Integer, const Standard_Integer)) &StepElement_SequenceOfElementMaterial::Remove, "Remove range of items", py::arg("theFromIndex"), py::arg("theToIndex"));
	cls_StepElement_SequenceOfElementMaterial.def("Append", (void (StepElement_SequenceOfElementMaterial::*)(const opencascade::handle<StepElement_ElementMaterial> &)) &StepElement_SequenceOfElementMaterial::Append, "Append one item", py::arg("theItem"));
	cls_StepElement_SequenceOfElementMaterial.def("Append", (void (StepElement_SequenceOfElementMaterial::*)(StepElement_SequenceOfElementMaterial &)) &StepElement_SequenceOfElementMaterial::Append, "Append another sequence (making it empty)", py::arg("theSeq"));
	cls_StepElement_SequenceOfElementMaterial.def("Prepend", (void (StepElement_SequenceOfElementMaterial::*)(const opencascade::handle<StepElement_ElementMaterial> &)) &StepElement_SequenceOfElementMaterial::Prepend, "Prepend one item", py::arg("theItem"));
	cls_StepElement_SequenceOfElementMaterial.def("Prepend", (void (StepElement_SequenceOfElementMaterial::*)(StepElement_SequenceOfElementMaterial &)) &StepElement_SequenceOfElementMaterial::Prepend, "Prepend another sequence (making it empty)", py::arg("theSeq"));
	cls_StepElement_SequenceOfElementMaterial.def("InsertBefore", (void (StepElement_SequenceOfElementMaterial::*)(const Standard_Integer, const opencascade::handle<StepElement_ElementMaterial> &)) &StepElement_SequenceOfElementMaterial::InsertBefore, "InsertBefore theIndex theItem", py::arg("theIndex"), py::arg("theItem"));
	cls_StepElement_SequenceOfElementMaterial.def("InsertBefore", (void (StepElement_SequenceOfElementMaterial::*)(const Standard_Integer, StepElement_SequenceOfElementMaterial &)) &StepElement_SequenceOfElementMaterial::InsertBefore, "InsertBefore theIndex another sequence", py::arg("theIndex"), py::arg("theSeq"));
	cls_StepElement_SequenceOfElementMaterial.def("InsertAfter", (void (StepElement_SequenceOfElementMaterial::*)(StepElement_SequenceOfElementMaterial::Iterator &, const opencascade::handle<StepElement_ElementMaterial> &)) &StepElement_SequenceOfElementMaterial::InsertAfter, "InsertAfter the position of iterator", py::arg("thePosition"), py::arg("theItem"));
	cls_StepElement_SequenceOfElementMaterial.def("InsertAfter", (void (StepElement_SequenceOfElementMaterial::*)(const Standard_Integer, StepElement_SequenceOfElementMaterial &)) &StepElement_SequenceOfElementMaterial::InsertAfter, "InsertAfter theIndex theItem", py::arg("theIndex"), py::arg("theSeq"));
	cls_StepElement_SequenceOfElementMaterial.def("InsertAfter", (void (StepElement_SequenceOfElementMaterial::*)(const Standard_Integer, const opencascade::handle<StepElement_ElementMaterial> &)) &StepElement_SequenceOfElementMaterial::InsertAfter, "InsertAfter theIndex another sequence", py::arg("theIndex"), py::arg("theItem"));
	cls_StepElement_SequenceOfElementMaterial.def("Split", (void (StepElement_SequenceOfElementMaterial::*)(const Standard_Integer, StepElement_SequenceOfElementMaterial &)) &StepElement_SequenceOfElementMaterial::Split, "Split in two sequences", py::arg("theIndex"), py::arg("theSeq"));
	cls_StepElement_SequenceOfElementMaterial.def("First", (const opencascade::handle<StepElement_ElementMaterial> & (StepElement_SequenceOfElementMaterial::*)() const ) &StepElement_SequenceOfElementMaterial::First, "First item access");
	cls_StepElement_SequenceOfElementMaterial.def("ChangeFirst", (opencascade::handle<StepElement_ElementMaterial> & (StepElement_SequenceOfElementMaterial::*)()) &StepElement_SequenceOfElementMaterial::ChangeFirst, "First item access");
	cls_StepElement_SequenceOfElementMaterial.def("Last", (const opencascade::handle<StepElement_ElementMaterial> & (StepElement_SequenceOfElementMaterial::*)() const ) &StepElement_SequenceOfElementMaterial::Last, "Last item access");
	cls_StepElement_SequenceOfElementMaterial.def("ChangeLast", (opencascade::handle<StepElement_ElementMaterial> & (StepElement_SequenceOfElementMaterial::*)()) &StepElement_SequenceOfElementMaterial::ChangeLast, "Last item access");
	cls_StepElement_SequenceOfElementMaterial.def("Value", (const opencascade::handle<StepElement_ElementMaterial> & (StepElement_SequenceOfElementMaterial::*)(const Standard_Integer) const ) &StepElement_SequenceOfElementMaterial::Value, "Constant item access by theIndex", py::arg("theIndex"));
	cls_StepElement_SequenceOfElementMaterial.def("__call__", (const opencascade::handle<StepElement_ElementMaterial> & (StepElement_SequenceOfElementMaterial::*)(const Standard_Integer) const ) &StepElement_SequenceOfElementMaterial::operator(), py::is_operator(), "Constant operator()", py::arg("theIndex"));
	cls_StepElement_SequenceOfElementMaterial.def("ChangeValue", (opencascade::handle<StepElement_ElementMaterial> & (StepElement_SequenceOfElementMaterial::*)(const Standard_Integer)) &StepElement_SequenceOfElementMaterial::ChangeValue, "Variable item access by theIndex", py::arg("theIndex"));
	cls_StepElement_SequenceOfElementMaterial.def("__call__", (opencascade::handle<StepElement_ElementMaterial> & (StepElement_SequenceOfElementMaterial::*)(const Standard_Integer)) &StepElement_SequenceOfElementMaterial::operator(), py::is_operator(), "Variable operator()", py::arg("theIndex"));
	cls_StepElement_SequenceOfElementMaterial.def("SetValue", (void (StepElement_SequenceOfElementMaterial::*)(const Standard_Integer, const opencascade::handle<StepElement_ElementMaterial> &)) &StepElement_SequenceOfElementMaterial::SetValue, "Set item value by theIndex", py::arg("theIndex"), py::arg("theItem"));
	cls_StepElement_SequenceOfElementMaterial.def("__iter__", [](const StepElement_SequenceOfElementMaterial &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_ElementAspect.hxx
	py::class_<StepElement_ElementAspect, std::unique_ptr<StepElement_ElementAspect, Deleter<StepElement_ElementAspect>>, StepData_SelectType> cls_StepElement_ElementAspect(mod, "StepElement_ElementAspect", "Representation of STEP SELECT type ElementAspect");
	cls_StepElement_ElementAspect.def(py::init<>());
	cls_StepElement_ElementAspect.def("CaseNum", (Standard_Integer (StepElement_ElementAspect::*)(const opencascade::handle<Standard_Transient> &) const ) &StepElement_ElementAspect::CaseNum, "Recognizes a kind of ElementAspect select type return 0", py::arg("ent"));
	cls_StepElement_ElementAspect.def("CaseMem", (Standard_Integer (StepElement_ElementAspect::*)(const opencascade::handle<StepData_SelectMember> &) const ) &StepElement_ElementAspect::CaseMem, "Recognizes a items of select member ElementAspectMember 1 -> ElementVolume 2 -> Volume3dFace 3 -> Volume2dFace 4 -> Volume3dEdge 5 -> Volume2dEdge 6 -> Surface3dFace 7 -> Surface2dFace 8 -> Surface3dEdge 9 -> Surface2dEdge 10 -> CurveEdge 0 else", py::arg("ent"));
	cls_StepElement_ElementAspect.def("NewMember", (opencascade::handle<StepData_SelectMember> (StepElement_ElementAspect::*)() const ) &StepElement_ElementAspect::NewMember, "Returns a new select member the type ElementAspectMember");
	cls_StepElement_ElementAspect.def("SetElementVolume", (void (StepElement_ElementAspect::*)(const StepElement_ElementVolume)) &StepElement_ElementAspect::SetElementVolume, "Set Value for ElementVolume", py::arg("aVal"));
	cls_StepElement_ElementAspect.def("ElementVolume", (StepElement_ElementVolume (StepElement_ElementAspect::*)() const ) &StepElement_ElementAspect::ElementVolume, "Returns Value as ElementVolume (or Null if another type)");
	cls_StepElement_ElementAspect.def("SetVolume3dFace", (void (StepElement_ElementAspect::*)(const Standard_Integer)) &StepElement_ElementAspect::SetVolume3dFace, "Set Value for Volume3dFace", py::arg("aVal"));
	cls_StepElement_ElementAspect.def("Volume3dFace", (Standard_Integer (StepElement_ElementAspect::*)() const ) &StepElement_ElementAspect::Volume3dFace, "Returns Value as Volume3dFace (or Null if another type)");
	cls_StepElement_ElementAspect.def("SetVolume2dFace", (void (StepElement_ElementAspect::*)(const Standard_Integer)) &StepElement_ElementAspect::SetVolume2dFace, "Set Value for Volume2dFace", py::arg("aVal"));
	cls_StepElement_ElementAspect.def("Volume2dFace", (Standard_Integer (StepElement_ElementAspect::*)() const ) &StepElement_ElementAspect::Volume2dFace, "Returns Value as Volume2dFace (or Null if another type)");
	cls_StepElement_ElementAspect.def("SetVolume3dEdge", (void (StepElement_ElementAspect::*)(const Standard_Integer)) &StepElement_ElementAspect::SetVolume3dEdge, "Set Value for Volume3dEdge", py::arg("aVal"));
	cls_StepElement_ElementAspect.def("Volume3dEdge", (Standard_Integer (StepElement_ElementAspect::*)() const ) &StepElement_ElementAspect::Volume3dEdge, "Returns Value as Volume3dEdge (or Null if another type)");
	cls_StepElement_ElementAspect.def("SetVolume2dEdge", (void (StepElement_ElementAspect::*)(const Standard_Integer)) &StepElement_ElementAspect::SetVolume2dEdge, "Set Value for Volume2dEdge", py::arg("aVal"));
	cls_StepElement_ElementAspect.def("Volume2dEdge", (Standard_Integer (StepElement_ElementAspect::*)() const ) &StepElement_ElementAspect::Volume2dEdge, "Returns Value as Volume2dEdge (or Null if another type)");
	cls_StepElement_ElementAspect.def("SetSurface3dFace", (void (StepElement_ElementAspect::*)(const Standard_Integer)) &StepElement_ElementAspect::SetSurface3dFace, "Set Value for Surface3dFace", py::arg("aVal"));
	cls_StepElement_ElementAspect.def("Surface3dFace", (Standard_Integer (StepElement_ElementAspect::*)() const ) &StepElement_ElementAspect::Surface3dFace, "Returns Value as Surface3dFace (or Null if another type)");
	cls_StepElement_ElementAspect.def("SetSurface2dFace", (void (StepElement_ElementAspect::*)(const Standard_Integer)) &StepElement_ElementAspect::SetSurface2dFace, "Set Value for Surface2dFace", py::arg("aVal"));
	cls_StepElement_ElementAspect.def("Surface2dFace", (Standard_Integer (StepElement_ElementAspect::*)() const ) &StepElement_ElementAspect::Surface2dFace, "Returns Value as Surface2dFace (or Null if another type)");
	cls_StepElement_ElementAspect.def("SetSurface3dEdge", (void (StepElement_ElementAspect::*)(const Standard_Integer)) &StepElement_ElementAspect::SetSurface3dEdge, "Set Value for Surface3dEdge", py::arg("aVal"));
	cls_StepElement_ElementAspect.def("Surface3dEdge", (Standard_Integer (StepElement_ElementAspect::*)() const ) &StepElement_ElementAspect::Surface3dEdge, "Returns Value as Surface3dEdge (or Null if another type)");
	cls_StepElement_ElementAspect.def("SetSurface2dEdge", (void (StepElement_ElementAspect::*)(const Standard_Integer)) &StepElement_ElementAspect::SetSurface2dEdge, "Set Value for Surface2dEdge", py::arg("aVal"));
	cls_StepElement_ElementAspect.def("Surface2dEdge", (Standard_Integer (StepElement_ElementAspect::*)() const ) &StepElement_ElementAspect::Surface2dEdge, "Returns Value as Surface2dEdge (or Null if another type)");
	cls_StepElement_ElementAspect.def("SetCurveEdge", (void (StepElement_ElementAspect::*)(const StepElement_CurveEdge)) &StepElement_ElementAspect::SetCurveEdge, "Set Value for CurveEdge", py::arg("aVal"));
	cls_StepElement_ElementAspect.def("CurveEdge", (StepElement_CurveEdge (StepElement_ElementAspect::*)() const ) &StepElement_ElementAspect::CurveEdge, "Returns Value as CurveEdge (or Null if another type)");

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_Sequence.hxx
	py::class_<StepElement_SequenceOfCurveElementSectionDefinition, std::unique_ptr<StepElement_SequenceOfCurveElementSectionDefinition, Deleter<StepElement_SequenceOfCurveElementSectionDefinition>>, NCollection_BaseSequence> cls_StepElement_SequenceOfCurveElementSectionDefinition(mod, "StepElement_SequenceOfCurveElementSectionDefinition", "Purpose: Definition of a sequence of elements indexed by an Integer in range of 1..n");
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def(py::init<>());
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def(py::init<const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("theAllocator"));
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def(py::init([] (const StepElement_SequenceOfCurveElementSectionDefinition &other) {return new StepElement_SequenceOfCurveElementSectionDefinition(other);}), "Copy constructor", py::arg("other"));
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("begin", (StepElement_SequenceOfCurveElementSectionDefinition::iterator (StepElement_SequenceOfCurveElementSectionDefinition::*)() const ) &StepElement_SequenceOfCurveElementSectionDefinition::begin, "Returns an iterator pointing to the first element in the sequence.");
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("end", (StepElement_SequenceOfCurveElementSectionDefinition::iterator (StepElement_SequenceOfCurveElementSectionDefinition::*)() const ) &StepElement_SequenceOfCurveElementSectionDefinition::end, "Returns an iterator referring to the past-the-end element in the sequence.");
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("cbegin", (StepElement_SequenceOfCurveElementSectionDefinition::const_iterator (StepElement_SequenceOfCurveElementSectionDefinition::*)() const ) &StepElement_SequenceOfCurveElementSectionDefinition::cbegin, "Returns a const iterator pointing to the first element in the sequence.");
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("cend", (StepElement_SequenceOfCurveElementSectionDefinition::const_iterator (StepElement_SequenceOfCurveElementSectionDefinition::*)() const ) &StepElement_SequenceOfCurveElementSectionDefinition::cend, "Returns a const iterator referring to the past-the-end element in the sequence.");
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("Size", (Standard_Integer (StepElement_SequenceOfCurveElementSectionDefinition::*)() const ) &StepElement_SequenceOfCurveElementSectionDefinition::Size, "Number of items");
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("Length", (Standard_Integer (StepElement_SequenceOfCurveElementSectionDefinition::*)() const ) &StepElement_SequenceOfCurveElementSectionDefinition::Length, "Number of items");
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("Lower", (Standard_Integer (StepElement_SequenceOfCurveElementSectionDefinition::*)() const ) &StepElement_SequenceOfCurveElementSectionDefinition::Lower, "Method for consistency with other collections.");
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("Upper", (Standard_Integer (StepElement_SequenceOfCurveElementSectionDefinition::*)() const ) &StepElement_SequenceOfCurveElementSectionDefinition::Upper, "Method for consistency with other collections.");
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("IsEmpty", (Standard_Boolean (StepElement_SequenceOfCurveElementSectionDefinition::*)() const ) &StepElement_SequenceOfCurveElementSectionDefinition::IsEmpty, "Empty query");
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("Reverse", (void (StepElement_SequenceOfCurveElementSectionDefinition::*)()) &StepElement_SequenceOfCurveElementSectionDefinition::Reverse, "Reverse sequence");
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("Exchange", (void (StepElement_SequenceOfCurveElementSectionDefinition::*)(const Standard_Integer, const Standard_Integer)) &StepElement_SequenceOfCurveElementSectionDefinition::Exchange, "Exchange two members", py::arg("I"), py::arg("J"));
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def_static("delNode_", (void (*)(NCollection_SeqNode *, opencascade::handle<NCollection_BaseAllocator> &)) &StepElement_SequenceOfCurveElementSectionDefinition::delNode, "Static deleter to be passed to BaseSequence", py::arg("theNode"), py::arg("theAl"));
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("Clear", [](StepElement_SequenceOfCurveElementSectionDefinition &self) -> void { return self.Clear(); });
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("Clear", (void (StepElement_SequenceOfCurveElementSectionDefinition::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &StepElement_SequenceOfCurveElementSectionDefinition::Clear, "Clear the items out, take a new allocator if non null", py::arg("theAllocator"));
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("Assign", (StepElement_SequenceOfCurveElementSectionDefinition & (StepElement_SequenceOfCurveElementSectionDefinition::*)(const StepElement_SequenceOfCurveElementSectionDefinition &)) &StepElement_SequenceOfCurveElementSectionDefinition::Assign, "Replace this sequence by the items of theOther. This method does not change the internal allocator.", py::arg("theOther"));
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("assign", (StepElement_SequenceOfCurveElementSectionDefinition & (StepElement_SequenceOfCurveElementSectionDefinition::*)(const StepElement_SequenceOfCurveElementSectionDefinition &)) &StepElement_SequenceOfCurveElementSectionDefinition::operator=, py::is_operator(), "Replacement operator", py::arg("theOther"));
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("Remove", (void (StepElement_SequenceOfCurveElementSectionDefinition::*)(StepElement_SequenceOfCurveElementSectionDefinition::Iterator &)) &StepElement_SequenceOfCurveElementSectionDefinition::Remove, "Remove one item", py::arg("thePosition"));
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("Remove", (void (StepElement_SequenceOfCurveElementSectionDefinition::*)(const Standard_Integer)) &StepElement_SequenceOfCurveElementSectionDefinition::Remove, "Remove one item", py::arg("theIndex"));
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("Remove", (void (StepElement_SequenceOfCurveElementSectionDefinition::*)(const Standard_Integer, const Standard_Integer)) &StepElement_SequenceOfCurveElementSectionDefinition::Remove, "Remove range of items", py::arg("theFromIndex"), py::arg("theToIndex"));
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("Append", (void (StepElement_SequenceOfCurveElementSectionDefinition::*)(const opencascade::handle<StepElement_CurveElementSectionDefinition> &)) &StepElement_SequenceOfCurveElementSectionDefinition::Append, "Append one item", py::arg("theItem"));
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("Append", (void (StepElement_SequenceOfCurveElementSectionDefinition::*)(StepElement_SequenceOfCurveElementSectionDefinition &)) &StepElement_SequenceOfCurveElementSectionDefinition::Append, "Append another sequence (making it empty)", py::arg("theSeq"));
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("Prepend", (void (StepElement_SequenceOfCurveElementSectionDefinition::*)(const opencascade::handle<StepElement_CurveElementSectionDefinition> &)) &StepElement_SequenceOfCurveElementSectionDefinition::Prepend, "Prepend one item", py::arg("theItem"));
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("Prepend", (void (StepElement_SequenceOfCurveElementSectionDefinition::*)(StepElement_SequenceOfCurveElementSectionDefinition &)) &StepElement_SequenceOfCurveElementSectionDefinition::Prepend, "Prepend another sequence (making it empty)", py::arg("theSeq"));
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("InsertBefore", (void (StepElement_SequenceOfCurveElementSectionDefinition::*)(const Standard_Integer, const opencascade::handle<StepElement_CurveElementSectionDefinition> &)) &StepElement_SequenceOfCurveElementSectionDefinition::InsertBefore, "InsertBefore theIndex theItem", py::arg("theIndex"), py::arg("theItem"));
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("InsertBefore", (void (StepElement_SequenceOfCurveElementSectionDefinition::*)(const Standard_Integer, StepElement_SequenceOfCurveElementSectionDefinition &)) &StepElement_SequenceOfCurveElementSectionDefinition::InsertBefore, "InsertBefore theIndex another sequence", py::arg("theIndex"), py::arg("theSeq"));
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("InsertAfter", (void (StepElement_SequenceOfCurveElementSectionDefinition::*)(StepElement_SequenceOfCurveElementSectionDefinition::Iterator &, const opencascade::handle<StepElement_CurveElementSectionDefinition> &)) &StepElement_SequenceOfCurveElementSectionDefinition::InsertAfter, "InsertAfter the position of iterator", py::arg("thePosition"), py::arg("theItem"));
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("InsertAfter", (void (StepElement_SequenceOfCurveElementSectionDefinition::*)(const Standard_Integer, StepElement_SequenceOfCurveElementSectionDefinition &)) &StepElement_SequenceOfCurveElementSectionDefinition::InsertAfter, "InsertAfter theIndex theItem", py::arg("theIndex"), py::arg("theSeq"));
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("InsertAfter", (void (StepElement_SequenceOfCurveElementSectionDefinition::*)(const Standard_Integer, const opencascade::handle<StepElement_CurveElementSectionDefinition> &)) &StepElement_SequenceOfCurveElementSectionDefinition::InsertAfter, "InsertAfter theIndex another sequence", py::arg("theIndex"), py::arg("theItem"));
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("Split", (void (StepElement_SequenceOfCurveElementSectionDefinition::*)(const Standard_Integer, StepElement_SequenceOfCurveElementSectionDefinition &)) &StepElement_SequenceOfCurveElementSectionDefinition::Split, "Split in two sequences", py::arg("theIndex"), py::arg("theSeq"));
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("First", (const opencascade::handle<StepElement_CurveElementSectionDefinition> & (StepElement_SequenceOfCurveElementSectionDefinition::*)() const ) &StepElement_SequenceOfCurveElementSectionDefinition::First, "First item access");
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("ChangeFirst", (opencascade::handle<StepElement_CurveElementSectionDefinition> & (StepElement_SequenceOfCurveElementSectionDefinition::*)()) &StepElement_SequenceOfCurveElementSectionDefinition::ChangeFirst, "First item access");
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("Last", (const opencascade::handle<StepElement_CurveElementSectionDefinition> & (StepElement_SequenceOfCurveElementSectionDefinition::*)() const ) &StepElement_SequenceOfCurveElementSectionDefinition::Last, "Last item access");
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("ChangeLast", (opencascade::handle<StepElement_CurveElementSectionDefinition> & (StepElement_SequenceOfCurveElementSectionDefinition::*)()) &StepElement_SequenceOfCurveElementSectionDefinition::ChangeLast, "Last item access");
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("Value", (const opencascade::handle<StepElement_CurveElementSectionDefinition> & (StepElement_SequenceOfCurveElementSectionDefinition::*)(const Standard_Integer) const ) &StepElement_SequenceOfCurveElementSectionDefinition::Value, "Constant item access by theIndex", py::arg("theIndex"));
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("__call__", (const opencascade::handle<StepElement_CurveElementSectionDefinition> & (StepElement_SequenceOfCurveElementSectionDefinition::*)(const Standard_Integer) const ) &StepElement_SequenceOfCurveElementSectionDefinition::operator(), py::is_operator(), "Constant operator()", py::arg("theIndex"));
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("ChangeValue", (opencascade::handle<StepElement_CurveElementSectionDefinition> & (StepElement_SequenceOfCurveElementSectionDefinition::*)(const Standard_Integer)) &StepElement_SequenceOfCurveElementSectionDefinition::ChangeValue, "Variable item access by theIndex", py::arg("theIndex"));
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("__call__", (opencascade::handle<StepElement_CurveElementSectionDefinition> & (StepElement_SequenceOfCurveElementSectionDefinition::*)(const Standard_Integer)) &StepElement_SequenceOfCurveElementSectionDefinition::operator(), py::is_operator(), "Variable operator()", py::arg("theIndex"));
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("SetValue", (void (StepElement_SequenceOfCurveElementSectionDefinition::*)(const Standard_Integer, const opencascade::handle<StepElement_CurveElementSectionDefinition> &)) &StepElement_SequenceOfCurveElementSectionDefinition::SetValue, "Set item value by theIndex", py::arg("theIndex"), py::arg("theItem"));
	cls_StepElement_SequenceOfCurveElementSectionDefinition.def("__iter__", [](const StepElement_SequenceOfCurveElementSectionDefinition &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_CurveElementFreedom.hxx
	py::class_<StepElement_CurveElementFreedom, std::unique_ptr<StepElement_CurveElementFreedom, Deleter<StepElement_CurveElementFreedom>>, StepData_SelectType> cls_StepElement_CurveElementFreedom(mod, "StepElement_CurveElementFreedom", "Representation of STEP SELECT type CurveElementFreedom");
	cls_StepElement_CurveElementFreedom.def(py::init<>());
	cls_StepElement_CurveElementFreedom.def("CaseNum", (Standard_Integer (StepElement_CurveElementFreedom::*)(const opencascade::handle<Standard_Transient> &) const ) &StepElement_CurveElementFreedom::CaseNum, "Recognizes a kind of CurveElementFreedom select type return 0", py::arg("ent"));
	cls_StepElement_CurveElementFreedom.def("CaseMem", (Standard_Integer (StepElement_CurveElementFreedom::*)(const opencascade::handle<StepData_SelectMember> &) const ) &StepElement_CurveElementFreedom::CaseMem, "Recognizes a items of select member CurveElementFreedomMember 1 -> EnumeratedCurveElementFreedom 2 -> ApplicationDefinedDegreeOfFreedom 0 else", py::arg("ent"));
	cls_StepElement_CurveElementFreedom.def("NewMember", (opencascade::handle<StepData_SelectMember> (StepElement_CurveElementFreedom::*)() const ) &StepElement_CurveElementFreedom::NewMember, "Returns a new select member the type CurveElementFreedomMember");
	cls_StepElement_CurveElementFreedom.def("SetEnumeratedCurveElementFreedom", (void (StepElement_CurveElementFreedom::*)(const StepElement_EnumeratedCurveElementFreedom)) &StepElement_CurveElementFreedom::SetEnumeratedCurveElementFreedom, "Set Value for EnumeratedCurveElementFreedom", py::arg("aVal"));
	cls_StepElement_CurveElementFreedom.def("EnumeratedCurveElementFreedom", (StepElement_EnumeratedCurveElementFreedom (StepElement_CurveElementFreedom::*)() const ) &StepElement_CurveElementFreedom::EnumeratedCurveElementFreedom, "Returns Value as EnumeratedCurveElementFreedom (or Null if another type)");
	cls_StepElement_CurveElementFreedom.def("SetApplicationDefinedDegreeOfFreedom", (void (StepElement_CurveElementFreedom::*)(const opencascade::handle<TCollection_HAsciiString> &)) &StepElement_CurveElementFreedom::SetApplicationDefinedDegreeOfFreedom, "Set Value for ApplicationDefinedDegreeOfFreedom", py::arg("aVal"));
	cls_StepElement_CurveElementFreedom.def("ApplicationDefinedDegreeOfFreedom", (opencascade::handle<TCollection_HAsciiString> (StepElement_CurveElementFreedom::*)() const ) &StepElement_CurveElementFreedom::ApplicationDefinedDegreeOfFreedom, "Returns Value as ApplicationDefinedDegreeOfFreedom (or Null if another type)");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_CurveElementPurposeMember.hxx
	py::class_<StepElement_CurveElementPurposeMember, opencascade::handle<StepElement_CurveElementPurposeMember>, StepData_SelectNamed> cls_StepElement_CurveElementPurposeMember(mod, "StepElement_CurveElementPurposeMember", "Representation of member for STEP SELECT type CurveElementPurpose");
	cls_StepElement_CurveElementPurposeMember.def(py::init<>());
	cls_StepElement_CurveElementPurposeMember.def("HasName", (Standard_Boolean (StepElement_CurveElementPurposeMember::*)() const ) &StepElement_CurveElementPurposeMember::HasName, "Returns True if has name");
	cls_StepElement_CurveElementPurposeMember.def("Name", (Standard_CString (StepElement_CurveElementPurposeMember::*)() const ) &StepElement_CurveElementPurposeMember::Name, "Returns set name");
	cls_StepElement_CurveElementPurposeMember.def("SetName", (Standard_Boolean (StepElement_CurveElementPurposeMember::*)(const Standard_CString)) &StepElement_CurveElementPurposeMember::SetName, "Set name", py::arg("name"));
	cls_StepElement_CurveElementPurposeMember.def("Matches", (Standard_Boolean (StepElement_CurveElementPurposeMember::*)(const Standard_CString) const ) &StepElement_CurveElementPurposeMember::Matches, "Tells if the name of a SelectMember matches a given one;", py::arg("name"));
	cls_StepElement_CurveElementPurposeMember.def_static("get_type_name_", (const char * (*)()) &StepElement_CurveElementPurposeMember::get_type_name, "None");
	cls_StepElement_CurveElementPurposeMember.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_CurveElementPurposeMember::get_type_descriptor, "None");
	cls_StepElement_CurveElementPurposeMember.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_CurveElementPurposeMember::*)() const ) &StepElement_CurveElementPurposeMember::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_Sequence.hxx
	py::class_<StepElement_SequenceOfCurveElementPurposeMember, std::unique_ptr<StepElement_SequenceOfCurveElementPurposeMember, Deleter<StepElement_SequenceOfCurveElementPurposeMember>>, NCollection_BaseSequence> cls_StepElement_SequenceOfCurveElementPurposeMember(mod, "StepElement_SequenceOfCurveElementPurposeMember", "Purpose: Definition of a sequence of elements indexed by an Integer in range of 1..n");
	cls_StepElement_SequenceOfCurveElementPurposeMember.def(py::init<>());
	cls_StepElement_SequenceOfCurveElementPurposeMember.def(py::init<const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("theAllocator"));
	cls_StepElement_SequenceOfCurveElementPurposeMember.def(py::init([] (const StepElement_SequenceOfCurveElementPurposeMember &other) {return new StepElement_SequenceOfCurveElementPurposeMember(other);}), "Copy constructor", py::arg("other"));
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("begin", (StepElement_SequenceOfCurveElementPurposeMember::iterator (StepElement_SequenceOfCurveElementPurposeMember::*)() const ) &StepElement_SequenceOfCurveElementPurposeMember::begin, "Returns an iterator pointing to the first element in the sequence.");
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("end", (StepElement_SequenceOfCurveElementPurposeMember::iterator (StepElement_SequenceOfCurveElementPurposeMember::*)() const ) &StepElement_SequenceOfCurveElementPurposeMember::end, "Returns an iterator referring to the past-the-end element in the sequence.");
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("cbegin", (StepElement_SequenceOfCurveElementPurposeMember::const_iterator (StepElement_SequenceOfCurveElementPurposeMember::*)() const ) &StepElement_SequenceOfCurveElementPurposeMember::cbegin, "Returns a const iterator pointing to the first element in the sequence.");
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("cend", (StepElement_SequenceOfCurveElementPurposeMember::const_iterator (StepElement_SequenceOfCurveElementPurposeMember::*)() const ) &StepElement_SequenceOfCurveElementPurposeMember::cend, "Returns a const iterator referring to the past-the-end element in the sequence.");
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("Size", (Standard_Integer (StepElement_SequenceOfCurveElementPurposeMember::*)() const ) &StepElement_SequenceOfCurveElementPurposeMember::Size, "Number of items");
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("Length", (Standard_Integer (StepElement_SequenceOfCurveElementPurposeMember::*)() const ) &StepElement_SequenceOfCurveElementPurposeMember::Length, "Number of items");
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("Lower", (Standard_Integer (StepElement_SequenceOfCurveElementPurposeMember::*)() const ) &StepElement_SequenceOfCurveElementPurposeMember::Lower, "Method for consistency with other collections.");
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("Upper", (Standard_Integer (StepElement_SequenceOfCurveElementPurposeMember::*)() const ) &StepElement_SequenceOfCurveElementPurposeMember::Upper, "Method for consistency with other collections.");
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("IsEmpty", (Standard_Boolean (StepElement_SequenceOfCurveElementPurposeMember::*)() const ) &StepElement_SequenceOfCurveElementPurposeMember::IsEmpty, "Empty query");
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("Reverse", (void (StepElement_SequenceOfCurveElementPurposeMember::*)()) &StepElement_SequenceOfCurveElementPurposeMember::Reverse, "Reverse sequence");
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("Exchange", (void (StepElement_SequenceOfCurveElementPurposeMember::*)(const Standard_Integer, const Standard_Integer)) &StepElement_SequenceOfCurveElementPurposeMember::Exchange, "Exchange two members", py::arg("I"), py::arg("J"));
	cls_StepElement_SequenceOfCurveElementPurposeMember.def_static("delNode_", (void (*)(NCollection_SeqNode *, opencascade::handle<NCollection_BaseAllocator> &)) &StepElement_SequenceOfCurveElementPurposeMember::delNode, "Static deleter to be passed to BaseSequence", py::arg("theNode"), py::arg("theAl"));
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("Clear", [](StepElement_SequenceOfCurveElementPurposeMember &self) -> void { return self.Clear(); });
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("Clear", (void (StepElement_SequenceOfCurveElementPurposeMember::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &StepElement_SequenceOfCurveElementPurposeMember::Clear, "Clear the items out, take a new allocator if non null", py::arg("theAllocator"));
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("Assign", (StepElement_SequenceOfCurveElementPurposeMember & (StepElement_SequenceOfCurveElementPurposeMember::*)(const StepElement_SequenceOfCurveElementPurposeMember &)) &StepElement_SequenceOfCurveElementPurposeMember::Assign, "Replace this sequence by the items of theOther. This method does not change the internal allocator.", py::arg("theOther"));
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("assign", (StepElement_SequenceOfCurveElementPurposeMember & (StepElement_SequenceOfCurveElementPurposeMember::*)(const StepElement_SequenceOfCurveElementPurposeMember &)) &StepElement_SequenceOfCurveElementPurposeMember::operator=, py::is_operator(), "Replacement operator", py::arg("theOther"));
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("Remove", (void (StepElement_SequenceOfCurveElementPurposeMember::*)(StepElement_SequenceOfCurveElementPurposeMember::Iterator &)) &StepElement_SequenceOfCurveElementPurposeMember::Remove, "Remove one item", py::arg("thePosition"));
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("Remove", (void (StepElement_SequenceOfCurveElementPurposeMember::*)(const Standard_Integer)) &StepElement_SequenceOfCurveElementPurposeMember::Remove, "Remove one item", py::arg("theIndex"));
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("Remove", (void (StepElement_SequenceOfCurveElementPurposeMember::*)(const Standard_Integer, const Standard_Integer)) &StepElement_SequenceOfCurveElementPurposeMember::Remove, "Remove range of items", py::arg("theFromIndex"), py::arg("theToIndex"));
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("Append", (void (StepElement_SequenceOfCurveElementPurposeMember::*)(const opencascade::handle<StepElement_CurveElementPurposeMember> &)) &StepElement_SequenceOfCurveElementPurposeMember::Append, "Append one item", py::arg("theItem"));
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("Append", (void (StepElement_SequenceOfCurveElementPurposeMember::*)(StepElement_SequenceOfCurveElementPurposeMember &)) &StepElement_SequenceOfCurveElementPurposeMember::Append, "Append another sequence (making it empty)", py::arg("theSeq"));
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("Prepend", (void (StepElement_SequenceOfCurveElementPurposeMember::*)(const opencascade::handle<StepElement_CurveElementPurposeMember> &)) &StepElement_SequenceOfCurveElementPurposeMember::Prepend, "Prepend one item", py::arg("theItem"));
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("Prepend", (void (StepElement_SequenceOfCurveElementPurposeMember::*)(StepElement_SequenceOfCurveElementPurposeMember &)) &StepElement_SequenceOfCurveElementPurposeMember::Prepend, "Prepend another sequence (making it empty)", py::arg("theSeq"));
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("InsertBefore", (void (StepElement_SequenceOfCurveElementPurposeMember::*)(const Standard_Integer, const opencascade::handle<StepElement_CurveElementPurposeMember> &)) &StepElement_SequenceOfCurveElementPurposeMember::InsertBefore, "InsertBefore theIndex theItem", py::arg("theIndex"), py::arg("theItem"));
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("InsertBefore", (void (StepElement_SequenceOfCurveElementPurposeMember::*)(const Standard_Integer, StepElement_SequenceOfCurveElementPurposeMember &)) &StepElement_SequenceOfCurveElementPurposeMember::InsertBefore, "InsertBefore theIndex another sequence", py::arg("theIndex"), py::arg("theSeq"));
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("InsertAfter", (void (StepElement_SequenceOfCurveElementPurposeMember::*)(StepElement_SequenceOfCurveElementPurposeMember::Iterator &, const opencascade::handle<StepElement_CurveElementPurposeMember> &)) &StepElement_SequenceOfCurveElementPurposeMember::InsertAfter, "InsertAfter the position of iterator", py::arg("thePosition"), py::arg("theItem"));
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("InsertAfter", (void (StepElement_SequenceOfCurveElementPurposeMember::*)(const Standard_Integer, StepElement_SequenceOfCurveElementPurposeMember &)) &StepElement_SequenceOfCurveElementPurposeMember::InsertAfter, "InsertAfter theIndex theItem", py::arg("theIndex"), py::arg("theSeq"));
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("InsertAfter", (void (StepElement_SequenceOfCurveElementPurposeMember::*)(const Standard_Integer, const opencascade::handle<StepElement_CurveElementPurposeMember> &)) &StepElement_SequenceOfCurveElementPurposeMember::InsertAfter, "InsertAfter theIndex another sequence", py::arg("theIndex"), py::arg("theItem"));
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("Split", (void (StepElement_SequenceOfCurveElementPurposeMember::*)(const Standard_Integer, StepElement_SequenceOfCurveElementPurposeMember &)) &StepElement_SequenceOfCurveElementPurposeMember::Split, "Split in two sequences", py::arg("theIndex"), py::arg("theSeq"));
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("First", (const opencascade::handle<StepElement_CurveElementPurposeMember> & (StepElement_SequenceOfCurveElementPurposeMember::*)() const ) &StepElement_SequenceOfCurveElementPurposeMember::First, "First item access");
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("ChangeFirst", (opencascade::handle<StepElement_CurveElementPurposeMember> & (StepElement_SequenceOfCurveElementPurposeMember::*)()) &StepElement_SequenceOfCurveElementPurposeMember::ChangeFirst, "First item access");
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("Last", (const opencascade::handle<StepElement_CurveElementPurposeMember> & (StepElement_SequenceOfCurveElementPurposeMember::*)() const ) &StepElement_SequenceOfCurveElementPurposeMember::Last, "Last item access");
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("ChangeLast", (opencascade::handle<StepElement_CurveElementPurposeMember> & (StepElement_SequenceOfCurveElementPurposeMember::*)()) &StepElement_SequenceOfCurveElementPurposeMember::ChangeLast, "Last item access");
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("Value", (const opencascade::handle<StepElement_CurveElementPurposeMember> & (StepElement_SequenceOfCurveElementPurposeMember::*)(const Standard_Integer) const ) &StepElement_SequenceOfCurveElementPurposeMember::Value, "Constant item access by theIndex", py::arg("theIndex"));
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("__call__", (const opencascade::handle<StepElement_CurveElementPurposeMember> & (StepElement_SequenceOfCurveElementPurposeMember::*)(const Standard_Integer) const ) &StepElement_SequenceOfCurveElementPurposeMember::operator(), py::is_operator(), "Constant operator()", py::arg("theIndex"));
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("ChangeValue", (opencascade::handle<StepElement_CurveElementPurposeMember> & (StepElement_SequenceOfCurveElementPurposeMember::*)(const Standard_Integer)) &StepElement_SequenceOfCurveElementPurposeMember::ChangeValue, "Variable item access by theIndex", py::arg("theIndex"));
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("__call__", (opencascade::handle<StepElement_CurveElementPurposeMember> & (StepElement_SequenceOfCurveElementPurposeMember::*)(const Standard_Integer)) &StepElement_SequenceOfCurveElementPurposeMember::operator(), py::is_operator(), "Variable operator()", py::arg("theIndex"));
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("SetValue", (void (StepElement_SequenceOfCurveElementPurposeMember::*)(const Standard_Integer, const opencascade::handle<StepElement_CurveElementPurposeMember> &)) &StepElement_SequenceOfCurveElementPurposeMember::SetValue, "Set item value by theIndex", py::arg("theIndex"), py::arg("theItem"));
	cls_StepElement_SequenceOfCurveElementPurposeMember.def("__iter__", [](const StepElement_SequenceOfCurveElementPurposeMember &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_SurfaceElementPurposeMember.hxx
	py::class_<StepElement_SurfaceElementPurposeMember, opencascade::handle<StepElement_SurfaceElementPurposeMember>, StepData_SelectNamed> cls_StepElement_SurfaceElementPurposeMember(mod, "StepElement_SurfaceElementPurposeMember", "Representation of member for STEP SELECT type SurfaceElementPurpose");
	cls_StepElement_SurfaceElementPurposeMember.def(py::init<>());
	cls_StepElement_SurfaceElementPurposeMember.def("HasName", (Standard_Boolean (StepElement_SurfaceElementPurposeMember::*)() const ) &StepElement_SurfaceElementPurposeMember::HasName, "Returns True if has name");
	cls_StepElement_SurfaceElementPurposeMember.def("Name", (Standard_CString (StepElement_SurfaceElementPurposeMember::*)() const ) &StepElement_SurfaceElementPurposeMember::Name, "Returns set name");
	cls_StepElement_SurfaceElementPurposeMember.def("SetName", (Standard_Boolean (StepElement_SurfaceElementPurposeMember::*)(const Standard_CString)) &StepElement_SurfaceElementPurposeMember::SetName, "Set name", py::arg("name"));
	cls_StepElement_SurfaceElementPurposeMember.def("Matches", (Standard_Boolean (StepElement_SurfaceElementPurposeMember::*)(const Standard_CString) const ) &StepElement_SurfaceElementPurposeMember::Matches, "Tells if the name of a SelectMember matches a given one;", py::arg("name"));
	cls_StepElement_SurfaceElementPurposeMember.def_static("get_type_name_", (const char * (*)()) &StepElement_SurfaceElementPurposeMember::get_type_name, "None");
	cls_StepElement_SurfaceElementPurposeMember.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_SurfaceElementPurposeMember::get_type_descriptor, "None");
	cls_StepElement_SurfaceElementPurposeMember.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_SurfaceElementPurposeMember::*)() const ) &StepElement_SurfaceElementPurposeMember::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_Sequence.hxx
	py::class_<StepElement_SequenceOfSurfaceElementPurposeMember, std::unique_ptr<StepElement_SequenceOfSurfaceElementPurposeMember, Deleter<StepElement_SequenceOfSurfaceElementPurposeMember>>, NCollection_BaseSequence> cls_StepElement_SequenceOfSurfaceElementPurposeMember(mod, "StepElement_SequenceOfSurfaceElementPurposeMember", "Purpose: Definition of a sequence of elements indexed by an Integer in range of 1..n");
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def(py::init<>());
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def(py::init<const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("theAllocator"));
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def(py::init([] (const StepElement_SequenceOfSurfaceElementPurposeMember &other) {return new StepElement_SequenceOfSurfaceElementPurposeMember(other);}), "Copy constructor", py::arg("other"));
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("begin", (StepElement_SequenceOfSurfaceElementPurposeMember::iterator (StepElement_SequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_SequenceOfSurfaceElementPurposeMember::begin, "Returns an iterator pointing to the first element in the sequence.");
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("end", (StepElement_SequenceOfSurfaceElementPurposeMember::iterator (StepElement_SequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_SequenceOfSurfaceElementPurposeMember::end, "Returns an iterator referring to the past-the-end element in the sequence.");
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("cbegin", (StepElement_SequenceOfSurfaceElementPurposeMember::const_iterator (StepElement_SequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_SequenceOfSurfaceElementPurposeMember::cbegin, "Returns a const iterator pointing to the first element in the sequence.");
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("cend", (StepElement_SequenceOfSurfaceElementPurposeMember::const_iterator (StepElement_SequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_SequenceOfSurfaceElementPurposeMember::cend, "Returns a const iterator referring to the past-the-end element in the sequence.");
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("Size", (Standard_Integer (StepElement_SequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_SequenceOfSurfaceElementPurposeMember::Size, "Number of items");
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("Length", (Standard_Integer (StepElement_SequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_SequenceOfSurfaceElementPurposeMember::Length, "Number of items");
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("Lower", (Standard_Integer (StepElement_SequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_SequenceOfSurfaceElementPurposeMember::Lower, "Method for consistency with other collections.");
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("Upper", (Standard_Integer (StepElement_SequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_SequenceOfSurfaceElementPurposeMember::Upper, "Method for consistency with other collections.");
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("IsEmpty", (Standard_Boolean (StepElement_SequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_SequenceOfSurfaceElementPurposeMember::IsEmpty, "Empty query");
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("Reverse", (void (StepElement_SequenceOfSurfaceElementPurposeMember::*)()) &StepElement_SequenceOfSurfaceElementPurposeMember::Reverse, "Reverse sequence");
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("Exchange", (void (StepElement_SequenceOfSurfaceElementPurposeMember::*)(const Standard_Integer, const Standard_Integer)) &StepElement_SequenceOfSurfaceElementPurposeMember::Exchange, "Exchange two members", py::arg("I"), py::arg("J"));
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def_static("delNode_", (void (*)(NCollection_SeqNode *, opencascade::handle<NCollection_BaseAllocator> &)) &StepElement_SequenceOfSurfaceElementPurposeMember::delNode, "Static deleter to be passed to BaseSequence", py::arg("theNode"), py::arg("theAl"));
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("Clear", [](StepElement_SequenceOfSurfaceElementPurposeMember &self) -> void { return self.Clear(); });
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("Clear", (void (StepElement_SequenceOfSurfaceElementPurposeMember::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &StepElement_SequenceOfSurfaceElementPurposeMember::Clear, "Clear the items out, take a new allocator if non null", py::arg("theAllocator"));
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("Assign", (StepElement_SequenceOfSurfaceElementPurposeMember & (StepElement_SequenceOfSurfaceElementPurposeMember::*)(const StepElement_SequenceOfSurfaceElementPurposeMember &)) &StepElement_SequenceOfSurfaceElementPurposeMember::Assign, "Replace this sequence by the items of theOther. This method does not change the internal allocator.", py::arg("theOther"));
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("assign", (StepElement_SequenceOfSurfaceElementPurposeMember & (StepElement_SequenceOfSurfaceElementPurposeMember::*)(const StepElement_SequenceOfSurfaceElementPurposeMember &)) &StepElement_SequenceOfSurfaceElementPurposeMember::operator=, py::is_operator(), "Replacement operator", py::arg("theOther"));
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("Remove", (void (StepElement_SequenceOfSurfaceElementPurposeMember::*)(StepElement_SequenceOfSurfaceElementPurposeMember::Iterator &)) &StepElement_SequenceOfSurfaceElementPurposeMember::Remove, "Remove one item", py::arg("thePosition"));
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("Remove", (void (StepElement_SequenceOfSurfaceElementPurposeMember::*)(const Standard_Integer)) &StepElement_SequenceOfSurfaceElementPurposeMember::Remove, "Remove one item", py::arg("theIndex"));
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("Remove", (void (StepElement_SequenceOfSurfaceElementPurposeMember::*)(const Standard_Integer, const Standard_Integer)) &StepElement_SequenceOfSurfaceElementPurposeMember::Remove, "Remove range of items", py::arg("theFromIndex"), py::arg("theToIndex"));
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("Append", (void (StepElement_SequenceOfSurfaceElementPurposeMember::*)(const opencascade::handle<StepElement_SurfaceElementPurposeMember> &)) &StepElement_SequenceOfSurfaceElementPurposeMember::Append, "Append one item", py::arg("theItem"));
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("Append", (void (StepElement_SequenceOfSurfaceElementPurposeMember::*)(StepElement_SequenceOfSurfaceElementPurposeMember &)) &StepElement_SequenceOfSurfaceElementPurposeMember::Append, "Append another sequence (making it empty)", py::arg("theSeq"));
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("Prepend", (void (StepElement_SequenceOfSurfaceElementPurposeMember::*)(const opencascade::handle<StepElement_SurfaceElementPurposeMember> &)) &StepElement_SequenceOfSurfaceElementPurposeMember::Prepend, "Prepend one item", py::arg("theItem"));
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("Prepend", (void (StepElement_SequenceOfSurfaceElementPurposeMember::*)(StepElement_SequenceOfSurfaceElementPurposeMember &)) &StepElement_SequenceOfSurfaceElementPurposeMember::Prepend, "Prepend another sequence (making it empty)", py::arg("theSeq"));
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("InsertBefore", (void (StepElement_SequenceOfSurfaceElementPurposeMember::*)(const Standard_Integer, const opencascade::handle<StepElement_SurfaceElementPurposeMember> &)) &StepElement_SequenceOfSurfaceElementPurposeMember::InsertBefore, "InsertBefore theIndex theItem", py::arg("theIndex"), py::arg("theItem"));
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("InsertBefore", (void (StepElement_SequenceOfSurfaceElementPurposeMember::*)(const Standard_Integer, StepElement_SequenceOfSurfaceElementPurposeMember &)) &StepElement_SequenceOfSurfaceElementPurposeMember::InsertBefore, "InsertBefore theIndex another sequence", py::arg("theIndex"), py::arg("theSeq"));
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("InsertAfter", (void (StepElement_SequenceOfSurfaceElementPurposeMember::*)(StepElement_SequenceOfSurfaceElementPurposeMember::Iterator &, const opencascade::handle<StepElement_SurfaceElementPurposeMember> &)) &StepElement_SequenceOfSurfaceElementPurposeMember::InsertAfter, "InsertAfter the position of iterator", py::arg("thePosition"), py::arg("theItem"));
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("InsertAfter", (void (StepElement_SequenceOfSurfaceElementPurposeMember::*)(const Standard_Integer, StepElement_SequenceOfSurfaceElementPurposeMember &)) &StepElement_SequenceOfSurfaceElementPurposeMember::InsertAfter, "InsertAfter theIndex theItem", py::arg("theIndex"), py::arg("theSeq"));
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("InsertAfter", (void (StepElement_SequenceOfSurfaceElementPurposeMember::*)(const Standard_Integer, const opencascade::handle<StepElement_SurfaceElementPurposeMember> &)) &StepElement_SequenceOfSurfaceElementPurposeMember::InsertAfter, "InsertAfter theIndex another sequence", py::arg("theIndex"), py::arg("theItem"));
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("Split", (void (StepElement_SequenceOfSurfaceElementPurposeMember::*)(const Standard_Integer, StepElement_SequenceOfSurfaceElementPurposeMember &)) &StepElement_SequenceOfSurfaceElementPurposeMember::Split, "Split in two sequences", py::arg("theIndex"), py::arg("theSeq"));
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("First", (const opencascade::handle<StepElement_SurfaceElementPurposeMember> & (StepElement_SequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_SequenceOfSurfaceElementPurposeMember::First, "First item access");
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("ChangeFirst", (opencascade::handle<StepElement_SurfaceElementPurposeMember> & (StepElement_SequenceOfSurfaceElementPurposeMember::*)()) &StepElement_SequenceOfSurfaceElementPurposeMember::ChangeFirst, "First item access");
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("Last", (const opencascade::handle<StepElement_SurfaceElementPurposeMember> & (StepElement_SequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_SequenceOfSurfaceElementPurposeMember::Last, "Last item access");
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("ChangeLast", (opencascade::handle<StepElement_SurfaceElementPurposeMember> & (StepElement_SequenceOfSurfaceElementPurposeMember::*)()) &StepElement_SequenceOfSurfaceElementPurposeMember::ChangeLast, "Last item access");
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("Value", (const opencascade::handle<StepElement_SurfaceElementPurposeMember> & (StepElement_SequenceOfSurfaceElementPurposeMember::*)(const Standard_Integer) const ) &StepElement_SequenceOfSurfaceElementPurposeMember::Value, "Constant item access by theIndex", py::arg("theIndex"));
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("__call__", (const opencascade::handle<StepElement_SurfaceElementPurposeMember> & (StepElement_SequenceOfSurfaceElementPurposeMember::*)(const Standard_Integer) const ) &StepElement_SequenceOfSurfaceElementPurposeMember::operator(), py::is_operator(), "Constant operator()", py::arg("theIndex"));
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("ChangeValue", (opencascade::handle<StepElement_SurfaceElementPurposeMember> & (StepElement_SequenceOfSurfaceElementPurposeMember::*)(const Standard_Integer)) &StepElement_SequenceOfSurfaceElementPurposeMember::ChangeValue, "Variable item access by theIndex", py::arg("theIndex"));
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("__call__", (opencascade::handle<StepElement_SurfaceElementPurposeMember> & (StepElement_SequenceOfSurfaceElementPurposeMember::*)(const Standard_Integer)) &StepElement_SequenceOfSurfaceElementPurposeMember::operator(), py::is_operator(), "Variable operator()", py::arg("theIndex"));
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("SetValue", (void (StepElement_SequenceOfSurfaceElementPurposeMember::*)(const Standard_Integer, const opencascade::handle<StepElement_SurfaceElementPurposeMember> &)) &StepElement_SequenceOfSurfaceElementPurposeMember::SetValue, "Set item value by theIndex", py::arg("theIndex"), py::arg("theItem"));
	cls_StepElement_SequenceOfSurfaceElementPurposeMember.def("__iter__", [](const StepElement_SequenceOfSurfaceElementPurposeMember &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_MeasureOrUnspecifiedValue.hxx
	py::class_<StepElement_MeasureOrUnspecifiedValue, std::unique_ptr<StepElement_MeasureOrUnspecifiedValue, Deleter<StepElement_MeasureOrUnspecifiedValue>>, StepData_SelectType> cls_StepElement_MeasureOrUnspecifiedValue(mod, "StepElement_MeasureOrUnspecifiedValue", "Representation of STEP SELECT type MeasureOrUnspecifiedValue");
	cls_StepElement_MeasureOrUnspecifiedValue.def(py::init<>());
	cls_StepElement_MeasureOrUnspecifiedValue.def("CaseNum", (Standard_Integer (StepElement_MeasureOrUnspecifiedValue::*)(const opencascade::handle<Standard_Transient> &) const ) &StepElement_MeasureOrUnspecifiedValue::CaseNum, "Recognizes a kind of MeasureOrUnspecifiedValue select type return 0", py::arg("ent"));
	cls_StepElement_MeasureOrUnspecifiedValue.def("CaseMem", (Standard_Integer (StepElement_MeasureOrUnspecifiedValue::*)(const opencascade::handle<StepData_SelectMember> &) const ) &StepElement_MeasureOrUnspecifiedValue::CaseMem, "Recognizes a items of select member MeasureOrUnspecifiedValueMember 1 -> ContextDependentMeasure 2 -> UnspecifiedValue 0 else", py::arg("ent"));
	cls_StepElement_MeasureOrUnspecifiedValue.def("NewMember", (opencascade::handle<StepData_SelectMember> (StepElement_MeasureOrUnspecifiedValue::*)() const ) &StepElement_MeasureOrUnspecifiedValue::NewMember, "Returns a new select member the type MeasureOrUnspecifiedValueMember");
	cls_StepElement_MeasureOrUnspecifiedValue.def("SetContextDependentMeasure", (void (StepElement_MeasureOrUnspecifiedValue::*)(const Standard_Real)) &StepElement_MeasureOrUnspecifiedValue::SetContextDependentMeasure, "Set Value for ContextDependentMeasure", py::arg("aVal"));
	cls_StepElement_MeasureOrUnspecifiedValue.def("ContextDependentMeasure", (Standard_Real (StepElement_MeasureOrUnspecifiedValue::*)() const ) &StepElement_MeasureOrUnspecifiedValue::ContextDependentMeasure, "Returns Value as ContextDependentMeasure (or Null if another type)");
	cls_StepElement_MeasureOrUnspecifiedValue.def("SetUnspecifiedValue", (void (StepElement_MeasureOrUnspecifiedValue::*)(const StepElement_UnspecifiedValue)) &StepElement_MeasureOrUnspecifiedValue::SetUnspecifiedValue, "Set Value for UnspecifiedValue", py::arg("aVal"));
	cls_StepElement_MeasureOrUnspecifiedValue.def("UnspecifiedValue", (StepElement_UnspecifiedValue (StepElement_MeasureOrUnspecifiedValue::*)() const ) &StepElement_MeasureOrUnspecifiedValue::UnspecifiedValue, "Returns Value as UnspecifiedValue (or Null if another type)");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_VolumeElementPurpose.hxx
	py::class_<StepElement_VolumeElementPurpose, std::unique_ptr<StepElement_VolumeElementPurpose, Deleter<StepElement_VolumeElementPurpose>>, StepData_SelectType> cls_StepElement_VolumeElementPurpose(mod, "StepElement_VolumeElementPurpose", "Representation of STEP SELECT type VolumeElementPurpose");
	cls_StepElement_VolumeElementPurpose.def(py::init<>());
	cls_StepElement_VolumeElementPurpose.def("CaseNum", (Standard_Integer (StepElement_VolumeElementPurpose::*)(const opencascade::handle<Standard_Transient> &) const ) &StepElement_VolumeElementPurpose::CaseNum, "Recognizes a kind of VolumeElementPurpose select type return 0", py::arg("ent"));
	cls_StepElement_VolumeElementPurpose.def("CaseMem", (Standard_Integer (StepElement_VolumeElementPurpose::*)(const opencascade::handle<StepData_SelectMember> &) const ) &StepElement_VolumeElementPurpose::CaseMem, "Recognizes a items of select member VolumeElementPurposeMember 1 -> EnumeratedVolumeElementPurpose 2 -> ApplicationDefinedElementPurpose 0 else", py::arg("ent"));
	cls_StepElement_VolumeElementPurpose.def("NewMember", (opencascade::handle<StepData_SelectMember> (StepElement_VolumeElementPurpose::*)() const ) &StepElement_VolumeElementPurpose::NewMember, "Returns a new select member the type VolumeElementPurposeMember");
	cls_StepElement_VolumeElementPurpose.def("SetEnumeratedVolumeElementPurpose", (void (StepElement_VolumeElementPurpose::*)(const StepElement_EnumeratedVolumeElementPurpose)) &StepElement_VolumeElementPurpose::SetEnumeratedVolumeElementPurpose, "Set Value for EnumeratedVolumeElementPurpose", py::arg("aVal"));
	cls_StepElement_VolumeElementPurpose.def("EnumeratedVolumeElementPurpose", (StepElement_EnumeratedVolumeElementPurpose (StepElement_VolumeElementPurpose::*)() const ) &StepElement_VolumeElementPurpose::EnumeratedVolumeElementPurpose, "Returns Value as EnumeratedVolumeElementPurpose (or Null if another type)");
	cls_StepElement_VolumeElementPurpose.def("SetApplicationDefinedElementPurpose", (void (StepElement_VolumeElementPurpose::*)(const opencascade::handle<TCollection_HAsciiString> &)) &StepElement_VolumeElementPurpose::SetApplicationDefinedElementPurpose, "Set Value for ApplicationDefinedElementPurpose", py::arg("aVal"));
	cls_StepElement_VolumeElementPurpose.def("ApplicationDefinedElementPurpose", (opencascade::handle<TCollection_HAsciiString> (StepElement_VolumeElementPurpose::*)() const ) &StepElement_VolumeElementPurpose::ApplicationDefinedElementPurpose, "Returns Value as ApplicationDefinedElementPurpose (or Null if another type)");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_VolumeElementPurposeMember.hxx
	py::class_<StepElement_VolumeElementPurposeMember, opencascade::handle<StepElement_VolumeElementPurposeMember>, StepData_SelectNamed> cls_StepElement_VolumeElementPurposeMember(mod, "StepElement_VolumeElementPurposeMember", "Representation of member for STEP SELECT type VolumeElementPurpose");
	cls_StepElement_VolumeElementPurposeMember.def(py::init<>());
	cls_StepElement_VolumeElementPurposeMember.def("HasName", (Standard_Boolean (StepElement_VolumeElementPurposeMember::*)() const ) &StepElement_VolumeElementPurposeMember::HasName, "Returns True if has name");
	cls_StepElement_VolumeElementPurposeMember.def("Name", (Standard_CString (StepElement_VolumeElementPurposeMember::*)() const ) &StepElement_VolumeElementPurposeMember::Name, "Returns set name");
	cls_StepElement_VolumeElementPurposeMember.def("SetName", (Standard_Boolean (StepElement_VolumeElementPurposeMember::*)(const Standard_CString)) &StepElement_VolumeElementPurposeMember::SetName, "Set name", py::arg("name"));
	cls_StepElement_VolumeElementPurposeMember.def("Matches", (Standard_Boolean (StepElement_VolumeElementPurposeMember::*)(const Standard_CString) const ) &StepElement_VolumeElementPurposeMember::Matches, "Tells if the name of a SelectMember matches a given one;", py::arg("name"));
	cls_StepElement_VolumeElementPurposeMember.def_static("get_type_name_", (const char * (*)()) &StepElement_VolumeElementPurposeMember::get_type_name, "None");
	cls_StepElement_VolumeElementPurposeMember.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_VolumeElementPurposeMember::get_type_descriptor, "None");
	cls_StepElement_VolumeElementPurposeMember.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_VolumeElementPurposeMember::*)() const ) &StepElement_VolumeElementPurposeMember::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_SurfaceElementPurpose.hxx
	py::class_<StepElement_SurfaceElementPurpose, std::unique_ptr<StepElement_SurfaceElementPurpose, Deleter<StepElement_SurfaceElementPurpose>>, StepData_SelectType> cls_StepElement_SurfaceElementPurpose(mod, "StepElement_SurfaceElementPurpose", "Representation of STEP SELECT type SurfaceElementPurpose");
	cls_StepElement_SurfaceElementPurpose.def(py::init<>());
	cls_StepElement_SurfaceElementPurpose.def("CaseNum", (Standard_Integer (StepElement_SurfaceElementPurpose::*)(const opencascade::handle<Standard_Transient> &) const ) &StepElement_SurfaceElementPurpose::CaseNum, "Recognizes a kind of SurfaceElementPurpose select type return 0", py::arg("ent"));
	cls_StepElement_SurfaceElementPurpose.def("CaseMem", (Standard_Integer (StepElement_SurfaceElementPurpose::*)(const opencascade::handle<StepData_SelectMember> &) const ) &StepElement_SurfaceElementPurpose::CaseMem, "Recognizes a items of select member SurfaceElementPurposeMember 1 -> EnumeratedSurfaceElementPurpose 2 -> ApplicationDefinedElementPurpose 0 else", py::arg("ent"));
	cls_StepElement_SurfaceElementPurpose.def("NewMember", (opencascade::handle<StepData_SelectMember> (StepElement_SurfaceElementPurpose::*)() const ) &StepElement_SurfaceElementPurpose::NewMember, "Returns a new select member the type SurfaceElementPurposeMember");
	cls_StepElement_SurfaceElementPurpose.def("SetEnumeratedSurfaceElementPurpose", (void (StepElement_SurfaceElementPurpose::*)(const StepElement_EnumeratedSurfaceElementPurpose)) &StepElement_SurfaceElementPurpose::SetEnumeratedSurfaceElementPurpose, "Set Value for EnumeratedSurfaceElementPurpose", py::arg("aVal"));
	cls_StepElement_SurfaceElementPurpose.def("EnumeratedSurfaceElementPurpose", (StepElement_EnumeratedSurfaceElementPurpose (StepElement_SurfaceElementPurpose::*)() const ) &StepElement_SurfaceElementPurpose::EnumeratedSurfaceElementPurpose, "Returns Value as EnumeratedSurfaceElementPurpose (or Null if another type)");
	cls_StepElement_SurfaceElementPurpose.def("SetApplicationDefinedElementPurpose", (void (StepElement_SurfaceElementPurpose::*)(const opencascade::handle<TCollection_HAsciiString> &)) &StepElement_SurfaceElementPurpose::SetApplicationDefinedElementPurpose, "Set Value for ApplicationDefinedElementPurpose", py::arg("aVal"));
	cls_StepElement_SurfaceElementPurpose.def("ApplicationDefinedElementPurpose", (opencascade::handle<TCollection_HAsciiString> (StepElement_SurfaceElementPurpose::*)() const ) &StepElement_SurfaceElementPurpose::ApplicationDefinedElementPurpose, "Returns Value as ApplicationDefinedElementPurpose (or Null if another type)");

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_Array1.hxx
	py::class_<StepElement_Array1OfHSequenceOfCurveElementPurposeMember, std::unique_ptr<StepElement_Array1OfHSequenceOfCurveElementPurposeMember, Deleter<StepElement_Array1OfHSequenceOfCurveElementPurposeMember>>> cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember(mod, "StepElement_Array1OfHSequenceOfCurveElementPurposeMember", "Purpose: The class Array1 represents unidimensional arrays of fixed size known at run time. The range of the index is user defined. An array1 can be constructed with a 'C array'. This functionality is useful to call methods expecting an Array1. It allows to carry the bounds inside the arrays.");
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def(py::init<>());
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def(py::init<const Standard_Integer, const Standard_Integer>(), py::arg("theLower"), py::arg("theUpper"));
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def(py::init([] (const StepElement_Array1OfHSequenceOfCurveElementPurposeMember &other) {return new StepElement_Array1OfHSequenceOfCurveElementPurposeMember(other);}), "Copy constructor", py::arg("other"));
	// FIXME cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def(py::init<StepElement_Array1OfHSequenceOfCurveElementPurposeMember &&>(), py::arg("theOther"));
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def(py::init<const opencascade::handle<StepElement_HSequenceOfCurveElementPurposeMember> &, const Standard_Integer, const Standard_Integer>(), py::arg("theBegin"), py::arg("theLower"), py::arg("theUpper"));
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("begin", (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::iterator (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::begin, "Returns an iterator pointing to the first element in the array.");
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("end", (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::iterator (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::end, "Returns an iterator referring to the past-the-end element in the array.");
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("cbegin", (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::const_iterator (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::cbegin, "Returns a const iterator pointing to the first element in the array.");
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("cend", (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::const_iterator (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::cend, "Returns a const iterator referring to the past-the-end element in the array.");
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("Init", (void (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)(const opencascade::handle<StepElement_HSequenceOfCurveElementPurposeMember> &)) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::Init, "Initialise the items with theValue", py::arg("theValue"));
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("Size", (Standard_Integer (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::Size, "Size query");
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("Length", (Standard_Integer (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::Length, "Length query (the same)");
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("IsEmpty", (Standard_Boolean (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::IsEmpty, "Return TRUE if array has zero length.");
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("Lower", (Standard_Integer (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::Lower, "Lower bound");
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("Upper", (Standard_Integer (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::Upper, "Upper bound");
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("IsDeletable", (Standard_Boolean (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::IsDeletable, "myDeletable flag");
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("IsAllocated", (Standard_Boolean (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::IsAllocated, "IsAllocated flag - for naming compatibility");
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("Assign", (StepElement_Array1OfHSequenceOfCurveElementPurposeMember & (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)(const StepElement_Array1OfHSequenceOfCurveElementPurposeMember &)) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::Assign, "Assignment", py::arg("theOther"));
	// FIXME cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("Move", (StepElement_Array1OfHSequenceOfCurveElementPurposeMember & (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)(StepElement_Array1OfHSequenceOfCurveElementPurposeMember &&)) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::Move, "Move assignment", py::arg("theOther"));
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("assign", (StepElement_Array1OfHSequenceOfCurveElementPurposeMember & (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)(const StepElement_Array1OfHSequenceOfCurveElementPurposeMember &)) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	// FIXME cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("assign", (StepElement_Array1OfHSequenceOfCurveElementPurposeMember & (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)(StepElement_Array1OfHSequenceOfCurveElementPurposeMember &&)) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::operator=, py::is_operator(), "Move assignment operator.", py::arg("theOther"));
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("First", (const opencascade::handle<StepElement_HSequenceOfCurveElementPurposeMember> & (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::First, "Returns first element");
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("ChangeFirst", (opencascade::handle<StepElement_HSequenceOfCurveElementPurposeMember> & (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)()) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::ChangeFirst, "Returns first element");
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("Last", (const opencascade::handle<StepElement_HSequenceOfCurveElementPurposeMember> & (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::Last, "Returns last element");
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("ChangeLast", (opencascade::handle<StepElement_HSequenceOfCurveElementPurposeMember> & (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)()) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::ChangeLast, "Returns last element");
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("Value", (const opencascade::handle<StepElement_HSequenceOfCurveElementPurposeMember> & (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)(const Standard_Integer) const ) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::Value, "Constant value access", py::arg("theIndex"));
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("__call__", (const opencascade::handle<StepElement_HSequenceOfCurveElementPurposeMember> & (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)(const Standard_Integer) const ) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::operator(), py::is_operator(), "operator() - alias to Value", py::arg("theIndex"));
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("ChangeValue", (opencascade::handle<StepElement_HSequenceOfCurveElementPurposeMember> & (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)(const Standard_Integer)) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::ChangeValue, "Variable value access", py::arg("theIndex"));
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("__call__", (opencascade::handle<StepElement_HSequenceOfCurveElementPurposeMember> & (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)(const Standard_Integer)) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::operator(), py::is_operator(), "operator() - alias to ChangeValue", py::arg("theIndex"));
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("SetValue", (void (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)(const Standard_Integer, const opencascade::handle<StepElement_HSequenceOfCurveElementPurposeMember> &)) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::SetValue, "Set value", py::arg("theIndex"), py::arg("theItem"));
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("Resize", (void (StepElement_Array1OfHSequenceOfCurveElementPurposeMember::*)(const Standard_Integer, const Standard_Integer, const Standard_Boolean)) &StepElement_Array1OfHSequenceOfCurveElementPurposeMember::Resize, "Resizes the array to specified bounds. No re-allocation will be done if length of array does not change, but existing values will not be discarded if theToCopyData set to FALSE.", py::arg("theLower"), py::arg("theUpper"), py::arg("theToCopyData"));
	cls_StepElement_Array1OfHSequenceOfCurveElementPurposeMember.def("__iter__", [](const StepElement_Array1OfHSequenceOfCurveElementPurposeMember &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_CurveElementFreedomMember.hxx
	py::class_<StepElement_CurveElementFreedomMember, opencascade::handle<StepElement_CurveElementFreedomMember>, StepData_SelectNamed> cls_StepElement_CurveElementFreedomMember(mod, "StepElement_CurveElementFreedomMember", "Representation of member for STEP SELECT type CurveElementFreedom");
	cls_StepElement_CurveElementFreedomMember.def(py::init<>());
	cls_StepElement_CurveElementFreedomMember.def("HasName", (Standard_Boolean (StepElement_CurveElementFreedomMember::*)() const ) &StepElement_CurveElementFreedomMember::HasName, "Returns True if has name");
	cls_StepElement_CurveElementFreedomMember.def("Name", (Standard_CString (StepElement_CurveElementFreedomMember::*)() const ) &StepElement_CurveElementFreedomMember::Name, "Returns set name");
	cls_StepElement_CurveElementFreedomMember.def("SetName", (Standard_Boolean (StepElement_CurveElementFreedomMember::*)(const Standard_CString)) &StepElement_CurveElementFreedomMember::SetName, "Set name", py::arg("name"));
	cls_StepElement_CurveElementFreedomMember.def("Matches", (Standard_Boolean (StepElement_CurveElementFreedomMember::*)(const Standard_CString) const ) &StepElement_CurveElementFreedomMember::Matches, "Tells if the name of a SelectMember matches a given one;", py::arg("name"));
	cls_StepElement_CurveElementFreedomMember.def_static("get_type_name_", (const char * (*)()) &StepElement_CurveElementFreedomMember::get_type_name, "None");
	cls_StepElement_CurveElementFreedomMember.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_CurveElementFreedomMember::get_type_descriptor, "None");
	cls_StepElement_CurveElementFreedomMember.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_CurveElementFreedomMember::*)() const ) &StepElement_CurveElementFreedomMember::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_CurveElementPurpose.hxx
	py::class_<StepElement_CurveElementPurpose, std::unique_ptr<StepElement_CurveElementPurpose, Deleter<StepElement_CurveElementPurpose>>, StepData_SelectType> cls_StepElement_CurveElementPurpose(mod, "StepElement_CurveElementPurpose", "Representation of STEP SELECT type CurveElementPurpose");
	cls_StepElement_CurveElementPurpose.def(py::init<>());
	cls_StepElement_CurveElementPurpose.def("CaseNum", (Standard_Integer (StepElement_CurveElementPurpose::*)(const opencascade::handle<Standard_Transient> &) const ) &StepElement_CurveElementPurpose::CaseNum, "Recognizes a kind of CurveElementPurpose select type return 0", py::arg("ent"));
	cls_StepElement_CurveElementPurpose.def("CaseMem", (Standard_Integer (StepElement_CurveElementPurpose::*)(const opencascade::handle<StepData_SelectMember> &) const ) &StepElement_CurveElementPurpose::CaseMem, "Recognizes a items of select member CurveElementPurposeMember 1 -> EnumeratedCurveElementPurpose 2 -> ApplicationDefinedElementPurpose 0 else", py::arg("ent"));
	cls_StepElement_CurveElementPurpose.def("NewMember", (opencascade::handle<StepData_SelectMember> (StepElement_CurveElementPurpose::*)() const ) &StepElement_CurveElementPurpose::NewMember, "Returns a new select member the type CurveElementPurposeMember");
	cls_StepElement_CurveElementPurpose.def("SetEnumeratedCurveElementPurpose", (void (StepElement_CurveElementPurpose::*)(const StepElement_EnumeratedCurveElementPurpose)) &StepElement_CurveElementPurpose::SetEnumeratedCurveElementPurpose, "Set Value for EnumeratedCurveElementPurpose", py::arg("aVal"));
	cls_StepElement_CurveElementPurpose.def("EnumeratedCurveElementPurpose", (StepElement_EnumeratedCurveElementPurpose (StepElement_CurveElementPurpose::*)() const ) &StepElement_CurveElementPurpose::EnumeratedCurveElementPurpose, "Returns Value as EnumeratedCurveElementPurpose (or Null if another type)");
	cls_StepElement_CurveElementPurpose.def("SetApplicationDefinedElementPurpose", (void (StepElement_CurveElementPurpose::*)(const opencascade::handle<TCollection_HAsciiString> &)) &StepElement_CurveElementPurpose::SetApplicationDefinedElementPurpose, "Set Value for ApplicationDefinedElementPurpose", py::arg("aVal"));
	cls_StepElement_CurveElementPurpose.def("ApplicationDefinedElementPurpose", (opencascade::handle<TCollection_HAsciiString> (StepElement_CurveElementPurpose::*)() const ) &StepElement_CurveElementPurpose::ApplicationDefinedElementPurpose, "Returns Value as ApplicationDefinedElementPurpose (or Null if another type)");

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_Array1.hxx
	py::class_<StepElement_Array1OfMeasureOrUnspecifiedValue, std::unique_ptr<StepElement_Array1OfMeasureOrUnspecifiedValue, Deleter<StepElement_Array1OfMeasureOrUnspecifiedValue>>> cls_StepElement_Array1OfMeasureOrUnspecifiedValue(mod, "StepElement_Array1OfMeasureOrUnspecifiedValue", "Purpose: The class Array1 represents unidimensional arrays of fixed size known at run time. The range of the index is user defined. An array1 can be constructed with a 'C array'. This functionality is useful to call methods expecting an Array1. It allows to carry the bounds inside the arrays.");
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def(py::init<>());
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def(py::init<const Standard_Integer, const Standard_Integer>(), py::arg("theLower"), py::arg("theUpper"));
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def(py::init([] (const StepElement_Array1OfMeasureOrUnspecifiedValue &other) {return new StepElement_Array1OfMeasureOrUnspecifiedValue(other);}), "Copy constructor", py::arg("other"));
	// FIXME cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def(py::init<StepElement_Array1OfMeasureOrUnspecifiedValue &&>(), py::arg("theOther"));
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def(py::init<const StepElement_MeasureOrUnspecifiedValue &, const Standard_Integer, const Standard_Integer>(), py::arg("theBegin"), py::arg("theLower"), py::arg("theUpper"));
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("begin", (StepElement_Array1OfMeasureOrUnspecifiedValue::iterator (StepElement_Array1OfMeasureOrUnspecifiedValue::*)() const ) &StepElement_Array1OfMeasureOrUnspecifiedValue::begin, "Returns an iterator pointing to the first element in the array.");
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("end", (StepElement_Array1OfMeasureOrUnspecifiedValue::iterator (StepElement_Array1OfMeasureOrUnspecifiedValue::*)() const ) &StepElement_Array1OfMeasureOrUnspecifiedValue::end, "Returns an iterator referring to the past-the-end element in the array.");
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("cbegin", (StepElement_Array1OfMeasureOrUnspecifiedValue::const_iterator (StepElement_Array1OfMeasureOrUnspecifiedValue::*)() const ) &StepElement_Array1OfMeasureOrUnspecifiedValue::cbegin, "Returns a const iterator pointing to the first element in the array.");
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("cend", (StepElement_Array1OfMeasureOrUnspecifiedValue::const_iterator (StepElement_Array1OfMeasureOrUnspecifiedValue::*)() const ) &StepElement_Array1OfMeasureOrUnspecifiedValue::cend, "Returns a const iterator referring to the past-the-end element in the array.");
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("Init", (void (StepElement_Array1OfMeasureOrUnspecifiedValue::*)(const StepElement_MeasureOrUnspecifiedValue &)) &StepElement_Array1OfMeasureOrUnspecifiedValue::Init, "Initialise the items with theValue", py::arg("theValue"));
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("Size", (Standard_Integer (StepElement_Array1OfMeasureOrUnspecifiedValue::*)() const ) &StepElement_Array1OfMeasureOrUnspecifiedValue::Size, "Size query");
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("Length", (Standard_Integer (StepElement_Array1OfMeasureOrUnspecifiedValue::*)() const ) &StepElement_Array1OfMeasureOrUnspecifiedValue::Length, "Length query (the same)");
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("IsEmpty", (Standard_Boolean (StepElement_Array1OfMeasureOrUnspecifiedValue::*)() const ) &StepElement_Array1OfMeasureOrUnspecifiedValue::IsEmpty, "Return TRUE if array has zero length.");
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("Lower", (Standard_Integer (StepElement_Array1OfMeasureOrUnspecifiedValue::*)() const ) &StepElement_Array1OfMeasureOrUnspecifiedValue::Lower, "Lower bound");
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("Upper", (Standard_Integer (StepElement_Array1OfMeasureOrUnspecifiedValue::*)() const ) &StepElement_Array1OfMeasureOrUnspecifiedValue::Upper, "Upper bound");
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("IsDeletable", (Standard_Boolean (StepElement_Array1OfMeasureOrUnspecifiedValue::*)() const ) &StepElement_Array1OfMeasureOrUnspecifiedValue::IsDeletable, "myDeletable flag");
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("IsAllocated", (Standard_Boolean (StepElement_Array1OfMeasureOrUnspecifiedValue::*)() const ) &StepElement_Array1OfMeasureOrUnspecifiedValue::IsAllocated, "IsAllocated flag - for naming compatibility");
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("Assign", (StepElement_Array1OfMeasureOrUnspecifiedValue & (StepElement_Array1OfMeasureOrUnspecifiedValue::*)(const StepElement_Array1OfMeasureOrUnspecifiedValue &)) &StepElement_Array1OfMeasureOrUnspecifiedValue::Assign, "Assignment", py::arg("theOther"));
	// FIXME cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("Move", (StepElement_Array1OfMeasureOrUnspecifiedValue & (StepElement_Array1OfMeasureOrUnspecifiedValue::*)(StepElement_Array1OfMeasureOrUnspecifiedValue &&)) &StepElement_Array1OfMeasureOrUnspecifiedValue::Move, "Move assignment", py::arg("theOther"));
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("assign", (StepElement_Array1OfMeasureOrUnspecifiedValue & (StepElement_Array1OfMeasureOrUnspecifiedValue::*)(const StepElement_Array1OfMeasureOrUnspecifiedValue &)) &StepElement_Array1OfMeasureOrUnspecifiedValue::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	// FIXME cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("assign", (StepElement_Array1OfMeasureOrUnspecifiedValue & (StepElement_Array1OfMeasureOrUnspecifiedValue::*)(StepElement_Array1OfMeasureOrUnspecifiedValue &&)) &StepElement_Array1OfMeasureOrUnspecifiedValue::operator=, py::is_operator(), "Move assignment operator.", py::arg("theOther"));
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("First", (const StepElement_MeasureOrUnspecifiedValue & (StepElement_Array1OfMeasureOrUnspecifiedValue::*)() const ) &StepElement_Array1OfMeasureOrUnspecifiedValue::First, "Returns first element");
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("ChangeFirst", (StepElement_MeasureOrUnspecifiedValue & (StepElement_Array1OfMeasureOrUnspecifiedValue::*)()) &StepElement_Array1OfMeasureOrUnspecifiedValue::ChangeFirst, "Returns first element");
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("Last", (const StepElement_MeasureOrUnspecifiedValue & (StepElement_Array1OfMeasureOrUnspecifiedValue::*)() const ) &StepElement_Array1OfMeasureOrUnspecifiedValue::Last, "Returns last element");
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("ChangeLast", (StepElement_MeasureOrUnspecifiedValue & (StepElement_Array1OfMeasureOrUnspecifiedValue::*)()) &StepElement_Array1OfMeasureOrUnspecifiedValue::ChangeLast, "Returns last element");
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("Value", (const StepElement_MeasureOrUnspecifiedValue & (StepElement_Array1OfMeasureOrUnspecifiedValue::*)(const Standard_Integer) const ) &StepElement_Array1OfMeasureOrUnspecifiedValue::Value, "Constant value access", py::arg("theIndex"));
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("__call__", (const StepElement_MeasureOrUnspecifiedValue & (StepElement_Array1OfMeasureOrUnspecifiedValue::*)(const Standard_Integer) const ) &StepElement_Array1OfMeasureOrUnspecifiedValue::operator(), py::is_operator(), "operator() - alias to Value", py::arg("theIndex"));
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("ChangeValue", (StepElement_MeasureOrUnspecifiedValue & (StepElement_Array1OfMeasureOrUnspecifiedValue::*)(const Standard_Integer)) &StepElement_Array1OfMeasureOrUnspecifiedValue::ChangeValue, "Variable value access", py::arg("theIndex"));
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("__call__", (StepElement_MeasureOrUnspecifiedValue & (StepElement_Array1OfMeasureOrUnspecifiedValue::*)(const Standard_Integer)) &StepElement_Array1OfMeasureOrUnspecifiedValue::operator(), py::is_operator(), "operator() - alias to ChangeValue", py::arg("theIndex"));
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("SetValue", (void (StepElement_Array1OfMeasureOrUnspecifiedValue::*)(const Standard_Integer, const StepElement_MeasureOrUnspecifiedValue &)) &StepElement_Array1OfMeasureOrUnspecifiedValue::SetValue, "Set value", py::arg("theIndex"), py::arg("theItem"));
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("Resize", (void (StepElement_Array1OfMeasureOrUnspecifiedValue::*)(const Standard_Integer, const Standard_Integer, const Standard_Boolean)) &StepElement_Array1OfMeasureOrUnspecifiedValue::Resize, "Resizes the array to specified bounds. No re-allocation will be done if length of array does not change, but existing values will not be discarded if theToCopyData set to FALSE.", py::arg("theLower"), py::arg("theUpper"), py::arg("theToCopyData"));
	cls_StepElement_Array1OfMeasureOrUnspecifiedValue.def("__iter__", [](const StepElement_Array1OfMeasureOrUnspecifiedValue &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_ElementAspectMember.hxx
	py::class_<StepElement_ElementAspectMember, opencascade::handle<StepElement_ElementAspectMember>, StepData_SelectNamed> cls_StepElement_ElementAspectMember(mod, "StepElement_ElementAspectMember", "Representation of member for STEP SELECT type ElementAspect");
	cls_StepElement_ElementAspectMember.def(py::init<>());
	cls_StepElement_ElementAspectMember.def("HasName", (Standard_Boolean (StepElement_ElementAspectMember::*)() const ) &StepElement_ElementAspectMember::HasName, "Returns True if has name");
	cls_StepElement_ElementAspectMember.def("Name", (Standard_CString (StepElement_ElementAspectMember::*)() const ) &StepElement_ElementAspectMember::Name, "Returns set name");
	cls_StepElement_ElementAspectMember.def("SetName", (Standard_Boolean (StepElement_ElementAspectMember::*)(const Standard_CString)) &StepElement_ElementAspectMember::SetName, "Set name", py::arg("name"));
	cls_StepElement_ElementAspectMember.def("Matches", (Standard_Boolean (StepElement_ElementAspectMember::*)(const Standard_CString) const ) &StepElement_ElementAspectMember::Matches, "Tells if the name of a SelectMember matches a given one;", py::arg("name"));
	cls_StepElement_ElementAspectMember.def_static("get_type_name_", (const char * (*)()) &StepElement_ElementAspectMember::get_type_name, "None");
	cls_StepElement_ElementAspectMember.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_ElementAspectMember::get_type_descriptor, "None");
	cls_StepElement_ElementAspectMember.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_ElementAspectMember::*)() const ) &StepElement_ElementAspectMember::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_Array1.hxx
	py::class_<StepElement_Array1OfCurveElementEndReleasePacket, std::unique_ptr<StepElement_Array1OfCurveElementEndReleasePacket, Deleter<StepElement_Array1OfCurveElementEndReleasePacket>>> cls_StepElement_Array1OfCurveElementEndReleasePacket(mod, "StepElement_Array1OfCurveElementEndReleasePacket", "Purpose: The class Array1 represents unidimensional arrays of fixed size known at run time. The range of the index is user defined. An array1 can be constructed with a 'C array'. This functionality is useful to call methods expecting an Array1. It allows to carry the bounds inside the arrays.");
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def(py::init<>());
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def(py::init<const Standard_Integer, const Standard_Integer>(), py::arg("theLower"), py::arg("theUpper"));
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def(py::init([] (const StepElement_Array1OfCurveElementEndReleasePacket &other) {return new StepElement_Array1OfCurveElementEndReleasePacket(other);}), "Copy constructor", py::arg("other"));
	// FIXME cls_StepElement_Array1OfCurveElementEndReleasePacket.def(py::init<StepElement_Array1OfCurveElementEndReleasePacket &&>(), py::arg("theOther"));
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def(py::init<const opencascade::handle<StepElement_CurveElementEndReleasePacket> &, const Standard_Integer, const Standard_Integer>(), py::arg("theBegin"), py::arg("theLower"), py::arg("theUpper"));
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def("begin", (StepElement_Array1OfCurveElementEndReleasePacket::iterator (StepElement_Array1OfCurveElementEndReleasePacket::*)() const ) &StepElement_Array1OfCurveElementEndReleasePacket::begin, "Returns an iterator pointing to the first element in the array.");
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def("end", (StepElement_Array1OfCurveElementEndReleasePacket::iterator (StepElement_Array1OfCurveElementEndReleasePacket::*)() const ) &StepElement_Array1OfCurveElementEndReleasePacket::end, "Returns an iterator referring to the past-the-end element in the array.");
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def("cbegin", (StepElement_Array1OfCurveElementEndReleasePacket::const_iterator (StepElement_Array1OfCurveElementEndReleasePacket::*)() const ) &StepElement_Array1OfCurveElementEndReleasePacket::cbegin, "Returns a const iterator pointing to the first element in the array.");
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def("cend", (StepElement_Array1OfCurveElementEndReleasePacket::const_iterator (StepElement_Array1OfCurveElementEndReleasePacket::*)() const ) &StepElement_Array1OfCurveElementEndReleasePacket::cend, "Returns a const iterator referring to the past-the-end element in the array.");
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def("Init", (void (StepElement_Array1OfCurveElementEndReleasePacket::*)(const opencascade::handle<StepElement_CurveElementEndReleasePacket> &)) &StepElement_Array1OfCurveElementEndReleasePacket::Init, "Initialise the items with theValue", py::arg("theValue"));
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def("Size", (Standard_Integer (StepElement_Array1OfCurveElementEndReleasePacket::*)() const ) &StepElement_Array1OfCurveElementEndReleasePacket::Size, "Size query");
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def("Length", (Standard_Integer (StepElement_Array1OfCurveElementEndReleasePacket::*)() const ) &StepElement_Array1OfCurveElementEndReleasePacket::Length, "Length query (the same)");
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def("IsEmpty", (Standard_Boolean (StepElement_Array1OfCurveElementEndReleasePacket::*)() const ) &StepElement_Array1OfCurveElementEndReleasePacket::IsEmpty, "Return TRUE if array has zero length.");
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def("Lower", (Standard_Integer (StepElement_Array1OfCurveElementEndReleasePacket::*)() const ) &StepElement_Array1OfCurveElementEndReleasePacket::Lower, "Lower bound");
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def("Upper", (Standard_Integer (StepElement_Array1OfCurveElementEndReleasePacket::*)() const ) &StepElement_Array1OfCurveElementEndReleasePacket::Upper, "Upper bound");
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def("IsDeletable", (Standard_Boolean (StepElement_Array1OfCurveElementEndReleasePacket::*)() const ) &StepElement_Array1OfCurveElementEndReleasePacket::IsDeletable, "myDeletable flag");
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def("IsAllocated", (Standard_Boolean (StepElement_Array1OfCurveElementEndReleasePacket::*)() const ) &StepElement_Array1OfCurveElementEndReleasePacket::IsAllocated, "IsAllocated flag - for naming compatibility");
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def("Assign", (StepElement_Array1OfCurveElementEndReleasePacket & (StepElement_Array1OfCurveElementEndReleasePacket::*)(const StepElement_Array1OfCurveElementEndReleasePacket &)) &StepElement_Array1OfCurveElementEndReleasePacket::Assign, "Assignment", py::arg("theOther"));
	// FIXME cls_StepElement_Array1OfCurveElementEndReleasePacket.def("Move", (StepElement_Array1OfCurveElementEndReleasePacket & (StepElement_Array1OfCurveElementEndReleasePacket::*)(StepElement_Array1OfCurveElementEndReleasePacket &&)) &StepElement_Array1OfCurveElementEndReleasePacket::Move, "Move assignment", py::arg("theOther"));
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def("assign", (StepElement_Array1OfCurveElementEndReleasePacket & (StepElement_Array1OfCurveElementEndReleasePacket::*)(const StepElement_Array1OfCurveElementEndReleasePacket &)) &StepElement_Array1OfCurveElementEndReleasePacket::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	// FIXME cls_StepElement_Array1OfCurveElementEndReleasePacket.def("assign", (StepElement_Array1OfCurveElementEndReleasePacket & (StepElement_Array1OfCurveElementEndReleasePacket::*)(StepElement_Array1OfCurveElementEndReleasePacket &&)) &StepElement_Array1OfCurveElementEndReleasePacket::operator=, py::is_operator(), "Move assignment operator.", py::arg("theOther"));
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def("First", (const opencascade::handle<StepElement_CurveElementEndReleasePacket> & (StepElement_Array1OfCurveElementEndReleasePacket::*)() const ) &StepElement_Array1OfCurveElementEndReleasePacket::First, "Returns first element");
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def("ChangeFirst", (opencascade::handle<StepElement_CurveElementEndReleasePacket> & (StepElement_Array1OfCurveElementEndReleasePacket::*)()) &StepElement_Array1OfCurveElementEndReleasePacket::ChangeFirst, "Returns first element");
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def("Last", (const opencascade::handle<StepElement_CurveElementEndReleasePacket> & (StepElement_Array1OfCurveElementEndReleasePacket::*)() const ) &StepElement_Array1OfCurveElementEndReleasePacket::Last, "Returns last element");
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def("ChangeLast", (opencascade::handle<StepElement_CurveElementEndReleasePacket> & (StepElement_Array1OfCurveElementEndReleasePacket::*)()) &StepElement_Array1OfCurveElementEndReleasePacket::ChangeLast, "Returns last element");
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def("Value", (const opencascade::handle<StepElement_CurveElementEndReleasePacket> & (StepElement_Array1OfCurveElementEndReleasePacket::*)(const Standard_Integer) const ) &StepElement_Array1OfCurveElementEndReleasePacket::Value, "Constant value access", py::arg("theIndex"));
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def("__call__", (const opencascade::handle<StepElement_CurveElementEndReleasePacket> & (StepElement_Array1OfCurveElementEndReleasePacket::*)(const Standard_Integer) const ) &StepElement_Array1OfCurveElementEndReleasePacket::operator(), py::is_operator(), "operator() - alias to Value", py::arg("theIndex"));
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def("ChangeValue", (opencascade::handle<StepElement_CurveElementEndReleasePacket> & (StepElement_Array1OfCurveElementEndReleasePacket::*)(const Standard_Integer)) &StepElement_Array1OfCurveElementEndReleasePacket::ChangeValue, "Variable value access", py::arg("theIndex"));
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def("__call__", (opencascade::handle<StepElement_CurveElementEndReleasePacket> & (StepElement_Array1OfCurveElementEndReleasePacket::*)(const Standard_Integer)) &StepElement_Array1OfCurveElementEndReleasePacket::operator(), py::is_operator(), "operator() - alias to ChangeValue", py::arg("theIndex"));
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def("SetValue", (void (StepElement_Array1OfCurveElementEndReleasePacket::*)(const Standard_Integer, const opencascade::handle<StepElement_CurveElementEndReleasePacket> &)) &StepElement_Array1OfCurveElementEndReleasePacket::SetValue, "Set value", py::arg("theIndex"), py::arg("theItem"));
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def("Resize", (void (StepElement_Array1OfCurveElementEndReleasePacket::*)(const Standard_Integer, const Standard_Integer, const Standard_Boolean)) &StepElement_Array1OfCurveElementEndReleasePacket::Resize, "Resizes the array to specified bounds. No re-allocation will be done if length of array does not change, but existing values will not be discarded if theToCopyData set to FALSE.", py::arg("theLower"), py::arg("theUpper"), py::arg("theToCopyData"));
	cls_StepElement_Array1OfCurveElementEndReleasePacket.def("__iter__", [](const StepElement_Array1OfCurveElementEndReleasePacket &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_Array1.hxx
	py::class_<StepElement_Array1OfCurveElementSectionDefinition, std::unique_ptr<StepElement_Array1OfCurveElementSectionDefinition, Deleter<StepElement_Array1OfCurveElementSectionDefinition>>> cls_StepElement_Array1OfCurveElementSectionDefinition(mod, "StepElement_Array1OfCurveElementSectionDefinition", "Purpose: The class Array1 represents unidimensional arrays of fixed size known at run time. The range of the index is user defined. An array1 can be constructed with a 'C array'. This functionality is useful to call methods expecting an Array1. It allows to carry the bounds inside the arrays.");
	cls_StepElement_Array1OfCurveElementSectionDefinition.def(py::init<>());
	cls_StepElement_Array1OfCurveElementSectionDefinition.def(py::init<const Standard_Integer, const Standard_Integer>(), py::arg("theLower"), py::arg("theUpper"));
	cls_StepElement_Array1OfCurveElementSectionDefinition.def(py::init([] (const StepElement_Array1OfCurveElementSectionDefinition &other) {return new StepElement_Array1OfCurveElementSectionDefinition(other);}), "Copy constructor", py::arg("other"));
	// FIXME cls_StepElement_Array1OfCurveElementSectionDefinition.def(py::init<StepElement_Array1OfCurveElementSectionDefinition &&>(), py::arg("theOther"));
	cls_StepElement_Array1OfCurveElementSectionDefinition.def(py::init<const opencascade::handle<StepElement_CurveElementSectionDefinition> &, const Standard_Integer, const Standard_Integer>(), py::arg("theBegin"), py::arg("theLower"), py::arg("theUpper"));
	cls_StepElement_Array1OfCurveElementSectionDefinition.def("begin", (StepElement_Array1OfCurveElementSectionDefinition::iterator (StepElement_Array1OfCurveElementSectionDefinition::*)() const ) &StepElement_Array1OfCurveElementSectionDefinition::begin, "Returns an iterator pointing to the first element in the array.");
	cls_StepElement_Array1OfCurveElementSectionDefinition.def("end", (StepElement_Array1OfCurveElementSectionDefinition::iterator (StepElement_Array1OfCurveElementSectionDefinition::*)() const ) &StepElement_Array1OfCurveElementSectionDefinition::end, "Returns an iterator referring to the past-the-end element in the array.");
	cls_StepElement_Array1OfCurveElementSectionDefinition.def("cbegin", (StepElement_Array1OfCurveElementSectionDefinition::const_iterator (StepElement_Array1OfCurveElementSectionDefinition::*)() const ) &StepElement_Array1OfCurveElementSectionDefinition::cbegin, "Returns a const iterator pointing to the first element in the array.");
	cls_StepElement_Array1OfCurveElementSectionDefinition.def("cend", (StepElement_Array1OfCurveElementSectionDefinition::const_iterator (StepElement_Array1OfCurveElementSectionDefinition::*)() const ) &StepElement_Array1OfCurveElementSectionDefinition::cend, "Returns a const iterator referring to the past-the-end element in the array.");
	cls_StepElement_Array1OfCurveElementSectionDefinition.def("Init", (void (StepElement_Array1OfCurveElementSectionDefinition::*)(const opencascade::handle<StepElement_CurveElementSectionDefinition> &)) &StepElement_Array1OfCurveElementSectionDefinition::Init, "Initialise the items with theValue", py::arg("theValue"));
	cls_StepElement_Array1OfCurveElementSectionDefinition.def("Size", (Standard_Integer (StepElement_Array1OfCurveElementSectionDefinition::*)() const ) &StepElement_Array1OfCurveElementSectionDefinition::Size, "Size query");
	cls_StepElement_Array1OfCurveElementSectionDefinition.def("Length", (Standard_Integer (StepElement_Array1OfCurveElementSectionDefinition::*)() const ) &StepElement_Array1OfCurveElementSectionDefinition::Length, "Length query (the same)");
	cls_StepElement_Array1OfCurveElementSectionDefinition.def("IsEmpty", (Standard_Boolean (StepElement_Array1OfCurveElementSectionDefinition::*)() const ) &StepElement_Array1OfCurveElementSectionDefinition::IsEmpty, "Return TRUE if array has zero length.");
	cls_StepElement_Array1OfCurveElementSectionDefinition.def("Lower", (Standard_Integer (StepElement_Array1OfCurveElementSectionDefinition::*)() const ) &StepElement_Array1OfCurveElementSectionDefinition::Lower, "Lower bound");
	cls_StepElement_Array1OfCurveElementSectionDefinition.def("Upper", (Standard_Integer (StepElement_Array1OfCurveElementSectionDefinition::*)() const ) &StepElement_Array1OfCurveElementSectionDefinition::Upper, "Upper bound");
	cls_StepElement_Array1OfCurveElementSectionDefinition.def("IsDeletable", (Standard_Boolean (StepElement_Array1OfCurveElementSectionDefinition::*)() const ) &StepElement_Array1OfCurveElementSectionDefinition::IsDeletable, "myDeletable flag");
	cls_StepElement_Array1OfCurveElementSectionDefinition.def("IsAllocated", (Standard_Boolean (StepElement_Array1OfCurveElementSectionDefinition::*)() const ) &StepElement_Array1OfCurveElementSectionDefinition::IsAllocated, "IsAllocated flag - for naming compatibility");
	cls_StepElement_Array1OfCurveElementSectionDefinition.def("Assign", (StepElement_Array1OfCurveElementSectionDefinition & (StepElement_Array1OfCurveElementSectionDefinition::*)(const StepElement_Array1OfCurveElementSectionDefinition &)) &StepElement_Array1OfCurveElementSectionDefinition::Assign, "Assignment", py::arg("theOther"));
	// FIXME cls_StepElement_Array1OfCurveElementSectionDefinition.def("Move", (StepElement_Array1OfCurveElementSectionDefinition & (StepElement_Array1OfCurveElementSectionDefinition::*)(StepElement_Array1OfCurveElementSectionDefinition &&)) &StepElement_Array1OfCurveElementSectionDefinition::Move, "Move assignment", py::arg("theOther"));
	cls_StepElement_Array1OfCurveElementSectionDefinition.def("assign", (StepElement_Array1OfCurveElementSectionDefinition & (StepElement_Array1OfCurveElementSectionDefinition::*)(const StepElement_Array1OfCurveElementSectionDefinition &)) &StepElement_Array1OfCurveElementSectionDefinition::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	// FIXME cls_StepElement_Array1OfCurveElementSectionDefinition.def("assign", (StepElement_Array1OfCurveElementSectionDefinition & (StepElement_Array1OfCurveElementSectionDefinition::*)(StepElement_Array1OfCurveElementSectionDefinition &&)) &StepElement_Array1OfCurveElementSectionDefinition::operator=, py::is_operator(), "Move assignment operator.", py::arg("theOther"));
	cls_StepElement_Array1OfCurveElementSectionDefinition.def("First", (const opencascade::handle<StepElement_CurveElementSectionDefinition> & (StepElement_Array1OfCurveElementSectionDefinition::*)() const ) &StepElement_Array1OfCurveElementSectionDefinition::First, "Returns first element");
	cls_StepElement_Array1OfCurveElementSectionDefinition.def("ChangeFirst", (opencascade::handle<StepElement_CurveElementSectionDefinition> & (StepElement_Array1OfCurveElementSectionDefinition::*)()) &StepElement_Array1OfCurveElementSectionDefinition::ChangeFirst, "Returns first element");
	cls_StepElement_Array1OfCurveElementSectionDefinition.def("Last", (const opencascade::handle<StepElement_CurveElementSectionDefinition> & (StepElement_Array1OfCurveElementSectionDefinition::*)() const ) &StepElement_Array1OfCurveElementSectionDefinition::Last, "Returns last element");
	cls_StepElement_Array1OfCurveElementSectionDefinition.def("ChangeLast", (opencascade::handle<StepElement_CurveElementSectionDefinition> & (StepElement_Array1OfCurveElementSectionDefinition::*)()) &StepElement_Array1OfCurveElementSectionDefinition::ChangeLast, "Returns last element");
	cls_StepElement_Array1OfCurveElementSectionDefinition.def("Value", (const opencascade::handle<StepElement_CurveElementSectionDefinition> & (StepElement_Array1OfCurveElementSectionDefinition::*)(const Standard_Integer) const ) &StepElement_Array1OfCurveElementSectionDefinition::Value, "Constant value access", py::arg("theIndex"));
	cls_StepElement_Array1OfCurveElementSectionDefinition.def("__call__", (const opencascade::handle<StepElement_CurveElementSectionDefinition> & (StepElement_Array1OfCurveElementSectionDefinition::*)(const Standard_Integer) const ) &StepElement_Array1OfCurveElementSectionDefinition::operator(), py::is_operator(), "operator() - alias to Value", py::arg("theIndex"));
	cls_StepElement_Array1OfCurveElementSectionDefinition.def("ChangeValue", (opencascade::handle<StepElement_CurveElementSectionDefinition> & (StepElement_Array1OfCurveElementSectionDefinition::*)(const Standard_Integer)) &StepElement_Array1OfCurveElementSectionDefinition::ChangeValue, "Variable value access", py::arg("theIndex"));
	cls_StepElement_Array1OfCurveElementSectionDefinition.def("__call__", (opencascade::handle<StepElement_CurveElementSectionDefinition> & (StepElement_Array1OfCurveElementSectionDefinition::*)(const Standard_Integer)) &StepElement_Array1OfCurveElementSectionDefinition::operator(), py::is_operator(), "operator() - alias to ChangeValue", py::arg("theIndex"));
	cls_StepElement_Array1OfCurveElementSectionDefinition.def("SetValue", (void (StepElement_Array1OfCurveElementSectionDefinition::*)(const Standard_Integer, const opencascade::handle<StepElement_CurveElementSectionDefinition> &)) &StepElement_Array1OfCurveElementSectionDefinition::SetValue, "Set value", py::arg("theIndex"), py::arg("theItem"));
	cls_StepElement_Array1OfCurveElementSectionDefinition.def("Resize", (void (StepElement_Array1OfCurveElementSectionDefinition::*)(const Standard_Integer, const Standard_Integer, const Standard_Boolean)) &StepElement_Array1OfCurveElementSectionDefinition::Resize, "Resizes the array to specified bounds. No re-allocation will be done if length of array does not change, but existing values will not be discarded if theToCopyData set to FALSE.", py::arg("theLower"), py::arg("theUpper"), py::arg("theToCopyData"));
	cls_StepElement_Array1OfCurveElementSectionDefinition.def("__iter__", [](const StepElement_Array1OfCurveElementSectionDefinition &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_Array1.hxx
	py::class_<StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember, std::unique_ptr<StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember, Deleter<StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember>>> cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember(mod, "StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember", "Purpose: The class Array1 represents unidimensional arrays of fixed size known at run time. The range of the index is user defined. An array1 can be constructed with a 'C array'. This functionality is useful to call methods expecting an Array1. It allows to carry the bounds inside the arrays.");
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def(py::init<>());
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def(py::init<const Standard_Integer, const Standard_Integer>(), py::arg("theLower"), py::arg("theUpper"));
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def(py::init([] (const StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember &other) {return new StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember(other);}), "Copy constructor", py::arg("other"));
	// FIXME cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def(py::init<StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember &&>(), py::arg("theOther"));
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def(py::init<const opencascade::handle<StepElement_HSequenceOfSurfaceElementPurposeMember> &, const Standard_Integer, const Standard_Integer>(), py::arg("theBegin"), py::arg("theLower"), py::arg("theUpper"));
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("begin", (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::iterator (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::begin, "Returns an iterator pointing to the first element in the array.");
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("end", (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::iterator (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::end, "Returns an iterator referring to the past-the-end element in the array.");
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("cbegin", (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::const_iterator (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::cbegin, "Returns a const iterator pointing to the first element in the array.");
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("cend", (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::const_iterator (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::cend, "Returns a const iterator referring to the past-the-end element in the array.");
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("Init", (void (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)(const opencascade::handle<StepElement_HSequenceOfSurfaceElementPurposeMember> &)) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::Init, "Initialise the items with theValue", py::arg("theValue"));
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("Size", (Standard_Integer (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::Size, "Size query");
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("Length", (Standard_Integer (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::Length, "Length query (the same)");
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("IsEmpty", (Standard_Boolean (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::IsEmpty, "Return TRUE if array has zero length.");
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("Lower", (Standard_Integer (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::Lower, "Lower bound");
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("Upper", (Standard_Integer (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::Upper, "Upper bound");
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("IsDeletable", (Standard_Boolean (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::IsDeletable, "myDeletable flag");
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("IsAllocated", (Standard_Boolean (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::IsAllocated, "IsAllocated flag - for naming compatibility");
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("Assign", (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember & (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)(const StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember &)) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::Assign, "Assignment", py::arg("theOther"));
	// FIXME cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("Move", (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember & (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)(StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember &&)) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::Move, "Move assignment", py::arg("theOther"));
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("assign", (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember & (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)(const StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember &)) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	// FIXME cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("assign", (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember & (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)(StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember &&)) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::operator=, py::is_operator(), "Move assignment operator.", py::arg("theOther"));
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("First", (const opencascade::handle<StepElement_HSequenceOfSurfaceElementPurposeMember> & (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::First, "Returns first element");
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("ChangeFirst", (opencascade::handle<StepElement_HSequenceOfSurfaceElementPurposeMember> & (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)()) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::ChangeFirst, "Returns first element");
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("Last", (const opencascade::handle<StepElement_HSequenceOfSurfaceElementPurposeMember> & (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::Last, "Returns last element");
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("ChangeLast", (opencascade::handle<StepElement_HSequenceOfSurfaceElementPurposeMember> & (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)()) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::ChangeLast, "Returns last element");
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("Value", (const opencascade::handle<StepElement_HSequenceOfSurfaceElementPurposeMember> & (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)(const Standard_Integer) const ) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::Value, "Constant value access", py::arg("theIndex"));
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("__call__", (const opencascade::handle<StepElement_HSequenceOfSurfaceElementPurposeMember> & (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)(const Standard_Integer) const ) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::operator(), py::is_operator(), "operator() - alias to Value", py::arg("theIndex"));
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("ChangeValue", (opencascade::handle<StepElement_HSequenceOfSurfaceElementPurposeMember> & (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)(const Standard_Integer)) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::ChangeValue, "Variable value access", py::arg("theIndex"));
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("__call__", (opencascade::handle<StepElement_HSequenceOfSurfaceElementPurposeMember> & (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)(const Standard_Integer)) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::operator(), py::is_operator(), "operator() - alias to ChangeValue", py::arg("theIndex"));
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("SetValue", (void (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)(const Standard_Integer, const opencascade::handle<StepElement_HSequenceOfSurfaceElementPurposeMember> &)) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::SetValue, "Set value", py::arg("theIndex"), py::arg("theItem"));
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("Resize", (void (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::*)(const Standard_Integer, const Standard_Integer, const Standard_Boolean)) &StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::Resize, "Resizes the array to specified bounds. No re-allocation will be done if length of array does not change, but existing values will not be discarded if theToCopyData set to FALSE.", py::arg("theLower"), py::arg("theUpper"), py::arg("theToCopyData"));
	cls_StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember.def("__iter__", [](const StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_Array1.hxx
	py::class_<StepElement_Array1OfSurfaceSection, std::unique_ptr<StepElement_Array1OfSurfaceSection, Deleter<StepElement_Array1OfSurfaceSection>>> cls_StepElement_Array1OfSurfaceSection(mod, "StepElement_Array1OfSurfaceSection", "Purpose: The class Array1 represents unidimensional arrays of fixed size known at run time. The range of the index is user defined. An array1 can be constructed with a 'C array'. This functionality is useful to call methods expecting an Array1. It allows to carry the bounds inside the arrays.");
	cls_StepElement_Array1OfSurfaceSection.def(py::init<>());
	cls_StepElement_Array1OfSurfaceSection.def(py::init<const Standard_Integer, const Standard_Integer>(), py::arg("theLower"), py::arg("theUpper"));
	cls_StepElement_Array1OfSurfaceSection.def(py::init([] (const StepElement_Array1OfSurfaceSection &other) {return new StepElement_Array1OfSurfaceSection(other);}), "Copy constructor", py::arg("other"));
	// FIXME cls_StepElement_Array1OfSurfaceSection.def(py::init<StepElement_Array1OfSurfaceSection &&>(), py::arg("theOther"));
	cls_StepElement_Array1OfSurfaceSection.def(py::init<const opencascade::handle<StepElement_SurfaceSection> &, const Standard_Integer, const Standard_Integer>(), py::arg("theBegin"), py::arg("theLower"), py::arg("theUpper"));
	cls_StepElement_Array1OfSurfaceSection.def("begin", (StepElement_Array1OfSurfaceSection::iterator (StepElement_Array1OfSurfaceSection::*)() const ) &StepElement_Array1OfSurfaceSection::begin, "Returns an iterator pointing to the first element in the array.");
	cls_StepElement_Array1OfSurfaceSection.def("end", (StepElement_Array1OfSurfaceSection::iterator (StepElement_Array1OfSurfaceSection::*)() const ) &StepElement_Array1OfSurfaceSection::end, "Returns an iterator referring to the past-the-end element in the array.");
	cls_StepElement_Array1OfSurfaceSection.def("cbegin", (StepElement_Array1OfSurfaceSection::const_iterator (StepElement_Array1OfSurfaceSection::*)() const ) &StepElement_Array1OfSurfaceSection::cbegin, "Returns a const iterator pointing to the first element in the array.");
	cls_StepElement_Array1OfSurfaceSection.def("cend", (StepElement_Array1OfSurfaceSection::const_iterator (StepElement_Array1OfSurfaceSection::*)() const ) &StepElement_Array1OfSurfaceSection::cend, "Returns a const iterator referring to the past-the-end element in the array.");
	cls_StepElement_Array1OfSurfaceSection.def("Init", (void (StepElement_Array1OfSurfaceSection::*)(const opencascade::handle<StepElement_SurfaceSection> &)) &StepElement_Array1OfSurfaceSection::Init, "Initialise the items with theValue", py::arg("theValue"));
	cls_StepElement_Array1OfSurfaceSection.def("Size", (Standard_Integer (StepElement_Array1OfSurfaceSection::*)() const ) &StepElement_Array1OfSurfaceSection::Size, "Size query");
	cls_StepElement_Array1OfSurfaceSection.def("Length", (Standard_Integer (StepElement_Array1OfSurfaceSection::*)() const ) &StepElement_Array1OfSurfaceSection::Length, "Length query (the same)");
	cls_StepElement_Array1OfSurfaceSection.def("IsEmpty", (Standard_Boolean (StepElement_Array1OfSurfaceSection::*)() const ) &StepElement_Array1OfSurfaceSection::IsEmpty, "Return TRUE if array has zero length.");
	cls_StepElement_Array1OfSurfaceSection.def("Lower", (Standard_Integer (StepElement_Array1OfSurfaceSection::*)() const ) &StepElement_Array1OfSurfaceSection::Lower, "Lower bound");
	cls_StepElement_Array1OfSurfaceSection.def("Upper", (Standard_Integer (StepElement_Array1OfSurfaceSection::*)() const ) &StepElement_Array1OfSurfaceSection::Upper, "Upper bound");
	cls_StepElement_Array1OfSurfaceSection.def("IsDeletable", (Standard_Boolean (StepElement_Array1OfSurfaceSection::*)() const ) &StepElement_Array1OfSurfaceSection::IsDeletable, "myDeletable flag");
	cls_StepElement_Array1OfSurfaceSection.def("IsAllocated", (Standard_Boolean (StepElement_Array1OfSurfaceSection::*)() const ) &StepElement_Array1OfSurfaceSection::IsAllocated, "IsAllocated flag - for naming compatibility");
	cls_StepElement_Array1OfSurfaceSection.def("Assign", (StepElement_Array1OfSurfaceSection & (StepElement_Array1OfSurfaceSection::*)(const StepElement_Array1OfSurfaceSection &)) &StepElement_Array1OfSurfaceSection::Assign, "Assignment", py::arg("theOther"));
	// FIXME cls_StepElement_Array1OfSurfaceSection.def("Move", (StepElement_Array1OfSurfaceSection & (StepElement_Array1OfSurfaceSection::*)(StepElement_Array1OfSurfaceSection &&)) &StepElement_Array1OfSurfaceSection::Move, "Move assignment", py::arg("theOther"));
	cls_StepElement_Array1OfSurfaceSection.def("assign", (StepElement_Array1OfSurfaceSection & (StepElement_Array1OfSurfaceSection::*)(const StepElement_Array1OfSurfaceSection &)) &StepElement_Array1OfSurfaceSection::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	// FIXME cls_StepElement_Array1OfSurfaceSection.def("assign", (StepElement_Array1OfSurfaceSection & (StepElement_Array1OfSurfaceSection::*)(StepElement_Array1OfSurfaceSection &&)) &StepElement_Array1OfSurfaceSection::operator=, py::is_operator(), "Move assignment operator.", py::arg("theOther"));
	cls_StepElement_Array1OfSurfaceSection.def("First", (const opencascade::handle<StepElement_SurfaceSection> & (StepElement_Array1OfSurfaceSection::*)() const ) &StepElement_Array1OfSurfaceSection::First, "Returns first element");
	cls_StepElement_Array1OfSurfaceSection.def("ChangeFirst", (opencascade::handle<StepElement_SurfaceSection> & (StepElement_Array1OfSurfaceSection::*)()) &StepElement_Array1OfSurfaceSection::ChangeFirst, "Returns first element");
	cls_StepElement_Array1OfSurfaceSection.def("Last", (const opencascade::handle<StepElement_SurfaceSection> & (StepElement_Array1OfSurfaceSection::*)() const ) &StepElement_Array1OfSurfaceSection::Last, "Returns last element");
	cls_StepElement_Array1OfSurfaceSection.def("ChangeLast", (opencascade::handle<StepElement_SurfaceSection> & (StepElement_Array1OfSurfaceSection::*)()) &StepElement_Array1OfSurfaceSection::ChangeLast, "Returns last element");
	cls_StepElement_Array1OfSurfaceSection.def("Value", (const opencascade::handle<StepElement_SurfaceSection> & (StepElement_Array1OfSurfaceSection::*)(const Standard_Integer) const ) &StepElement_Array1OfSurfaceSection::Value, "Constant value access", py::arg("theIndex"));
	cls_StepElement_Array1OfSurfaceSection.def("__call__", (const opencascade::handle<StepElement_SurfaceSection> & (StepElement_Array1OfSurfaceSection::*)(const Standard_Integer) const ) &StepElement_Array1OfSurfaceSection::operator(), py::is_operator(), "operator() - alias to Value", py::arg("theIndex"));
	cls_StepElement_Array1OfSurfaceSection.def("ChangeValue", (opencascade::handle<StepElement_SurfaceSection> & (StepElement_Array1OfSurfaceSection::*)(const Standard_Integer)) &StepElement_Array1OfSurfaceSection::ChangeValue, "Variable value access", py::arg("theIndex"));
	cls_StepElement_Array1OfSurfaceSection.def("__call__", (opencascade::handle<StepElement_SurfaceSection> & (StepElement_Array1OfSurfaceSection::*)(const Standard_Integer)) &StepElement_Array1OfSurfaceSection::operator(), py::is_operator(), "operator() - alias to ChangeValue", py::arg("theIndex"));
	cls_StepElement_Array1OfSurfaceSection.def("SetValue", (void (StepElement_Array1OfSurfaceSection::*)(const Standard_Integer, const opencascade::handle<StepElement_SurfaceSection> &)) &StepElement_Array1OfSurfaceSection::SetValue, "Set value", py::arg("theIndex"), py::arg("theItem"));
	cls_StepElement_Array1OfSurfaceSection.def("Resize", (void (StepElement_Array1OfSurfaceSection::*)(const Standard_Integer, const Standard_Integer, const Standard_Boolean)) &StepElement_Array1OfSurfaceSection::Resize, "Resizes the array to specified bounds. No re-allocation will be done if length of array does not change, but existing values will not be discarded if theToCopyData set to FALSE.", py::arg("theLower"), py::arg("theUpper"), py::arg("theToCopyData"));
	cls_StepElement_Array1OfSurfaceSection.def("__iter__", [](const StepElement_Array1OfSurfaceSection &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_Array1.hxx
	py::class_<StepElement_Array1OfVolumeElementPurpose, std::unique_ptr<StepElement_Array1OfVolumeElementPurpose, Deleter<StepElement_Array1OfVolumeElementPurpose>>> cls_StepElement_Array1OfVolumeElementPurpose(mod, "StepElement_Array1OfVolumeElementPurpose", "Purpose: The class Array1 represents unidimensional arrays of fixed size known at run time. The range of the index is user defined. An array1 can be constructed with a 'C array'. This functionality is useful to call methods expecting an Array1. It allows to carry the bounds inside the arrays.");
	cls_StepElement_Array1OfVolumeElementPurpose.def(py::init<>());
	cls_StepElement_Array1OfVolumeElementPurpose.def(py::init<const Standard_Integer, const Standard_Integer>(), py::arg("theLower"), py::arg("theUpper"));
	cls_StepElement_Array1OfVolumeElementPurpose.def(py::init([] (const StepElement_Array1OfVolumeElementPurpose &other) {return new StepElement_Array1OfVolumeElementPurpose(other);}), "Copy constructor", py::arg("other"));
	// FIXME cls_StepElement_Array1OfVolumeElementPurpose.def(py::init<StepElement_Array1OfVolumeElementPurpose &&>(), py::arg("theOther"));
	cls_StepElement_Array1OfVolumeElementPurpose.def(py::init<const StepElement_VolumeElementPurpose &, const Standard_Integer, const Standard_Integer>(), py::arg("theBegin"), py::arg("theLower"), py::arg("theUpper"));
	cls_StepElement_Array1OfVolumeElementPurpose.def("begin", (StepElement_Array1OfVolumeElementPurpose::iterator (StepElement_Array1OfVolumeElementPurpose::*)() const ) &StepElement_Array1OfVolumeElementPurpose::begin, "Returns an iterator pointing to the first element in the array.");
	cls_StepElement_Array1OfVolumeElementPurpose.def("end", (StepElement_Array1OfVolumeElementPurpose::iterator (StepElement_Array1OfVolumeElementPurpose::*)() const ) &StepElement_Array1OfVolumeElementPurpose::end, "Returns an iterator referring to the past-the-end element in the array.");
	cls_StepElement_Array1OfVolumeElementPurpose.def("cbegin", (StepElement_Array1OfVolumeElementPurpose::const_iterator (StepElement_Array1OfVolumeElementPurpose::*)() const ) &StepElement_Array1OfVolumeElementPurpose::cbegin, "Returns a const iterator pointing to the first element in the array.");
	cls_StepElement_Array1OfVolumeElementPurpose.def("cend", (StepElement_Array1OfVolumeElementPurpose::const_iterator (StepElement_Array1OfVolumeElementPurpose::*)() const ) &StepElement_Array1OfVolumeElementPurpose::cend, "Returns a const iterator referring to the past-the-end element in the array.");
	cls_StepElement_Array1OfVolumeElementPurpose.def("Init", (void (StepElement_Array1OfVolumeElementPurpose::*)(const StepElement_VolumeElementPurpose &)) &StepElement_Array1OfVolumeElementPurpose::Init, "Initialise the items with theValue", py::arg("theValue"));
	cls_StepElement_Array1OfVolumeElementPurpose.def("Size", (Standard_Integer (StepElement_Array1OfVolumeElementPurpose::*)() const ) &StepElement_Array1OfVolumeElementPurpose::Size, "Size query");
	cls_StepElement_Array1OfVolumeElementPurpose.def("Length", (Standard_Integer (StepElement_Array1OfVolumeElementPurpose::*)() const ) &StepElement_Array1OfVolumeElementPurpose::Length, "Length query (the same)");
	cls_StepElement_Array1OfVolumeElementPurpose.def("IsEmpty", (Standard_Boolean (StepElement_Array1OfVolumeElementPurpose::*)() const ) &StepElement_Array1OfVolumeElementPurpose::IsEmpty, "Return TRUE if array has zero length.");
	cls_StepElement_Array1OfVolumeElementPurpose.def("Lower", (Standard_Integer (StepElement_Array1OfVolumeElementPurpose::*)() const ) &StepElement_Array1OfVolumeElementPurpose::Lower, "Lower bound");
	cls_StepElement_Array1OfVolumeElementPurpose.def("Upper", (Standard_Integer (StepElement_Array1OfVolumeElementPurpose::*)() const ) &StepElement_Array1OfVolumeElementPurpose::Upper, "Upper bound");
	cls_StepElement_Array1OfVolumeElementPurpose.def("IsDeletable", (Standard_Boolean (StepElement_Array1OfVolumeElementPurpose::*)() const ) &StepElement_Array1OfVolumeElementPurpose::IsDeletable, "myDeletable flag");
	cls_StepElement_Array1OfVolumeElementPurpose.def("IsAllocated", (Standard_Boolean (StepElement_Array1OfVolumeElementPurpose::*)() const ) &StepElement_Array1OfVolumeElementPurpose::IsAllocated, "IsAllocated flag - for naming compatibility");
	cls_StepElement_Array1OfVolumeElementPurpose.def("Assign", (StepElement_Array1OfVolumeElementPurpose & (StepElement_Array1OfVolumeElementPurpose::*)(const StepElement_Array1OfVolumeElementPurpose &)) &StepElement_Array1OfVolumeElementPurpose::Assign, "Assignment", py::arg("theOther"));
	// FIXME cls_StepElement_Array1OfVolumeElementPurpose.def("Move", (StepElement_Array1OfVolumeElementPurpose & (StepElement_Array1OfVolumeElementPurpose::*)(StepElement_Array1OfVolumeElementPurpose &&)) &StepElement_Array1OfVolumeElementPurpose::Move, "Move assignment", py::arg("theOther"));
	cls_StepElement_Array1OfVolumeElementPurpose.def("assign", (StepElement_Array1OfVolumeElementPurpose & (StepElement_Array1OfVolumeElementPurpose::*)(const StepElement_Array1OfVolumeElementPurpose &)) &StepElement_Array1OfVolumeElementPurpose::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	// FIXME cls_StepElement_Array1OfVolumeElementPurpose.def("assign", (StepElement_Array1OfVolumeElementPurpose & (StepElement_Array1OfVolumeElementPurpose::*)(StepElement_Array1OfVolumeElementPurpose &&)) &StepElement_Array1OfVolumeElementPurpose::operator=, py::is_operator(), "Move assignment operator.", py::arg("theOther"));
	cls_StepElement_Array1OfVolumeElementPurpose.def("First", (const StepElement_VolumeElementPurpose & (StepElement_Array1OfVolumeElementPurpose::*)() const ) &StepElement_Array1OfVolumeElementPurpose::First, "Returns first element");
	cls_StepElement_Array1OfVolumeElementPurpose.def("ChangeFirst", (StepElement_VolumeElementPurpose & (StepElement_Array1OfVolumeElementPurpose::*)()) &StepElement_Array1OfVolumeElementPurpose::ChangeFirst, "Returns first element");
	cls_StepElement_Array1OfVolumeElementPurpose.def("Last", (const StepElement_VolumeElementPurpose & (StepElement_Array1OfVolumeElementPurpose::*)() const ) &StepElement_Array1OfVolumeElementPurpose::Last, "Returns last element");
	cls_StepElement_Array1OfVolumeElementPurpose.def("ChangeLast", (StepElement_VolumeElementPurpose & (StepElement_Array1OfVolumeElementPurpose::*)()) &StepElement_Array1OfVolumeElementPurpose::ChangeLast, "Returns last element");
	cls_StepElement_Array1OfVolumeElementPurpose.def("Value", (const StepElement_VolumeElementPurpose & (StepElement_Array1OfVolumeElementPurpose::*)(const Standard_Integer) const ) &StepElement_Array1OfVolumeElementPurpose::Value, "Constant value access", py::arg("theIndex"));
	cls_StepElement_Array1OfVolumeElementPurpose.def("__call__", (const StepElement_VolumeElementPurpose & (StepElement_Array1OfVolumeElementPurpose::*)(const Standard_Integer) const ) &StepElement_Array1OfVolumeElementPurpose::operator(), py::is_operator(), "operator() - alias to Value", py::arg("theIndex"));
	cls_StepElement_Array1OfVolumeElementPurpose.def("ChangeValue", (StepElement_VolumeElementPurpose & (StepElement_Array1OfVolumeElementPurpose::*)(const Standard_Integer)) &StepElement_Array1OfVolumeElementPurpose::ChangeValue, "Variable value access", py::arg("theIndex"));
	cls_StepElement_Array1OfVolumeElementPurpose.def("__call__", (StepElement_VolumeElementPurpose & (StepElement_Array1OfVolumeElementPurpose::*)(const Standard_Integer)) &StepElement_Array1OfVolumeElementPurpose::operator(), py::is_operator(), "operator() - alias to ChangeValue", py::arg("theIndex"));
	cls_StepElement_Array1OfVolumeElementPurpose.def("SetValue", (void (StepElement_Array1OfVolumeElementPurpose::*)(const Standard_Integer, const StepElement_VolumeElementPurpose &)) &StepElement_Array1OfVolumeElementPurpose::SetValue, "Set value", py::arg("theIndex"), py::arg("theItem"));
	cls_StepElement_Array1OfVolumeElementPurpose.def("Resize", (void (StepElement_Array1OfVolumeElementPurpose::*)(const Standard_Integer, const Standard_Integer, const Standard_Boolean)) &StepElement_Array1OfVolumeElementPurpose::Resize, "Resizes the array to specified bounds. No re-allocation will be done if length of array does not change, but existing values will not be discarded if theToCopyData set to FALSE.", py::arg("theLower"), py::arg("theUpper"), py::arg("theToCopyData"));
	cls_StepElement_Array1OfVolumeElementPurpose.def("__iter__", [](const StepElement_Array1OfVolumeElementPurpose &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_Array1.hxx
	py::class_<StepElement_Array1OfVolumeElementPurposeMember, std::unique_ptr<StepElement_Array1OfVolumeElementPurposeMember, Deleter<StepElement_Array1OfVolumeElementPurposeMember>>> cls_StepElement_Array1OfVolumeElementPurposeMember(mod, "StepElement_Array1OfVolumeElementPurposeMember", "Purpose: The class Array1 represents unidimensional arrays of fixed size known at run time. The range of the index is user defined. An array1 can be constructed with a 'C array'. This functionality is useful to call methods expecting an Array1. It allows to carry the bounds inside the arrays.");
	cls_StepElement_Array1OfVolumeElementPurposeMember.def(py::init<>());
	cls_StepElement_Array1OfVolumeElementPurposeMember.def(py::init<const Standard_Integer, const Standard_Integer>(), py::arg("theLower"), py::arg("theUpper"));
	cls_StepElement_Array1OfVolumeElementPurposeMember.def(py::init([] (const StepElement_Array1OfVolumeElementPurposeMember &other) {return new StepElement_Array1OfVolumeElementPurposeMember(other);}), "Copy constructor", py::arg("other"));
	// FIXME cls_StepElement_Array1OfVolumeElementPurposeMember.def(py::init<StepElement_Array1OfVolumeElementPurposeMember &&>(), py::arg("theOther"));
	cls_StepElement_Array1OfVolumeElementPurposeMember.def(py::init<const opencascade::handle<StepElement_VolumeElementPurposeMember> &, const Standard_Integer, const Standard_Integer>(), py::arg("theBegin"), py::arg("theLower"), py::arg("theUpper"));
	cls_StepElement_Array1OfVolumeElementPurposeMember.def("begin", (StepElement_Array1OfVolumeElementPurposeMember::iterator (StepElement_Array1OfVolumeElementPurposeMember::*)() const ) &StepElement_Array1OfVolumeElementPurposeMember::begin, "Returns an iterator pointing to the first element in the array.");
	cls_StepElement_Array1OfVolumeElementPurposeMember.def("end", (StepElement_Array1OfVolumeElementPurposeMember::iterator (StepElement_Array1OfVolumeElementPurposeMember::*)() const ) &StepElement_Array1OfVolumeElementPurposeMember::end, "Returns an iterator referring to the past-the-end element in the array.");
	cls_StepElement_Array1OfVolumeElementPurposeMember.def("cbegin", (StepElement_Array1OfVolumeElementPurposeMember::const_iterator (StepElement_Array1OfVolumeElementPurposeMember::*)() const ) &StepElement_Array1OfVolumeElementPurposeMember::cbegin, "Returns a const iterator pointing to the first element in the array.");
	cls_StepElement_Array1OfVolumeElementPurposeMember.def("cend", (StepElement_Array1OfVolumeElementPurposeMember::const_iterator (StepElement_Array1OfVolumeElementPurposeMember::*)() const ) &StepElement_Array1OfVolumeElementPurposeMember::cend, "Returns a const iterator referring to the past-the-end element in the array.");
	cls_StepElement_Array1OfVolumeElementPurposeMember.def("Init", (void (StepElement_Array1OfVolumeElementPurposeMember::*)(const opencascade::handle<StepElement_VolumeElementPurposeMember> &)) &StepElement_Array1OfVolumeElementPurposeMember::Init, "Initialise the items with theValue", py::arg("theValue"));
	cls_StepElement_Array1OfVolumeElementPurposeMember.def("Size", (Standard_Integer (StepElement_Array1OfVolumeElementPurposeMember::*)() const ) &StepElement_Array1OfVolumeElementPurposeMember::Size, "Size query");
	cls_StepElement_Array1OfVolumeElementPurposeMember.def("Length", (Standard_Integer (StepElement_Array1OfVolumeElementPurposeMember::*)() const ) &StepElement_Array1OfVolumeElementPurposeMember::Length, "Length query (the same)");
	cls_StepElement_Array1OfVolumeElementPurposeMember.def("IsEmpty", (Standard_Boolean (StepElement_Array1OfVolumeElementPurposeMember::*)() const ) &StepElement_Array1OfVolumeElementPurposeMember::IsEmpty, "Return TRUE if array has zero length.");
	cls_StepElement_Array1OfVolumeElementPurposeMember.def("Lower", (Standard_Integer (StepElement_Array1OfVolumeElementPurposeMember::*)() const ) &StepElement_Array1OfVolumeElementPurposeMember::Lower, "Lower bound");
	cls_StepElement_Array1OfVolumeElementPurposeMember.def("Upper", (Standard_Integer (StepElement_Array1OfVolumeElementPurposeMember::*)() const ) &StepElement_Array1OfVolumeElementPurposeMember::Upper, "Upper bound");
	cls_StepElement_Array1OfVolumeElementPurposeMember.def("IsDeletable", (Standard_Boolean (StepElement_Array1OfVolumeElementPurposeMember::*)() const ) &StepElement_Array1OfVolumeElementPurposeMember::IsDeletable, "myDeletable flag");
	cls_StepElement_Array1OfVolumeElementPurposeMember.def("IsAllocated", (Standard_Boolean (StepElement_Array1OfVolumeElementPurposeMember::*)() const ) &StepElement_Array1OfVolumeElementPurposeMember::IsAllocated, "IsAllocated flag - for naming compatibility");
	cls_StepElement_Array1OfVolumeElementPurposeMember.def("Assign", (StepElement_Array1OfVolumeElementPurposeMember & (StepElement_Array1OfVolumeElementPurposeMember::*)(const StepElement_Array1OfVolumeElementPurposeMember &)) &StepElement_Array1OfVolumeElementPurposeMember::Assign, "Assignment", py::arg("theOther"));
	// FIXME cls_StepElement_Array1OfVolumeElementPurposeMember.def("Move", (StepElement_Array1OfVolumeElementPurposeMember & (StepElement_Array1OfVolumeElementPurposeMember::*)(StepElement_Array1OfVolumeElementPurposeMember &&)) &StepElement_Array1OfVolumeElementPurposeMember::Move, "Move assignment", py::arg("theOther"));
	cls_StepElement_Array1OfVolumeElementPurposeMember.def("assign", (StepElement_Array1OfVolumeElementPurposeMember & (StepElement_Array1OfVolumeElementPurposeMember::*)(const StepElement_Array1OfVolumeElementPurposeMember &)) &StepElement_Array1OfVolumeElementPurposeMember::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	// FIXME cls_StepElement_Array1OfVolumeElementPurposeMember.def("assign", (StepElement_Array1OfVolumeElementPurposeMember & (StepElement_Array1OfVolumeElementPurposeMember::*)(StepElement_Array1OfVolumeElementPurposeMember &&)) &StepElement_Array1OfVolumeElementPurposeMember::operator=, py::is_operator(), "Move assignment operator.", py::arg("theOther"));
	cls_StepElement_Array1OfVolumeElementPurposeMember.def("First", (const opencascade::handle<StepElement_VolumeElementPurposeMember> & (StepElement_Array1OfVolumeElementPurposeMember::*)() const ) &StepElement_Array1OfVolumeElementPurposeMember::First, "Returns first element");
	cls_StepElement_Array1OfVolumeElementPurposeMember.def("ChangeFirst", (opencascade::handle<StepElement_VolumeElementPurposeMember> & (StepElement_Array1OfVolumeElementPurposeMember::*)()) &StepElement_Array1OfVolumeElementPurposeMember::ChangeFirst, "Returns first element");
	cls_StepElement_Array1OfVolumeElementPurposeMember.def("Last", (const opencascade::handle<StepElement_VolumeElementPurposeMember> & (StepElement_Array1OfVolumeElementPurposeMember::*)() const ) &StepElement_Array1OfVolumeElementPurposeMember::Last, "Returns last element");
	cls_StepElement_Array1OfVolumeElementPurposeMember.def("ChangeLast", (opencascade::handle<StepElement_VolumeElementPurposeMember> & (StepElement_Array1OfVolumeElementPurposeMember::*)()) &StepElement_Array1OfVolumeElementPurposeMember::ChangeLast, "Returns last element");
	cls_StepElement_Array1OfVolumeElementPurposeMember.def("Value", (const opencascade::handle<StepElement_VolumeElementPurposeMember> & (StepElement_Array1OfVolumeElementPurposeMember::*)(const Standard_Integer) const ) &StepElement_Array1OfVolumeElementPurposeMember::Value, "Constant value access", py::arg("theIndex"));
	cls_StepElement_Array1OfVolumeElementPurposeMember.def("__call__", (const opencascade::handle<StepElement_VolumeElementPurposeMember> & (StepElement_Array1OfVolumeElementPurposeMember::*)(const Standard_Integer) const ) &StepElement_Array1OfVolumeElementPurposeMember::operator(), py::is_operator(), "operator() - alias to Value", py::arg("theIndex"));
	cls_StepElement_Array1OfVolumeElementPurposeMember.def("ChangeValue", (opencascade::handle<StepElement_VolumeElementPurposeMember> & (StepElement_Array1OfVolumeElementPurposeMember::*)(const Standard_Integer)) &StepElement_Array1OfVolumeElementPurposeMember::ChangeValue, "Variable value access", py::arg("theIndex"));
	cls_StepElement_Array1OfVolumeElementPurposeMember.def("__call__", (opencascade::handle<StepElement_VolumeElementPurposeMember> & (StepElement_Array1OfVolumeElementPurposeMember::*)(const Standard_Integer)) &StepElement_Array1OfVolumeElementPurposeMember::operator(), py::is_operator(), "operator() - alias to ChangeValue", py::arg("theIndex"));
	cls_StepElement_Array1OfVolumeElementPurposeMember.def("SetValue", (void (StepElement_Array1OfVolumeElementPurposeMember::*)(const Standard_Integer, const opencascade::handle<StepElement_VolumeElementPurposeMember> &)) &StepElement_Array1OfVolumeElementPurposeMember::SetValue, "Set value", py::arg("theIndex"), py::arg("theItem"));
	cls_StepElement_Array1OfVolumeElementPurposeMember.def("Resize", (void (StepElement_Array1OfVolumeElementPurposeMember::*)(const Standard_Integer, const Standard_Integer, const Standard_Boolean)) &StepElement_Array1OfVolumeElementPurposeMember::Resize, "Resizes the array to specified bounds. No re-allocation will be done if length of array does not change, but existing values will not be discarded if theToCopyData set to FALSE.", py::arg("theLower"), py::arg("theUpper"), py::arg("theToCopyData"));
	cls_StepElement_Array1OfVolumeElementPurposeMember.def("__iter__", [](const StepElement_Array1OfVolumeElementPurposeMember &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_Array2.hxx
	py::class_<StepElement_Array2OfCurveElementPurposeMember, std::unique_ptr<StepElement_Array2OfCurveElementPurposeMember, Deleter<StepElement_Array2OfCurveElementPurposeMember>>> cls_StepElement_Array2OfCurveElementPurposeMember(mod, "StepElement_Array2OfCurveElementPurposeMember", "Purpose: The class Array2 represents bi-dimensional arrays of fixed size known at run time. The ranges of indices are user defined.");
	cls_StepElement_Array2OfCurveElementPurposeMember.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer>(), py::arg("theRowLower"), py::arg("theRowUpper"), py::arg("theColLower"), py::arg("theColUpper"));
	cls_StepElement_Array2OfCurveElementPurposeMember.def(py::init([] (const StepElement_Array2OfCurveElementPurposeMember &other) {return new StepElement_Array2OfCurveElementPurposeMember(other);}), "Copy constructor", py::arg("other"));
	cls_StepElement_Array2OfCurveElementPurposeMember.def(py::init<const opencascade::handle<StepElement_CurveElementPurposeMember> &, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer>(), py::arg("theBegin"), py::arg("theRowLower"), py::arg("theRowUpper"), py::arg("theColLower"), py::arg("theColUpper"));
	cls_StepElement_Array2OfCurveElementPurposeMember.def("Init", (void (StepElement_Array2OfCurveElementPurposeMember::*)(const opencascade::handle<StepElement_CurveElementPurposeMember> &)) &StepElement_Array2OfCurveElementPurposeMember::Init, "Initialise the values", py::arg("theValue"));
	cls_StepElement_Array2OfCurveElementPurposeMember.def("Size", (Standard_Integer (StepElement_Array2OfCurveElementPurposeMember::*)() const ) &StepElement_Array2OfCurveElementPurposeMember::Size, "Size (number of items)");
	cls_StepElement_Array2OfCurveElementPurposeMember.def("Length", (Standard_Integer (StepElement_Array2OfCurveElementPurposeMember::*)() const ) &StepElement_Array2OfCurveElementPurposeMember::Length, "Length (number of items)");
	cls_StepElement_Array2OfCurveElementPurposeMember.def("RowLength", (Standard_Integer (StepElement_Array2OfCurveElementPurposeMember::*)() const ) &StepElement_Array2OfCurveElementPurposeMember::RowLength, "Returns length of the row, i.e. number of columns");
	cls_StepElement_Array2OfCurveElementPurposeMember.def("ColLength", (Standard_Integer (StepElement_Array2OfCurveElementPurposeMember::*)() const ) &StepElement_Array2OfCurveElementPurposeMember::ColLength, "Returns length of the column, i.e. number of rows");
	cls_StepElement_Array2OfCurveElementPurposeMember.def("LowerRow", (Standard_Integer (StepElement_Array2OfCurveElementPurposeMember::*)() const ) &StepElement_Array2OfCurveElementPurposeMember::LowerRow, "LowerRow");
	cls_StepElement_Array2OfCurveElementPurposeMember.def("UpperRow", (Standard_Integer (StepElement_Array2OfCurveElementPurposeMember::*)() const ) &StepElement_Array2OfCurveElementPurposeMember::UpperRow, "UpperRow");
	cls_StepElement_Array2OfCurveElementPurposeMember.def("LowerCol", (Standard_Integer (StepElement_Array2OfCurveElementPurposeMember::*)() const ) &StepElement_Array2OfCurveElementPurposeMember::LowerCol, "LowerCol");
	cls_StepElement_Array2OfCurveElementPurposeMember.def("UpperCol", (Standard_Integer (StepElement_Array2OfCurveElementPurposeMember::*)() const ) &StepElement_Array2OfCurveElementPurposeMember::UpperCol, "UpperCol");
	cls_StepElement_Array2OfCurveElementPurposeMember.def("IsDeletable", (Standard_Boolean (StepElement_Array2OfCurveElementPurposeMember::*)() const ) &StepElement_Array2OfCurveElementPurposeMember::IsDeletable, "myDeletable flag");
	cls_StepElement_Array2OfCurveElementPurposeMember.def("Assign", (StepElement_Array2OfCurveElementPurposeMember & (StepElement_Array2OfCurveElementPurposeMember::*)(const StepElement_Array2OfCurveElementPurposeMember &)) &StepElement_Array2OfCurveElementPurposeMember::Assign, "Assignment", py::arg("theOther"));
	cls_StepElement_Array2OfCurveElementPurposeMember.def("assign", (StepElement_Array2OfCurveElementPurposeMember & (StepElement_Array2OfCurveElementPurposeMember::*)(const StepElement_Array2OfCurveElementPurposeMember &)) &StepElement_Array2OfCurveElementPurposeMember::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	cls_StepElement_Array2OfCurveElementPurposeMember.def("Value", (const opencascade::handle<StepElement_CurveElementPurposeMember> & (StepElement_Array2OfCurveElementPurposeMember::*)(const Standard_Integer, const Standard_Integer) const ) &StepElement_Array2OfCurveElementPurposeMember::Value, "Constant value access", py::arg("theRow"), py::arg("theCol"));
	cls_StepElement_Array2OfCurveElementPurposeMember.def("__call__", (const opencascade::handle<StepElement_CurveElementPurposeMember> & (StepElement_Array2OfCurveElementPurposeMember::*)(const Standard_Integer, const Standard_Integer) const ) &StepElement_Array2OfCurveElementPurposeMember::operator(), py::is_operator(), "operator() - alias to ChangeValue", py::arg("theRow"), py::arg("theCol"));
	cls_StepElement_Array2OfCurveElementPurposeMember.def("ChangeValue", (opencascade::handle<StepElement_CurveElementPurposeMember> & (StepElement_Array2OfCurveElementPurposeMember::*)(const Standard_Integer, const Standard_Integer)) &StepElement_Array2OfCurveElementPurposeMember::ChangeValue, "Variable value access", py::arg("theRow"), py::arg("theCol"));
	cls_StepElement_Array2OfCurveElementPurposeMember.def("__call__", (opencascade::handle<StepElement_CurveElementPurposeMember> & (StepElement_Array2OfCurveElementPurposeMember::*)(const Standard_Integer, const Standard_Integer)) &StepElement_Array2OfCurveElementPurposeMember::operator(), py::is_operator(), "operator() - alias to ChangeValue", py::arg("theRow"), py::arg("theCol"));
	cls_StepElement_Array2OfCurveElementPurposeMember.def("SetValue", (void (StepElement_Array2OfCurveElementPurposeMember::*)(const Standard_Integer, const Standard_Integer, const opencascade::handle<StepElement_CurveElementPurposeMember> &)) &StepElement_Array2OfCurveElementPurposeMember::SetValue, "SetValue", py::arg("theRow"), py::arg("theCol"), py::arg("theItem"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_Array2.hxx
	py::class_<StepElement_Array2OfSurfaceElementPurpose, std::unique_ptr<StepElement_Array2OfSurfaceElementPurpose, Deleter<StepElement_Array2OfSurfaceElementPurpose>>> cls_StepElement_Array2OfSurfaceElementPurpose(mod, "StepElement_Array2OfSurfaceElementPurpose", "Purpose: The class Array2 represents bi-dimensional arrays of fixed size known at run time. The ranges of indices are user defined.");
	cls_StepElement_Array2OfSurfaceElementPurpose.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer>(), py::arg("theRowLower"), py::arg("theRowUpper"), py::arg("theColLower"), py::arg("theColUpper"));
	cls_StepElement_Array2OfSurfaceElementPurpose.def(py::init([] (const StepElement_Array2OfSurfaceElementPurpose &other) {return new StepElement_Array2OfSurfaceElementPurpose(other);}), "Copy constructor", py::arg("other"));
	cls_StepElement_Array2OfSurfaceElementPurpose.def(py::init<const StepElement_SurfaceElementPurpose &, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer>(), py::arg("theBegin"), py::arg("theRowLower"), py::arg("theRowUpper"), py::arg("theColLower"), py::arg("theColUpper"));
	cls_StepElement_Array2OfSurfaceElementPurpose.def("Init", (void (StepElement_Array2OfSurfaceElementPurpose::*)(const StepElement_SurfaceElementPurpose &)) &StepElement_Array2OfSurfaceElementPurpose::Init, "Initialise the values", py::arg("theValue"));
	cls_StepElement_Array2OfSurfaceElementPurpose.def("Size", (Standard_Integer (StepElement_Array2OfSurfaceElementPurpose::*)() const ) &StepElement_Array2OfSurfaceElementPurpose::Size, "Size (number of items)");
	cls_StepElement_Array2OfSurfaceElementPurpose.def("Length", (Standard_Integer (StepElement_Array2OfSurfaceElementPurpose::*)() const ) &StepElement_Array2OfSurfaceElementPurpose::Length, "Length (number of items)");
	cls_StepElement_Array2OfSurfaceElementPurpose.def("RowLength", (Standard_Integer (StepElement_Array2OfSurfaceElementPurpose::*)() const ) &StepElement_Array2OfSurfaceElementPurpose::RowLength, "Returns length of the row, i.e. number of columns");
	cls_StepElement_Array2OfSurfaceElementPurpose.def("ColLength", (Standard_Integer (StepElement_Array2OfSurfaceElementPurpose::*)() const ) &StepElement_Array2OfSurfaceElementPurpose::ColLength, "Returns length of the column, i.e. number of rows");
	cls_StepElement_Array2OfSurfaceElementPurpose.def("LowerRow", (Standard_Integer (StepElement_Array2OfSurfaceElementPurpose::*)() const ) &StepElement_Array2OfSurfaceElementPurpose::LowerRow, "LowerRow");
	cls_StepElement_Array2OfSurfaceElementPurpose.def("UpperRow", (Standard_Integer (StepElement_Array2OfSurfaceElementPurpose::*)() const ) &StepElement_Array2OfSurfaceElementPurpose::UpperRow, "UpperRow");
	cls_StepElement_Array2OfSurfaceElementPurpose.def("LowerCol", (Standard_Integer (StepElement_Array2OfSurfaceElementPurpose::*)() const ) &StepElement_Array2OfSurfaceElementPurpose::LowerCol, "LowerCol");
	cls_StepElement_Array2OfSurfaceElementPurpose.def("UpperCol", (Standard_Integer (StepElement_Array2OfSurfaceElementPurpose::*)() const ) &StepElement_Array2OfSurfaceElementPurpose::UpperCol, "UpperCol");
	cls_StepElement_Array2OfSurfaceElementPurpose.def("IsDeletable", (Standard_Boolean (StepElement_Array2OfSurfaceElementPurpose::*)() const ) &StepElement_Array2OfSurfaceElementPurpose::IsDeletable, "myDeletable flag");
	cls_StepElement_Array2OfSurfaceElementPurpose.def("Assign", (StepElement_Array2OfSurfaceElementPurpose & (StepElement_Array2OfSurfaceElementPurpose::*)(const StepElement_Array2OfSurfaceElementPurpose &)) &StepElement_Array2OfSurfaceElementPurpose::Assign, "Assignment", py::arg("theOther"));
	cls_StepElement_Array2OfSurfaceElementPurpose.def("assign", (StepElement_Array2OfSurfaceElementPurpose & (StepElement_Array2OfSurfaceElementPurpose::*)(const StepElement_Array2OfSurfaceElementPurpose &)) &StepElement_Array2OfSurfaceElementPurpose::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	cls_StepElement_Array2OfSurfaceElementPurpose.def("Value", (const StepElement_SurfaceElementPurpose & (StepElement_Array2OfSurfaceElementPurpose::*)(const Standard_Integer, const Standard_Integer) const ) &StepElement_Array2OfSurfaceElementPurpose::Value, "Constant value access", py::arg("theRow"), py::arg("theCol"));
	cls_StepElement_Array2OfSurfaceElementPurpose.def("__call__", (const StepElement_SurfaceElementPurpose & (StepElement_Array2OfSurfaceElementPurpose::*)(const Standard_Integer, const Standard_Integer) const ) &StepElement_Array2OfSurfaceElementPurpose::operator(), py::is_operator(), "operator() - alias to ChangeValue", py::arg("theRow"), py::arg("theCol"));
	cls_StepElement_Array2OfSurfaceElementPurpose.def("ChangeValue", (StepElement_SurfaceElementPurpose & (StepElement_Array2OfSurfaceElementPurpose::*)(const Standard_Integer, const Standard_Integer)) &StepElement_Array2OfSurfaceElementPurpose::ChangeValue, "Variable value access", py::arg("theRow"), py::arg("theCol"));
	cls_StepElement_Array2OfSurfaceElementPurpose.def("__call__", (StepElement_SurfaceElementPurpose & (StepElement_Array2OfSurfaceElementPurpose::*)(const Standard_Integer, const Standard_Integer)) &StepElement_Array2OfSurfaceElementPurpose::operator(), py::is_operator(), "operator() - alias to ChangeValue", py::arg("theRow"), py::arg("theCol"));
	cls_StepElement_Array2OfSurfaceElementPurpose.def("SetValue", (void (StepElement_Array2OfSurfaceElementPurpose::*)(const Standard_Integer, const Standard_Integer, const StepElement_SurfaceElementPurpose &)) &StepElement_Array2OfSurfaceElementPurpose::SetValue, "SetValue", py::arg("theRow"), py::arg("theCol"), py::arg("theItem"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_Array2.hxx
	py::class_<StepElement_Array2OfSurfaceElementPurposeMember, std::unique_ptr<StepElement_Array2OfSurfaceElementPurposeMember, Deleter<StepElement_Array2OfSurfaceElementPurposeMember>>> cls_StepElement_Array2OfSurfaceElementPurposeMember(mod, "StepElement_Array2OfSurfaceElementPurposeMember", "Purpose: The class Array2 represents bi-dimensional arrays of fixed size known at run time. The ranges of indices are user defined.");
	cls_StepElement_Array2OfSurfaceElementPurposeMember.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer>(), py::arg("theRowLower"), py::arg("theRowUpper"), py::arg("theColLower"), py::arg("theColUpper"));
	cls_StepElement_Array2OfSurfaceElementPurposeMember.def(py::init([] (const StepElement_Array2OfSurfaceElementPurposeMember &other) {return new StepElement_Array2OfSurfaceElementPurposeMember(other);}), "Copy constructor", py::arg("other"));
	cls_StepElement_Array2OfSurfaceElementPurposeMember.def(py::init<const opencascade::handle<StepElement_SurfaceElementPurposeMember> &, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer>(), py::arg("theBegin"), py::arg("theRowLower"), py::arg("theRowUpper"), py::arg("theColLower"), py::arg("theColUpper"));
	cls_StepElement_Array2OfSurfaceElementPurposeMember.def("Init", (void (StepElement_Array2OfSurfaceElementPurposeMember::*)(const opencascade::handle<StepElement_SurfaceElementPurposeMember> &)) &StepElement_Array2OfSurfaceElementPurposeMember::Init, "Initialise the values", py::arg("theValue"));
	cls_StepElement_Array2OfSurfaceElementPurposeMember.def("Size", (Standard_Integer (StepElement_Array2OfSurfaceElementPurposeMember::*)() const ) &StepElement_Array2OfSurfaceElementPurposeMember::Size, "Size (number of items)");
	cls_StepElement_Array2OfSurfaceElementPurposeMember.def("Length", (Standard_Integer (StepElement_Array2OfSurfaceElementPurposeMember::*)() const ) &StepElement_Array2OfSurfaceElementPurposeMember::Length, "Length (number of items)");
	cls_StepElement_Array2OfSurfaceElementPurposeMember.def("RowLength", (Standard_Integer (StepElement_Array2OfSurfaceElementPurposeMember::*)() const ) &StepElement_Array2OfSurfaceElementPurposeMember::RowLength, "Returns length of the row, i.e. number of columns");
	cls_StepElement_Array2OfSurfaceElementPurposeMember.def("ColLength", (Standard_Integer (StepElement_Array2OfSurfaceElementPurposeMember::*)() const ) &StepElement_Array2OfSurfaceElementPurposeMember::ColLength, "Returns length of the column, i.e. number of rows");
	cls_StepElement_Array2OfSurfaceElementPurposeMember.def("LowerRow", (Standard_Integer (StepElement_Array2OfSurfaceElementPurposeMember::*)() const ) &StepElement_Array2OfSurfaceElementPurposeMember::LowerRow, "LowerRow");
	cls_StepElement_Array2OfSurfaceElementPurposeMember.def("UpperRow", (Standard_Integer (StepElement_Array2OfSurfaceElementPurposeMember::*)() const ) &StepElement_Array2OfSurfaceElementPurposeMember::UpperRow, "UpperRow");
	cls_StepElement_Array2OfSurfaceElementPurposeMember.def("LowerCol", (Standard_Integer (StepElement_Array2OfSurfaceElementPurposeMember::*)() const ) &StepElement_Array2OfSurfaceElementPurposeMember::LowerCol, "LowerCol");
	cls_StepElement_Array2OfSurfaceElementPurposeMember.def("UpperCol", (Standard_Integer (StepElement_Array2OfSurfaceElementPurposeMember::*)() const ) &StepElement_Array2OfSurfaceElementPurposeMember::UpperCol, "UpperCol");
	cls_StepElement_Array2OfSurfaceElementPurposeMember.def("IsDeletable", (Standard_Boolean (StepElement_Array2OfSurfaceElementPurposeMember::*)() const ) &StepElement_Array2OfSurfaceElementPurposeMember::IsDeletable, "myDeletable flag");
	cls_StepElement_Array2OfSurfaceElementPurposeMember.def("Assign", (StepElement_Array2OfSurfaceElementPurposeMember & (StepElement_Array2OfSurfaceElementPurposeMember::*)(const StepElement_Array2OfSurfaceElementPurposeMember &)) &StepElement_Array2OfSurfaceElementPurposeMember::Assign, "Assignment", py::arg("theOther"));
	cls_StepElement_Array2OfSurfaceElementPurposeMember.def("assign", (StepElement_Array2OfSurfaceElementPurposeMember & (StepElement_Array2OfSurfaceElementPurposeMember::*)(const StepElement_Array2OfSurfaceElementPurposeMember &)) &StepElement_Array2OfSurfaceElementPurposeMember::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	cls_StepElement_Array2OfSurfaceElementPurposeMember.def("Value", (const opencascade::handle<StepElement_SurfaceElementPurposeMember> & (StepElement_Array2OfSurfaceElementPurposeMember::*)(const Standard_Integer, const Standard_Integer) const ) &StepElement_Array2OfSurfaceElementPurposeMember::Value, "Constant value access", py::arg("theRow"), py::arg("theCol"));
	cls_StepElement_Array2OfSurfaceElementPurposeMember.def("__call__", (const opencascade::handle<StepElement_SurfaceElementPurposeMember> & (StepElement_Array2OfSurfaceElementPurposeMember::*)(const Standard_Integer, const Standard_Integer) const ) &StepElement_Array2OfSurfaceElementPurposeMember::operator(), py::is_operator(), "operator() - alias to ChangeValue", py::arg("theRow"), py::arg("theCol"));
	cls_StepElement_Array2OfSurfaceElementPurposeMember.def("ChangeValue", (opencascade::handle<StepElement_SurfaceElementPurposeMember> & (StepElement_Array2OfSurfaceElementPurposeMember::*)(const Standard_Integer, const Standard_Integer)) &StepElement_Array2OfSurfaceElementPurposeMember::ChangeValue, "Variable value access", py::arg("theRow"), py::arg("theCol"));
	cls_StepElement_Array2OfSurfaceElementPurposeMember.def("__call__", (opencascade::handle<StepElement_SurfaceElementPurposeMember> & (StepElement_Array2OfSurfaceElementPurposeMember::*)(const Standard_Integer, const Standard_Integer)) &StepElement_Array2OfSurfaceElementPurposeMember::operator(), py::is_operator(), "operator() - alias to ChangeValue", py::arg("theRow"), py::arg("theCol"));
	cls_StepElement_Array2OfSurfaceElementPurposeMember.def("SetValue", (void (StepElement_Array2OfSurfaceElementPurposeMember::*)(const Standard_Integer, const Standard_Integer, const opencascade::handle<StepElement_SurfaceElementPurposeMember> &)) &StepElement_Array2OfSurfaceElementPurposeMember::SetValue, "SetValue", py::arg("theRow"), py::arg("theCol"), py::arg("theItem"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_MeasureOrUnspecifiedValueMember.hxx
	py::class_<StepElement_MeasureOrUnspecifiedValueMember, opencascade::handle<StepElement_MeasureOrUnspecifiedValueMember>, StepData_SelectNamed> cls_StepElement_MeasureOrUnspecifiedValueMember(mod, "StepElement_MeasureOrUnspecifiedValueMember", "Representation of member for STEP SELECT type MeasureOrUnspecifiedValue");
	cls_StepElement_MeasureOrUnspecifiedValueMember.def(py::init<>());
	cls_StepElement_MeasureOrUnspecifiedValueMember.def("HasName", (Standard_Boolean (StepElement_MeasureOrUnspecifiedValueMember::*)() const ) &StepElement_MeasureOrUnspecifiedValueMember::HasName, "Returns True if has name");
	cls_StepElement_MeasureOrUnspecifiedValueMember.def("Name", (Standard_CString (StepElement_MeasureOrUnspecifiedValueMember::*)() const ) &StepElement_MeasureOrUnspecifiedValueMember::Name, "Returns set name");
	cls_StepElement_MeasureOrUnspecifiedValueMember.def("SetName", (Standard_Boolean (StepElement_MeasureOrUnspecifiedValueMember::*)(const Standard_CString)) &StepElement_MeasureOrUnspecifiedValueMember::SetName, "Set name", py::arg("name"));
	cls_StepElement_MeasureOrUnspecifiedValueMember.def("Matches", (Standard_Boolean (StepElement_MeasureOrUnspecifiedValueMember::*)(const Standard_CString) const ) &StepElement_MeasureOrUnspecifiedValueMember::Matches, "Tells if the name of a SelectMember matches a given one;", py::arg("name"));
	cls_StepElement_MeasureOrUnspecifiedValueMember.def_static("get_type_name_", (const char * (*)()) &StepElement_MeasureOrUnspecifiedValueMember::get_type_name, "None");
	cls_StepElement_MeasureOrUnspecifiedValueMember.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_MeasureOrUnspecifiedValueMember::get_type_descriptor, "None");
	cls_StepElement_MeasureOrUnspecifiedValueMember.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_MeasureOrUnspecifiedValueMember::*)() const ) &StepElement_MeasureOrUnspecifiedValueMember::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_HSequenceOfElementMaterial.hxx
	py::class_<StepElement_HSequenceOfElementMaterial, opencascade::handle<StepElement_HSequenceOfElementMaterial>, StepElement_SequenceOfElementMaterial, Standard_Transient> cls_StepElement_HSequenceOfElementMaterial(mod, "StepElement_HSequenceOfElementMaterial", "None");
	cls_StepElement_HSequenceOfElementMaterial.def(py::init<>());
	cls_StepElement_HSequenceOfElementMaterial.def(py::init<const StepElement_SequenceOfElementMaterial &>(), py::arg("theOther"));
	cls_StepElement_HSequenceOfElementMaterial.def("Sequence", (const StepElement_SequenceOfElementMaterial & (StepElement_HSequenceOfElementMaterial::*)() const ) &StepElement_HSequenceOfElementMaterial::Sequence, "None");
	cls_StepElement_HSequenceOfElementMaterial.def("Append", (void (StepElement_HSequenceOfElementMaterial::*)(const StepElement_SequenceOfElementMaterial::value_type &)) &StepElement_HSequenceOfElementMaterial::Append, "None", py::arg("theItem"));
	cls_StepElement_HSequenceOfElementMaterial.def("Append", (void (StepElement_HSequenceOfElementMaterial::*)(StepElement_SequenceOfElementMaterial &)) &StepElement_HSequenceOfElementMaterial::Append, "None", py::arg("theSequence"));
	cls_StepElement_HSequenceOfElementMaterial.def("ChangeSequence", (StepElement_SequenceOfElementMaterial & (StepElement_HSequenceOfElementMaterial::*)()) &StepElement_HSequenceOfElementMaterial::ChangeSequence, "None");
	cls_StepElement_HSequenceOfElementMaterial.def_static("get_type_name_", (const char * (*)()) &StepElement_HSequenceOfElementMaterial::get_type_name, "None");
	cls_StepElement_HSequenceOfElementMaterial.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_HSequenceOfElementMaterial::get_type_descriptor, "None");
	cls_StepElement_HSequenceOfElementMaterial.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_HSequenceOfElementMaterial::*)() const ) &StepElement_HSequenceOfElementMaterial::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_HSequenceOfCurveElementSectionDefinition.hxx
	py::class_<StepElement_HSequenceOfCurveElementSectionDefinition, opencascade::handle<StepElement_HSequenceOfCurveElementSectionDefinition>, StepElement_SequenceOfCurveElementSectionDefinition, Standard_Transient> cls_StepElement_HSequenceOfCurveElementSectionDefinition(mod, "StepElement_HSequenceOfCurveElementSectionDefinition", "None");
	cls_StepElement_HSequenceOfCurveElementSectionDefinition.def(py::init<>());
	cls_StepElement_HSequenceOfCurveElementSectionDefinition.def(py::init<const StepElement_SequenceOfCurveElementSectionDefinition &>(), py::arg("theOther"));
	cls_StepElement_HSequenceOfCurveElementSectionDefinition.def("Sequence", (const StepElement_SequenceOfCurveElementSectionDefinition & (StepElement_HSequenceOfCurveElementSectionDefinition::*)() const ) &StepElement_HSequenceOfCurveElementSectionDefinition::Sequence, "None");
	cls_StepElement_HSequenceOfCurveElementSectionDefinition.def("Append", (void (StepElement_HSequenceOfCurveElementSectionDefinition::*)(const StepElement_SequenceOfCurveElementSectionDefinition::value_type &)) &StepElement_HSequenceOfCurveElementSectionDefinition::Append, "None", py::arg("theItem"));
	cls_StepElement_HSequenceOfCurveElementSectionDefinition.def("Append", (void (StepElement_HSequenceOfCurveElementSectionDefinition::*)(StepElement_SequenceOfCurveElementSectionDefinition &)) &StepElement_HSequenceOfCurveElementSectionDefinition::Append, "None", py::arg("theSequence"));
	cls_StepElement_HSequenceOfCurveElementSectionDefinition.def("ChangeSequence", (StepElement_SequenceOfCurveElementSectionDefinition & (StepElement_HSequenceOfCurveElementSectionDefinition::*)()) &StepElement_HSequenceOfCurveElementSectionDefinition::ChangeSequence, "None");
	cls_StepElement_HSequenceOfCurveElementSectionDefinition.def_static("get_type_name_", (const char * (*)()) &StepElement_HSequenceOfCurveElementSectionDefinition::get_type_name, "None");
	cls_StepElement_HSequenceOfCurveElementSectionDefinition.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_HSequenceOfCurveElementSectionDefinition::get_type_descriptor, "None");
	cls_StepElement_HSequenceOfCurveElementSectionDefinition.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_HSequenceOfCurveElementSectionDefinition::*)() const ) &StepElement_HSequenceOfCurveElementSectionDefinition::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_HArray1OfCurveElementEndReleasePacket.hxx
	py::class_<StepElement_HArray1OfCurveElementEndReleasePacket, opencascade::handle<StepElement_HArray1OfCurveElementEndReleasePacket>, StepElement_Array1OfCurveElementEndReleasePacket, Standard_Transient> cls_StepElement_HArray1OfCurveElementEndReleasePacket(mod, "StepElement_HArray1OfCurveElementEndReleasePacket", "None");
	cls_StepElement_HArray1OfCurveElementEndReleasePacket.def(py::init<const Standard_Integer, const Standard_Integer>(), py::arg("theLower"), py::arg("theUpper"));
	cls_StepElement_HArray1OfCurveElementEndReleasePacket.def(py::init<const Standard_Integer, const Standard_Integer, const StepElement_Array1OfCurveElementEndReleasePacket::value_type &>(), py::arg("theLower"), py::arg("theUpper"), py::arg("theValue"));
	cls_StepElement_HArray1OfCurveElementEndReleasePacket.def(py::init<const StepElement_Array1OfCurveElementEndReleasePacket &>(), py::arg("theOther"));
	cls_StepElement_HArray1OfCurveElementEndReleasePacket.def("Array1", (const StepElement_Array1OfCurveElementEndReleasePacket & (StepElement_HArray1OfCurveElementEndReleasePacket::*)() const ) &StepElement_HArray1OfCurveElementEndReleasePacket::Array1, "None");
	cls_StepElement_HArray1OfCurveElementEndReleasePacket.def("ChangeArray1", (StepElement_Array1OfCurveElementEndReleasePacket & (StepElement_HArray1OfCurveElementEndReleasePacket::*)()) &StepElement_HArray1OfCurveElementEndReleasePacket::ChangeArray1, "None");
	cls_StepElement_HArray1OfCurveElementEndReleasePacket.def_static("get_type_name_", (const char * (*)()) &StepElement_HArray1OfCurveElementEndReleasePacket::get_type_name, "None");
	cls_StepElement_HArray1OfCurveElementEndReleasePacket.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_HArray1OfCurveElementEndReleasePacket::get_type_descriptor, "None");
	cls_StepElement_HArray1OfCurveElementEndReleasePacket.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_HArray1OfCurveElementEndReleasePacket::*)() const ) &StepElement_HArray1OfCurveElementEndReleasePacket::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_HArray1OfCurveElementSectionDefinition.hxx
	py::class_<StepElement_HArray1OfCurveElementSectionDefinition, opencascade::handle<StepElement_HArray1OfCurveElementSectionDefinition>, StepElement_Array1OfCurveElementSectionDefinition, Standard_Transient> cls_StepElement_HArray1OfCurveElementSectionDefinition(mod, "StepElement_HArray1OfCurveElementSectionDefinition", "None");
	cls_StepElement_HArray1OfCurveElementSectionDefinition.def(py::init<const Standard_Integer, const Standard_Integer>(), py::arg("theLower"), py::arg("theUpper"));
	cls_StepElement_HArray1OfCurveElementSectionDefinition.def(py::init<const Standard_Integer, const Standard_Integer, const StepElement_Array1OfCurveElementSectionDefinition::value_type &>(), py::arg("theLower"), py::arg("theUpper"), py::arg("theValue"));
	cls_StepElement_HArray1OfCurveElementSectionDefinition.def(py::init<const StepElement_Array1OfCurveElementSectionDefinition &>(), py::arg("theOther"));
	cls_StepElement_HArray1OfCurveElementSectionDefinition.def("Array1", (const StepElement_Array1OfCurveElementSectionDefinition & (StepElement_HArray1OfCurveElementSectionDefinition::*)() const ) &StepElement_HArray1OfCurveElementSectionDefinition::Array1, "None");
	cls_StepElement_HArray1OfCurveElementSectionDefinition.def("ChangeArray1", (StepElement_Array1OfCurveElementSectionDefinition & (StepElement_HArray1OfCurveElementSectionDefinition::*)()) &StepElement_HArray1OfCurveElementSectionDefinition::ChangeArray1, "None");
	cls_StepElement_HArray1OfCurveElementSectionDefinition.def_static("get_type_name_", (const char * (*)()) &StepElement_HArray1OfCurveElementSectionDefinition::get_type_name, "None");
	cls_StepElement_HArray1OfCurveElementSectionDefinition.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_HArray1OfCurveElementSectionDefinition::get_type_descriptor, "None");
	cls_StepElement_HArray1OfCurveElementSectionDefinition.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_HArray1OfCurveElementSectionDefinition::*)() const ) &StepElement_HArray1OfCurveElementSectionDefinition::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_HSequenceOfCurveElementPurposeMember.hxx
	py::class_<StepElement_HSequenceOfCurveElementPurposeMember, opencascade::handle<StepElement_HSequenceOfCurveElementPurposeMember>, StepElement_SequenceOfCurveElementPurposeMember, Standard_Transient> cls_StepElement_HSequenceOfCurveElementPurposeMember(mod, "StepElement_HSequenceOfCurveElementPurposeMember", "None");
	cls_StepElement_HSequenceOfCurveElementPurposeMember.def(py::init<>());
	cls_StepElement_HSequenceOfCurveElementPurposeMember.def(py::init<const StepElement_SequenceOfCurveElementPurposeMember &>(), py::arg("theOther"));
	cls_StepElement_HSequenceOfCurveElementPurposeMember.def("Sequence", (const StepElement_SequenceOfCurveElementPurposeMember & (StepElement_HSequenceOfCurveElementPurposeMember::*)() const ) &StepElement_HSequenceOfCurveElementPurposeMember::Sequence, "None");
	cls_StepElement_HSequenceOfCurveElementPurposeMember.def("Append", (void (StepElement_HSequenceOfCurveElementPurposeMember::*)(const StepElement_SequenceOfCurveElementPurposeMember::value_type &)) &StepElement_HSequenceOfCurveElementPurposeMember::Append, "None", py::arg("theItem"));
	cls_StepElement_HSequenceOfCurveElementPurposeMember.def("Append", (void (StepElement_HSequenceOfCurveElementPurposeMember::*)(StepElement_SequenceOfCurveElementPurposeMember &)) &StepElement_HSequenceOfCurveElementPurposeMember::Append, "None", py::arg("theSequence"));
	cls_StepElement_HSequenceOfCurveElementPurposeMember.def("ChangeSequence", (StepElement_SequenceOfCurveElementPurposeMember & (StepElement_HSequenceOfCurveElementPurposeMember::*)()) &StepElement_HSequenceOfCurveElementPurposeMember::ChangeSequence, "None");
	cls_StepElement_HSequenceOfCurveElementPurposeMember.def_static("get_type_name_", (const char * (*)()) &StepElement_HSequenceOfCurveElementPurposeMember::get_type_name, "None");
	cls_StepElement_HSequenceOfCurveElementPurposeMember.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_HSequenceOfCurveElementPurposeMember::get_type_descriptor, "None");
	cls_StepElement_HSequenceOfCurveElementPurposeMember.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_HSequenceOfCurveElementPurposeMember::*)() const ) &StepElement_HSequenceOfCurveElementPurposeMember::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_HArray1OfHSequenceOfCurveElementPurposeMember.hxx
	py::class_<StepElement_HArray1OfHSequenceOfCurveElementPurposeMember, opencascade::handle<StepElement_HArray1OfHSequenceOfCurveElementPurposeMember>, StepElement_Array1OfHSequenceOfCurveElementPurposeMember, Standard_Transient> cls_StepElement_HArray1OfHSequenceOfCurveElementPurposeMember(mod, "StepElement_HArray1OfHSequenceOfCurveElementPurposeMember", "None");
	cls_StepElement_HArray1OfHSequenceOfCurveElementPurposeMember.def(py::init<const Standard_Integer, const Standard_Integer>(), py::arg("theLower"), py::arg("theUpper"));
	cls_StepElement_HArray1OfHSequenceOfCurveElementPurposeMember.def(py::init<const Standard_Integer, const Standard_Integer, const StepElement_Array1OfHSequenceOfCurveElementPurposeMember::value_type &>(), py::arg("theLower"), py::arg("theUpper"), py::arg("theValue"));
	cls_StepElement_HArray1OfHSequenceOfCurveElementPurposeMember.def(py::init<const StepElement_Array1OfHSequenceOfCurveElementPurposeMember &>(), py::arg("theOther"));
	cls_StepElement_HArray1OfHSequenceOfCurveElementPurposeMember.def("Array1", (const StepElement_Array1OfHSequenceOfCurveElementPurposeMember & (StepElement_HArray1OfHSequenceOfCurveElementPurposeMember::*)() const ) &StepElement_HArray1OfHSequenceOfCurveElementPurposeMember::Array1, "None");
	cls_StepElement_HArray1OfHSequenceOfCurveElementPurposeMember.def("ChangeArray1", (StepElement_Array1OfHSequenceOfCurveElementPurposeMember & (StepElement_HArray1OfHSequenceOfCurveElementPurposeMember::*)()) &StepElement_HArray1OfHSequenceOfCurveElementPurposeMember::ChangeArray1, "None");
	cls_StepElement_HArray1OfHSequenceOfCurveElementPurposeMember.def_static("get_type_name_", (const char * (*)()) &StepElement_HArray1OfHSequenceOfCurveElementPurposeMember::get_type_name, "None");
	cls_StepElement_HArray1OfHSequenceOfCurveElementPurposeMember.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_HArray1OfHSequenceOfCurveElementPurposeMember::get_type_descriptor, "None");
	cls_StepElement_HArray1OfHSequenceOfCurveElementPurposeMember.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_HArray1OfHSequenceOfCurveElementPurposeMember::*)() const ) &StepElement_HArray1OfHSequenceOfCurveElementPurposeMember::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_HSequenceOfSurfaceElementPurposeMember.hxx
	py::class_<StepElement_HSequenceOfSurfaceElementPurposeMember, opencascade::handle<StepElement_HSequenceOfSurfaceElementPurposeMember>, StepElement_SequenceOfSurfaceElementPurposeMember, Standard_Transient> cls_StepElement_HSequenceOfSurfaceElementPurposeMember(mod, "StepElement_HSequenceOfSurfaceElementPurposeMember", "None");
	cls_StepElement_HSequenceOfSurfaceElementPurposeMember.def(py::init<>());
	cls_StepElement_HSequenceOfSurfaceElementPurposeMember.def(py::init<const StepElement_SequenceOfSurfaceElementPurposeMember &>(), py::arg("theOther"));
	cls_StepElement_HSequenceOfSurfaceElementPurposeMember.def("Sequence", (const StepElement_SequenceOfSurfaceElementPurposeMember & (StepElement_HSequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_HSequenceOfSurfaceElementPurposeMember::Sequence, "None");
	cls_StepElement_HSequenceOfSurfaceElementPurposeMember.def("Append", (void (StepElement_HSequenceOfSurfaceElementPurposeMember::*)(const StepElement_SequenceOfSurfaceElementPurposeMember::value_type &)) &StepElement_HSequenceOfSurfaceElementPurposeMember::Append, "None", py::arg("theItem"));
	cls_StepElement_HSequenceOfSurfaceElementPurposeMember.def("Append", (void (StepElement_HSequenceOfSurfaceElementPurposeMember::*)(StepElement_SequenceOfSurfaceElementPurposeMember &)) &StepElement_HSequenceOfSurfaceElementPurposeMember::Append, "None", py::arg("theSequence"));
	cls_StepElement_HSequenceOfSurfaceElementPurposeMember.def("ChangeSequence", (StepElement_SequenceOfSurfaceElementPurposeMember & (StepElement_HSequenceOfSurfaceElementPurposeMember::*)()) &StepElement_HSequenceOfSurfaceElementPurposeMember::ChangeSequence, "None");
	cls_StepElement_HSequenceOfSurfaceElementPurposeMember.def_static("get_type_name_", (const char * (*)()) &StepElement_HSequenceOfSurfaceElementPurposeMember::get_type_name, "None");
	cls_StepElement_HSequenceOfSurfaceElementPurposeMember.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_HSequenceOfSurfaceElementPurposeMember::get_type_descriptor, "None");
	cls_StepElement_HSequenceOfSurfaceElementPurposeMember.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_HSequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_HSequenceOfSurfaceElementPurposeMember::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_HArray1OfHSequenceOfSurfaceElementPurposeMember.hxx
	py::class_<StepElement_HArray1OfHSequenceOfSurfaceElementPurposeMember, opencascade::handle<StepElement_HArray1OfHSequenceOfSurfaceElementPurposeMember>, StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember, Standard_Transient> cls_StepElement_HArray1OfHSequenceOfSurfaceElementPurposeMember(mod, "StepElement_HArray1OfHSequenceOfSurfaceElementPurposeMember", "None");
	cls_StepElement_HArray1OfHSequenceOfSurfaceElementPurposeMember.def(py::init<const Standard_Integer, const Standard_Integer>(), py::arg("theLower"), py::arg("theUpper"));
	cls_StepElement_HArray1OfHSequenceOfSurfaceElementPurposeMember.def(py::init<const Standard_Integer, const Standard_Integer, const StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember::value_type &>(), py::arg("theLower"), py::arg("theUpper"), py::arg("theValue"));
	cls_StepElement_HArray1OfHSequenceOfSurfaceElementPurposeMember.def(py::init<const StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember &>(), py::arg("theOther"));
	cls_StepElement_HArray1OfHSequenceOfSurfaceElementPurposeMember.def("Array1", (const StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember & (StepElement_HArray1OfHSequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_HArray1OfHSequenceOfSurfaceElementPurposeMember::Array1, "None");
	cls_StepElement_HArray1OfHSequenceOfSurfaceElementPurposeMember.def("ChangeArray1", (StepElement_Array1OfHSequenceOfSurfaceElementPurposeMember & (StepElement_HArray1OfHSequenceOfSurfaceElementPurposeMember::*)()) &StepElement_HArray1OfHSequenceOfSurfaceElementPurposeMember::ChangeArray1, "None");
	cls_StepElement_HArray1OfHSequenceOfSurfaceElementPurposeMember.def_static("get_type_name_", (const char * (*)()) &StepElement_HArray1OfHSequenceOfSurfaceElementPurposeMember::get_type_name, "None");
	cls_StepElement_HArray1OfHSequenceOfSurfaceElementPurposeMember.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_HArray1OfHSequenceOfSurfaceElementPurposeMember::get_type_descriptor, "None");
	cls_StepElement_HArray1OfHSequenceOfSurfaceElementPurposeMember.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_HArray1OfHSequenceOfSurfaceElementPurposeMember::*)() const ) &StepElement_HArray1OfHSequenceOfSurfaceElementPurposeMember::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_HArray1OfMeasureOrUnspecifiedValue.hxx
	py::class_<StepElement_HArray1OfMeasureOrUnspecifiedValue, opencascade::handle<StepElement_HArray1OfMeasureOrUnspecifiedValue>, StepElement_Array1OfMeasureOrUnspecifiedValue, Standard_Transient> cls_StepElement_HArray1OfMeasureOrUnspecifiedValue(mod, "StepElement_HArray1OfMeasureOrUnspecifiedValue", "None");
	cls_StepElement_HArray1OfMeasureOrUnspecifiedValue.def(py::init<const Standard_Integer, const Standard_Integer>(), py::arg("theLower"), py::arg("theUpper"));
	cls_StepElement_HArray1OfMeasureOrUnspecifiedValue.def(py::init<const Standard_Integer, const Standard_Integer, const StepElement_Array1OfMeasureOrUnspecifiedValue::value_type &>(), py::arg("theLower"), py::arg("theUpper"), py::arg("theValue"));
	cls_StepElement_HArray1OfMeasureOrUnspecifiedValue.def(py::init<const StepElement_Array1OfMeasureOrUnspecifiedValue &>(), py::arg("theOther"));
	cls_StepElement_HArray1OfMeasureOrUnspecifiedValue.def("Array1", (const StepElement_Array1OfMeasureOrUnspecifiedValue & (StepElement_HArray1OfMeasureOrUnspecifiedValue::*)() const ) &StepElement_HArray1OfMeasureOrUnspecifiedValue::Array1, "None");
	cls_StepElement_HArray1OfMeasureOrUnspecifiedValue.def("ChangeArray1", (StepElement_Array1OfMeasureOrUnspecifiedValue & (StepElement_HArray1OfMeasureOrUnspecifiedValue::*)()) &StepElement_HArray1OfMeasureOrUnspecifiedValue::ChangeArray1, "None");
	cls_StepElement_HArray1OfMeasureOrUnspecifiedValue.def_static("get_type_name_", (const char * (*)()) &StepElement_HArray1OfMeasureOrUnspecifiedValue::get_type_name, "None");
	cls_StepElement_HArray1OfMeasureOrUnspecifiedValue.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_HArray1OfMeasureOrUnspecifiedValue::get_type_descriptor, "None");
	cls_StepElement_HArray1OfMeasureOrUnspecifiedValue.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_HArray1OfMeasureOrUnspecifiedValue::*)() const ) &StepElement_HArray1OfMeasureOrUnspecifiedValue::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_HArray1OfSurfaceSection.hxx
	py::class_<StepElement_HArray1OfSurfaceSection, opencascade::handle<StepElement_HArray1OfSurfaceSection>, StepElement_Array1OfSurfaceSection, Standard_Transient> cls_StepElement_HArray1OfSurfaceSection(mod, "StepElement_HArray1OfSurfaceSection", "None");
	cls_StepElement_HArray1OfSurfaceSection.def(py::init<const Standard_Integer, const Standard_Integer>(), py::arg("theLower"), py::arg("theUpper"));
	cls_StepElement_HArray1OfSurfaceSection.def(py::init<const Standard_Integer, const Standard_Integer, const StepElement_Array1OfSurfaceSection::value_type &>(), py::arg("theLower"), py::arg("theUpper"), py::arg("theValue"));
	cls_StepElement_HArray1OfSurfaceSection.def(py::init<const StepElement_Array1OfSurfaceSection &>(), py::arg("theOther"));
	cls_StepElement_HArray1OfSurfaceSection.def("Array1", (const StepElement_Array1OfSurfaceSection & (StepElement_HArray1OfSurfaceSection::*)() const ) &StepElement_HArray1OfSurfaceSection::Array1, "None");
	cls_StepElement_HArray1OfSurfaceSection.def("ChangeArray1", (StepElement_Array1OfSurfaceSection & (StepElement_HArray1OfSurfaceSection::*)()) &StepElement_HArray1OfSurfaceSection::ChangeArray1, "None");
	cls_StepElement_HArray1OfSurfaceSection.def_static("get_type_name_", (const char * (*)()) &StepElement_HArray1OfSurfaceSection::get_type_name, "None");
	cls_StepElement_HArray1OfSurfaceSection.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_HArray1OfSurfaceSection::get_type_descriptor, "None");
	cls_StepElement_HArray1OfSurfaceSection.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_HArray1OfSurfaceSection::*)() const ) &StepElement_HArray1OfSurfaceSection::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_HArray1OfVolumeElementPurpose.hxx
	py::class_<StepElement_HArray1OfVolumeElementPurpose, opencascade::handle<StepElement_HArray1OfVolumeElementPurpose>, StepElement_Array1OfVolumeElementPurpose, Standard_Transient> cls_StepElement_HArray1OfVolumeElementPurpose(mod, "StepElement_HArray1OfVolumeElementPurpose", "None");
	cls_StepElement_HArray1OfVolumeElementPurpose.def(py::init<const Standard_Integer, const Standard_Integer>(), py::arg("theLower"), py::arg("theUpper"));
	cls_StepElement_HArray1OfVolumeElementPurpose.def(py::init<const Standard_Integer, const Standard_Integer, const StepElement_Array1OfVolumeElementPurpose::value_type &>(), py::arg("theLower"), py::arg("theUpper"), py::arg("theValue"));
	cls_StepElement_HArray1OfVolumeElementPurpose.def(py::init<const StepElement_Array1OfVolumeElementPurpose &>(), py::arg("theOther"));
	cls_StepElement_HArray1OfVolumeElementPurpose.def("Array1", (const StepElement_Array1OfVolumeElementPurpose & (StepElement_HArray1OfVolumeElementPurpose::*)() const ) &StepElement_HArray1OfVolumeElementPurpose::Array1, "None");
	cls_StepElement_HArray1OfVolumeElementPurpose.def("ChangeArray1", (StepElement_Array1OfVolumeElementPurpose & (StepElement_HArray1OfVolumeElementPurpose::*)()) &StepElement_HArray1OfVolumeElementPurpose::ChangeArray1, "None");
	cls_StepElement_HArray1OfVolumeElementPurpose.def_static("get_type_name_", (const char * (*)()) &StepElement_HArray1OfVolumeElementPurpose::get_type_name, "None");
	cls_StepElement_HArray1OfVolumeElementPurpose.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_HArray1OfVolumeElementPurpose::get_type_descriptor, "None");
	cls_StepElement_HArray1OfVolumeElementPurpose.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_HArray1OfVolumeElementPurpose::*)() const ) &StepElement_HArray1OfVolumeElementPurpose::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_HArray1OfVolumeElementPurposeMember.hxx
	py::class_<StepElement_HArray1OfVolumeElementPurposeMember, opencascade::handle<StepElement_HArray1OfVolumeElementPurposeMember>, StepElement_Array1OfVolumeElementPurposeMember, Standard_Transient> cls_StepElement_HArray1OfVolumeElementPurposeMember(mod, "StepElement_HArray1OfVolumeElementPurposeMember", "None");
	cls_StepElement_HArray1OfVolumeElementPurposeMember.def(py::init<const Standard_Integer, const Standard_Integer>(), py::arg("theLower"), py::arg("theUpper"));
	cls_StepElement_HArray1OfVolumeElementPurposeMember.def(py::init<const Standard_Integer, const Standard_Integer, const StepElement_Array1OfVolumeElementPurposeMember::value_type &>(), py::arg("theLower"), py::arg("theUpper"), py::arg("theValue"));
	cls_StepElement_HArray1OfVolumeElementPurposeMember.def(py::init<const StepElement_Array1OfVolumeElementPurposeMember &>(), py::arg("theOther"));
	cls_StepElement_HArray1OfVolumeElementPurposeMember.def("Array1", (const StepElement_Array1OfVolumeElementPurposeMember & (StepElement_HArray1OfVolumeElementPurposeMember::*)() const ) &StepElement_HArray1OfVolumeElementPurposeMember::Array1, "None");
	cls_StepElement_HArray1OfVolumeElementPurposeMember.def("ChangeArray1", (StepElement_Array1OfVolumeElementPurposeMember & (StepElement_HArray1OfVolumeElementPurposeMember::*)()) &StepElement_HArray1OfVolumeElementPurposeMember::ChangeArray1, "None");
	cls_StepElement_HArray1OfVolumeElementPurposeMember.def_static("get_type_name_", (const char * (*)()) &StepElement_HArray1OfVolumeElementPurposeMember::get_type_name, "None");
	cls_StepElement_HArray1OfVolumeElementPurposeMember.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_HArray1OfVolumeElementPurposeMember::get_type_descriptor, "None");
	cls_StepElement_HArray1OfVolumeElementPurposeMember.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_HArray1OfVolumeElementPurposeMember::*)() const ) &StepElement_HArray1OfVolumeElementPurposeMember::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_HArray2OfCurveElementPurposeMember.hxx
	py::class_<StepElement_HArray2OfCurveElementPurposeMember, opencascade::handle<StepElement_HArray2OfCurveElementPurposeMember>, StepElement_Array2OfCurveElementPurposeMember, Standard_Transient> cls_StepElement_HArray2OfCurveElementPurposeMember(mod, "StepElement_HArray2OfCurveElementPurposeMember", "None");
	cls_StepElement_HArray2OfCurveElementPurposeMember.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer>(), py::arg("theRowLow"), py::arg("theRowUpp"), py::arg("theColLow"), py::arg("theColUpp"));
	cls_StepElement_HArray2OfCurveElementPurposeMember.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const StepElement_Array2OfCurveElementPurposeMember::value_type &>(), py::arg("theRowLow"), py::arg("theRowUpp"), py::arg("theColLow"), py::arg("theColUpp"), py::arg("theValue"));
	cls_StepElement_HArray2OfCurveElementPurposeMember.def(py::init<const StepElement_Array2OfCurveElementPurposeMember &>(), py::arg("theOther"));
	cls_StepElement_HArray2OfCurveElementPurposeMember.def("Array2", (const StepElement_Array2OfCurveElementPurposeMember & (StepElement_HArray2OfCurveElementPurposeMember::*)() const ) &StepElement_HArray2OfCurveElementPurposeMember::Array2, "None");
	cls_StepElement_HArray2OfCurveElementPurposeMember.def("ChangeArray2", (StepElement_Array2OfCurveElementPurposeMember & (StepElement_HArray2OfCurveElementPurposeMember::*)()) &StepElement_HArray2OfCurveElementPurposeMember::ChangeArray2, "None");
	cls_StepElement_HArray2OfCurveElementPurposeMember.def_static("get_type_name_", (const char * (*)()) &StepElement_HArray2OfCurveElementPurposeMember::get_type_name, "None");
	cls_StepElement_HArray2OfCurveElementPurposeMember.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_HArray2OfCurveElementPurposeMember::get_type_descriptor, "None");
	cls_StepElement_HArray2OfCurveElementPurposeMember.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_HArray2OfCurveElementPurposeMember::*)() const ) &StepElement_HArray2OfCurveElementPurposeMember::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_HArray2OfSurfaceElementPurpose.hxx
	py::class_<StepElement_HArray2OfSurfaceElementPurpose, opencascade::handle<StepElement_HArray2OfSurfaceElementPurpose>, StepElement_Array2OfSurfaceElementPurpose, Standard_Transient> cls_StepElement_HArray2OfSurfaceElementPurpose(mod, "StepElement_HArray2OfSurfaceElementPurpose", "None");
	cls_StepElement_HArray2OfSurfaceElementPurpose.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer>(), py::arg("theRowLow"), py::arg("theRowUpp"), py::arg("theColLow"), py::arg("theColUpp"));
	cls_StepElement_HArray2OfSurfaceElementPurpose.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const StepElement_Array2OfSurfaceElementPurpose::value_type &>(), py::arg("theRowLow"), py::arg("theRowUpp"), py::arg("theColLow"), py::arg("theColUpp"), py::arg("theValue"));
	cls_StepElement_HArray2OfSurfaceElementPurpose.def(py::init<const StepElement_Array2OfSurfaceElementPurpose &>(), py::arg("theOther"));
	cls_StepElement_HArray2OfSurfaceElementPurpose.def("Array2", (const StepElement_Array2OfSurfaceElementPurpose & (StepElement_HArray2OfSurfaceElementPurpose::*)() const ) &StepElement_HArray2OfSurfaceElementPurpose::Array2, "None");
	cls_StepElement_HArray2OfSurfaceElementPurpose.def("ChangeArray2", (StepElement_Array2OfSurfaceElementPurpose & (StepElement_HArray2OfSurfaceElementPurpose::*)()) &StepElement_HArray2OfSurfaceElementPurpose::ChangeArray2, "None");
	cls_StepElement_HArray2OfSurfaceElementPurpose.def_static("get_type_name_", (const char * (*)()) &StepElement_HArray2OfSurfaceElementPurpose::get_type_name, "None");
	cls_StepElement_HArray2OfSurfaceElementPurpose.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_HArray2OfSurfaceElementPurpose::get_type_descriptor, "None");
	cls_StepElement_HArray2OfSurfaceElementPurpose.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_HArray2OfSurfaceElementPurpose::*)() const ) &StepElement_HArray2OfSurfaceElementPurpose::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\StepElement_HArray2OfSurfaceElementPurposeMember.hxx
	py::class_<StepElement_HArray2OfSurfaceElementPurposeMember, opencascade::handle<StepElement_HArray2OfSurfaceElementPurposeMember>, StepElement_Array2OfSurfaceElementPurposeMember, Standard_Transient> cls_StepElement_HArray2OfSurfaceElementPurposeMember(mod, "StepElement_HArray2OfSurfaceElementPurposeMember", "None");
	cls_StepElement_HArray2OfSurfaceElementPurposeMember.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer>(), py::arg("theRowLow"), py::arg("theRowUpp"), py::arg("theColLow"), py::arg("theColUpp"));
	cls_StepElement_HArray2OfSurfaceElementPurposeMember.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const StepElement_Array2OfSurfaceElementPurposeMember::value_type &>(), py::arg("theRowLow"), py::arg("theRowUpp"), py::arg("theColLow"), py::arg("theColUpp"), py::arg("theValue"));
	cls_StepElement_HArray2OfSurfaceElementPurposeMember.def(py::init<const StepElement_Array2OfSurfaceElementPurposeMember &>(), py::arg("theOther"));
	cls_StepElement_HArray2OfSurfaceElementPurposeMember.def("Array2", (const StepElement_Array2OfSurfaceElementPurposeMember & (StepElement_HArray2OfSurfaceElementPurposeMember::*)() const ) &StepElement_HArray2OfSurfaceElementPurposeMember::Array2, "None");
	cls_StepElement_HArray2OfSurfaceElementPurposeMember.def("ChangeArray2", (StepElement_Array2OfSurfaceElementPurposeMember & (StepElement_HArray2OfSurfaceElementPurposeMember::*)()) &StepElement_HArray2OfSurfaceElementPurposeMember::ChangeArray2, "None");
	cls_StepElement_HArray2OfSurfaceElementPurposeMember.def_static("get_type_name_", (const char * (*)()) &StepElement_HArray2OfSurfaceElementPurposeMember::get_type_name, "None");
	cls_StepElement_HArray2OfSurfaceElementPurposeMember.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &StepElement_HArray2OfSurfaceElementPurposeMember::get_type_descriptor, "None");
	cls_StepElement_HArray2OfSurfaceElementPurposeMember.def("DynamicType", (const opencascade::handle<Standard_Type> & (StepElement_HArray2OfSurfaceElementPurposeMember::*)() const ) &StepElement_HArray2OfSurfaceElementPurposeMember::DynamicType, "None");


}
