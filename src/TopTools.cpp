#include <pybind11/pybind11.h>
namespace py = pybind11;

#include <Standard_Handle.hxx>
PYBIND11_DECLARE_HOLDER_TYPE(T, opencascade::handle<T>, true);
PYBIND11_DECLARE_HOLDER_TYPE(T, T*);
using opencascade::handle;

// Deleter template for mixed holder types with public/hidden destructors.
template<typename T> struct Deleter { void operator() (T *o) const { delete o; } };

#include <NCollection_BaseList.hxx>
#include <Standard_Handle.hxx>
#include <NCollection_BaseAllocator.hxx>
#include <NCollection_List.hxx>
#include <Standard_TypeDef.hxx>
#include <TopTools_ListOfShape.hxx>
#include <NCollection_BaseMap.hxx>
#include <NCollection_DataMap.hxx>
#include <TopTools_DataMapOfIntegerListOfShape.hxx>
#include <TopoDS_Shape.hxx>
#include <TopTools_ShapeMapHasher.hxx>
#include <NCollection_Map.hxx>
#include <TopTools_MapOfShape.hxx>
#include <NCollection_IndexedMap.hxx>
#include <TopTools_IndexedMapOfShape.hxx>
#include <NCollection_IndexedDataMap.hxx>
#include <TopTools_IndexedDataMapOfShapeListOfShape.hxx>
#include <TopTools_DataMapOfShapeListOfShape.hxx>
#include <TopTools_DataMapOfShapeShape.hxx>
#include <TopTools_OrientedShapeMapHasher.hxx>
#include <TopTools_IndexedMapOfOrientedShape.hxx>
#include <TopTools_DataMapOfShapeInteger.hxx>
#include <TopTools_DataMapOfOrientedShapeInteger.hxx>
#include <TopTools_IndexedDataMapOfShapeShape.hxx>
#include <NCollection_BaseSequence.hxx>
#include <NCollection_Sequence.hxx>
#include <TopTools_SequenceOfShape.hxx>
#include <TopTools_DataMapOfShapeListOfInteger.hxx>
#include <NCollection_Array1.hxx>
#include <TopTools_Array1OfShape.hxx>
#include <Standard_Transient.hxx>
#include <Standard_Type.hxx>
#include <TopTools_HArray1OfShape.hxx>
#include <NCollection_Array2.hxx>
#include <TopTools_Array2OfShape.hxx>
#include <TopTools_HArray2OfShape.hxx>
#include <TopTools_DataMapOfIntegerShape.hxx>
#include <TopTools_DataMapOfShapeReal.hxx>
#include <TopAbs_ShapeEnum.hxx>
#include <Standard_Mutex.hxx>
#include <TopTools_MutexForShapeProvider.hxx>
#include <TopTools_HSequenceOfShape.hxx>
#include <TopLoc_Location.hxx>
#include <Standard_OStream.hxx>
#include <Standard_IStream.hxx>
#include <Message_ProgressIndicator.hxx>
#include <TopTools_LocationSet.hxx>
#include <TCollection_AsciiString.hxx>
#include <TopTools_ShapeSet.hxx>
#include <TopTools_Array1OfListOfShape.hxx>
#include <TopTools_HArray1OfListOfShape.hxx>
#include <TopTools_IndexedDataMapOfShapeAddress.hxx>
#include <TopTools.hxx>
#include <TopTools_DataMapOfOrientedShapeShape.hxx>
#include <TopTools_DataMapOfShapeSequenceOfShape.hxx>
#include <TopTools_LocationSetPtr.hxx>
#include <TopTools_MapOfOrientedShape.hxx>

PYBIND11_MODULE(TopTools, mod) {

	// IMPORT
	py::module::import("OCCT.NCollection");
	py::module::import("OCCT.Standard");
	py::module::import("OCCT.TopoDS");
	py::module::import("OCCT.TopAbs");
	py::module::import("OCCT.TopLoc");
	py::module::import("OCCT.Message");
	py::module::import("OCCT.TCollection");

	py::module other_mod;

	// IMPORT GUARDS

	// ENUMS

	// FUNCTIONS

	// CLASSES
	// C:\Miniconda\envs\occt\Library\include\opencascade\TopTools_ShapeMapHasher.hxx
	py::class_<TopTools_ShapeMapHasher, std::unique_ptr<TopTools_ShapeMapHasher, Deleter<TopTools_ShapeMapHasher>>> cls_TopTools_ShapeMapHasher(mod, "TopTools_ShapeMapHasher", "Hash tool, used for generating maps of shapes in topology.");
	cls_TopTools_ShapeMapHasher.def(py::init<>());
	cls_TopTools_ShapeMapHasher.def_static("HashCode_", (Standard_Integer (*)(const TopoDS_Shape &, const Standard_Integer)) &TopTools_ShapeMapHasher::HashCode, "Returns a HasCode value for the Key <K> in the range 0..Upper.", py::arg("S"), py::arg("Upper"));
	cls_TopTools_ShapeMapHasher.def_static("IsEqual_", (Standard_Boolean (*)(const TopoDS_Shape &, const TopoDS_Shape &)) &TopTools_ShapeMapHasher::IsEqual, "Returns True when the two keys are the same. Two same keys must have the same hashcode, the contrary is not necessary.", py::arg("S1"), py::arg("S2"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\TopTools_OrientedShapeMapHasher.hxx
	py::class_<TopTools_OrientedShapeMapHasher, std::unique_ptr<TopTools_OrientedShapeMapHasher, Deleter<TopTools_OrientedShapeMapHasher>>> cls_TopTools_OrientedShapeMapHasher(mod, "TopTools_OrientedShapeMapHasher", "None");
	cls_TopTools_OrientedShapeMapHasher.def(py::init<>());
	cls_TopTools_OrientedShapeMapHasher.def_static("HashCode_", (Standard_Integer (*)(const TopoDS_Shape &, const Standard_Integer)) &TopTools_OrientedShapeMapHasher::HashCode, "Returns a HasCode value for the Key <K> in the range 0..Upper.", py::arg("S"), py::arg("Upper"));
	cls_TopTools_OrientedShapeMapHasher.def_static("IsEqual_", (Standard_Boolean (*)(const TopoDS_Shape &, const TopoDS_Shape &)) &TopTools_OrientedShapeMapHasher::IsEqual, "Returns True when the two keys are equal. Two same keys must have the same hashcode, the contrary is not necessary.", py::arg("S1"), py::arg("S2"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_Array1.hxx
	py::class_<TopTools_Array1OfShape, std::unique_ptr<TopTools_Array1OfShape, Deleter<TopTools_Array1OfShape>>> cls_TopTools_Array1OfShape(mod, "TopTools_Array1OfShape", "Purpose: The class Array1 represents unidimensional arrays of fixed size known at run time. The range of the index is user defined. An array1 can be constructed with a 'C array'. This functionality is useful to call methods expecting an Array1. It allows to carry the bounds inside the arrays.");
	cls_TopTools_Array1OfShape.def(py::init<>());
	cls_TopTools_Array1OfShape.def(py::init<const Standard_Integer, const Standard_Integer>(), py::arg("theLower"), py::arg("theUpper"));
	cls_TopTools_Array1OfShape.def(py::init([] (const TopTools_Array1OfShape &other) {return new TopTools_Array1OfShape(other);}), "Copy constructor", py::arg("other"));
	// FIXME cls_TopTools_Array1OfShape.def(py::init<TopTools_Array1OfShape &&>(), py::arg("theOther"));
	cls_TopTools_Array1OfShape.def(py::init<const TopoDS_Shape &, const Standard_Integer, const Standard_Integer>(), py::arg("theBegin"), py::arg("theLower"), py::arg("theUpper"));
	cls_TopTools_Array1OfShape.def("begin", (TopTools_Array1OfShape::iterator (TopTools_Array1OfShape::*)() const ) &TopTools_Array1OfShape::begin, "Returns an iterator pointing to the first element in the array.");
	cls_TopTools_Array1OfShape.def("end", (TopTools_Array1OfShape::iterator (TopTools_Array1OfShape::*)() const ) &TopTools_Array1OfShape::end, "Returns an iterator referring to the past-the-end element in the array.");
	cls_TopTools_Array1OfShape.def("cbegin", (TopTools_Array1OfShape::const_iterator (TopTools_Array1OfShape::*)() const ) &TopTools_Array1OfShape::cbegin, "Returns a const iterator pointing to the first element in the array.");
	cls_TopTools_Array1OfShape.def("cend", (TopTools_Array1OfShape::const_iterator (TopTools_Array1OfShape::*)() const ) &TopTools_Array1OfShape::cend, "Returns a const iterator referring to the past-the-end element in the array.");
	cls_TopTools_Array1OfShape.def("Init", (void (TopTools_Array1OfShape::*)(const TopoDS_Shape &)) &TopTools_Array1OfShape::Init, "Initialise the items with theValue", py::arg("theValue"));
	cls_TopTools_Array1OfShape.def("Size", (Standard_Integer (TopTools_Array1OfShape::*)() const ) &TopTools_Array1OfShape::Size, "Size query");
	cls_TopTools_Array1OfShape.def("Length", (Standard_Integer (TopTools_Array1OfShape::*)() const ) &TopTools_Array1OfShape::Length, "Length query (the same)");
	cls_TopTools_Array1OfShape.def("IsEmpty", (Standard_Boolean (TopTools_Array1OfShape::*)() const ) &TopTools_Array1OfShape::IsEmpty, "Return TRUE if array has zero length.");
	cls_TopTools_Array1OfShape.def("Lower", (Standard_Integer (TopTools_Array1OfShape::*)() const ) &TopTools_Array1OfShape::Lower, "Lower bound");
	cls_TopTools_Array1OfShape.def("Upper", (Standard_Integer (TopTools_Array1OfShape::*)() const ) &TopTools_Array1OfShape::Upper, "Upper bound");
	cls_TopTools_Array1OfShape.def("IsDeletable", (Standard_Boolean (TopTools_Array1OfShape::*)() const ) &TopTools_Array1OfShape::IsDeletable, "myDeletable flag");
	cls_TopTools_Array1OfShape.def("IsAllocated", (Standard_Boolean (TopTools_Array1OfShape::*)() const ) &TopTools_Array1OfShape::IsAllocated, "IsAllocated flag - for naming compatibility");
	cls_TopTools_Array1OfShape.def("Assign", (TopTools_Array1OfShape & (TopTools_Array1OfShape::*)(const TopTools_Array1OfShape &)) &TopTools_Array1OfShape::Assign, "Assignment", py::arg("theOther"));
	// FIXME cls_TopTools_Array1OfShape.def("Move", (TopTools_Array1OfShape & (TopTools_Array1OfShape::*)(TopTools_Array1OfShape &&)) &TopTools_Array1OfShape::Move, "Move assignment", py::arg("theOther"));
	cls_TopTools_Array1OfShape.def("assign", (TopTools_Array1OfShape & (TopTools_Array1OfShape::*)(const TopTools_Array1OfShape &)) &TopTools_Array1OfShape::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	// FIXME cls_TopTools_Array1OfShape.def("assign", (TopTools_Array1OfShape & (TopTools_Array1OfShape::*)(TopTools_Array1OfShape &&)) &TopTools_Array1OfShape::operator=, py::is_operator(), "Move assignment operator.", py::arg("theOther"));
	cls_TopTools_Array1OfShape.def("First", (const TopoDS_Shape & (TopTools_Array1OfShape::*)() const ) &TopTools_Array1OfShape::First, "Returns first element");
	cls_TopTools_Array1OfShape.def("ChangeFirst", (TopoDS_Shape & (TopTools_Array1OfShape::*)()) &TopTools_Array1OfShape::ChangeFirst, "Returns first element");
	cls_TopTools_Array1OfShape.def("Last", (const TopoDS_Shape & (TopTools_Array1OfShape::*)() const ) &TopTools_Array1OfShape::Last, "Returns last element");
	cls_TopTools_Array1OfShape.def("ChangeLast", (TopoDS_Shape & (TopTools_Array1OfShape::*)()) &TopTools_Array1OfShape::ChangeLast, "Returns last element");
	cls_TopTools_Array1OfShape.def("Value", (const TopoDS_Shape & (TopTools_Array1OfShape::*)(const Standard_Integer) const ) &TopTools_Array1OfShape::Value, "Constant value access", py::arg("theIndex"));
	cls_TopTools_Array1OfShape.def("__call__", (const TopoDS_Shape & (TopTools_Array1OfShape::*)(const Standard_Integer) const ) &TopTools_Array1OfShape::operator(), py::is_operator(), "operator() - alias to Value", py::arg("theIndex"));
	cls_TopTools_Array1OfShape.def("ChangeValue", (TopoDS_Shape & (TopTools_Array1OfShape::*)(const Standard_Integer)) &TopTools_Array1OfShape::ChangeValue, "Variable value access", py::arg("theIndex"));
	cls_TopTools_Array1OfShape.def("__call__", (TopoDS_Shape & (TopTools_Array1OfShape::*)(const Standard_Integer)) &TopTools_Array1OfShape::operator(), py::is_operator(), "operator() - alias to ChangeValue", py::arg("theIndex"));
	cls_TopTools_Array1OfShape.def("SetValue", (void (TopTools_Array1OfShape::*)(const Standard_Integer, const TopoDS_Shape &)) &TopTools_Array1OfShape::SetValue, "Set value", py::arg("theIndex"), py::arg("theItem"));
	cls_TopTools_Array1OfShape.def("Resize", (void (TopTools_Array1OfShape::*)(const Standard_Integer, const Standard_Integer, const Standard_Boolean)) &TopTools_Array1OfShape::Resize, "Resizes the array to specified bounds. No re-allocation will be done if length of array does not change, but existing values will not be discarded if theToCopyData set to FALSE.", py::arg("theLower"), py::arg("theUpper"), py::arg("theToCopyData"));
	cls_TopTools_Array1OfShape.def("__iter__", [](const TopTools_Array1OfShape &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_Array2.hxx
	py::class_<TopTools_Array2OfShape, std::unique_ptr<TopTools_Array2OfShape, Deleter<TopTools_Array2OfShape>>> cls_TopTools_Array2OfShape(mod, "TopTools_Array2OfShape", "Purpose: The class Array2 represents bi-dimensional arrays of fixed size known at run time. The ranges of indices are user defined.");
	cls_TopTools_Array2OfShape.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer>(), py::arg("theRowLower"), py::arg("theRowUpper"), py::arg("theColLower"), py::arg("theColUpper"));
	cls_TopTools_Array2OfShape.def(py::init([] (const TopTools_Array2OfShape &other) {return new TopTools_Array2OfShape(other);}), "Copy constructor", py::arg("other"));
	cls_TopTools_Array2OfShape.def(py::init<const TopoDS_Shape &, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer>(), py::arg("theBegin"), py::arg("theRowLower"), py::arg("theRowUpper"), py::arg("theColLower"), py::arg("theColUpper"));
	cls_TopTools_Array2OfShape.def("Init", (void (TopTools_Array2OfShape::*)(const TopoDS_Shape &)) &TopTools_Array2OfShape::Init, "Initialise the values", py::arg("theValue"));
	cls_TopTools_Array2OfShape.def("Size", (Standard_Integer (TopTools_Array2OfShape::*)() const ) &TopTools_Array2OfShape::Size, "Size (number of items)");
	cls_TopTools_Array2OfShape.def("Length", (Standard_Integer (TopTools_Array2OfShape::*)() const ) &TopTools_Array2OfShape::Length, "Length (number of items)");
	cls_TopTools_Array2OfShape.def("RowLength", (Standard_Integer (TopTools_Array2OfShape::*)() const ) &TopTools_Array2OfShape::RowLength, "Returns length of the row, i.e. number of columns");
	cls_TopTools_Array2OfShape.def("ColLength", (Standard_Integer (TopTools_Array2OfShape::*)() const ) &TopTools_Array2OfShape::ColLength, "Returns length of the column, i.e. number of rows");
	cls_TopTools_Array2OfShape.def("LowerRow", (Standard_Integer (TopTools_Array2OfShape::*)() const ) &TopTools_Array2OfShape::LowerRow, "LowerRow");
	cls_TopTools_Array2OfShape.def("UpperRow", (Standard_Integer (TopTools_Array2OfShape::*)() const ) &TopTools_Array2OfShape::UpperRow, "UpperRow");
	cls_TopTools_Array2OfShape.def("LowerCol", (Standard_Integer (TopTools_Array2OfShape::*)() const ) &TopTools_Array2OfShape::LowerCol, "LowerCol");
	cls_TopTools_Array2OfShape.def("UpperCol", (Standard_Integer (TopTools_Array2OfShape::*)() const ) &TopTools_Array2OfShape::UpperCol, "UpperCol");
	cls_TopTools_Array2OfShape.def("IsDeletable", (Standard_Boolean (TopTools_Array2OfShape::*)() const ) &TopTools_Array2OfShape::IsDeletable, "myDeletable flag");
	cls_TopTools_Array2OfShape.def("Assign", (TopTools_Array2OfShape & (TopTools_Array2OfShape::*)(const TopTools_Array2OfShape &)) &TopTools_Array2OfShape::Assign, "Assignment", py::arg("theOther"));
	cls_TopTools_Array2OfShape.def("assign", (TopTools_Array2OfShape & (TopTools_Array2OfShape::*)(const TopTools_Array2OfShape &)) &TopTools_Array2OfShape::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	cls_TopTools_Array2OfShape.def("Value", (const TopoDS_Shape & (TopTools_Array2OfShape::*)(const Standard_Integer, const Standard_Integer) const ) &TopTools_Array2OfShape::Value, "Constant value access", py::arg("theRow"), py::arg("theCol"));
	cls_TopTools_Array2OfShape.def("__call__", (const TopoDS_Shape & (TopTools_Array2OfShape::*)(const Standard_Integer, const Standard_Integer) const ) &TopTools_Array2OfShape::operator(), py::is_operator(), "operator() - alias to ChangeValue", py::arg("theRow"), py::arg("theCol"));
	cls_TopTools_Array2OfShape.def("ChangeValue", (TopoDS_Shape & (TopTools_Array2OfShape::*)(const Standard_Integer, const Standard_Integer)) &TopTools_Array2OfShape::ChangeValue, "Variable value access", py::arg("theRow"), py::arg("theCol"));
	cls_TopTools_Array2OfShape.def("__call__", (TopoDS_Shape & (TopTools_Array2OfShape::*)(const Standard_Integer, const Standard_Integer)) &TopTools_Array2OfShape::operator(), py::is_operator(), "operator() - alias to ChangeValue", py::arg("theRow"), py::arg("theCol"));
	cls_TopTools_Array2OfShape.def("SetValue", (void (TopTools_Array2OfShape::*)(const Standard_Integer, const Standard_Integer, const TopoDS_Shape &)) &TopTools_Array2OfShape::SetValue, "SetValue", py::arg("theRow"), py::arg("theCol"), py::arg("theItem"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\TopTools_MutexForShapeProvider.hxx
	py::class_<TopTools_MutexForShapeProvider, std::unique_ptr<TopTools_MutexForShapeProvider, Deleter<TopTools_MutexForShapeProvider>>> cls_TopTools_MutexForShapeProvider(mod, "TopTools_MutexForShapeProvider", "Class TopTools_MutexForShapeProvider This class is used to create and store mutexes associated with shapes.");
	cls_TopTools_MutexForShapeProvider.def(py::init<>());
	cls_TopTools_MutexForShapeProvider.def("CreateMutexesForSubShapes", (void (TopTools_MutexForShapeProvider::*)(const TopoDS_Shape &, const TopAbs_ShapeEnum)) &TopTools_MutexForShapeProvider::CreateMutexesForSubShapes, "Creates and associates mutexes with each sub-shape of type theType in theShape.", py::arg("theShape"), py::arg("theType"));
	cls_TopTools_MutexForShapeProvider.def("CreateMutexForShape", (void (TopTools_MutexForShapeProvider::*)(const TopoDS_Shape &)) &TopTools_MutexForShapeProvider::CreateMutexForShape, "Creates and associates mutex with theShape", py::arg("theShape"));
	cls_TopTools_MutexForShapeProvider.def("GetMutex", (Standard_Mutex * (TopTools_MutexForShapeProvider::*)(const TopoDS_Shape &) const ) &TopTools_MutexForShapeProvider::GetMutex, "Returns pointer to mutex associated with theShape. In case when mutex not found returns NULL.", py::arg("theShape"));
	cls_TopTools_MutexForShapeProvider.def("RemoveAllMutexes", (void (TopTools_MutexForShapeProvider::*)()) &TopTools_MutexForShapeProvider::RemoveAllMutexes, "Removes all mutexes");

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_Sequence.hxx
	py::class_<TopTools_SequenceOfShape, std::unique_ptr<TopTools_SequenceOfShape, Deleter<TopTools_SequenceOfShape>>, NCollection_BaseSequence> cls_TopTools_SequenceOfShape(mod, "TopTools_SequenceOfShape", "Purpose: Definition of a sequence of elements indexed by an Integer in range of 1..n");
	cls_TopTools_SequenceOfShape.def(py::init<>());
	cls_TopTools_SequenceOfShape.def(py::init<const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("theAllocator"));
	cls_TopTools_SequenceOfShape.def(py::init([] (const TopTools_SequenceOfShape &other) {return new TopTools_SequenceOfShape(other);}), "Copy constructor", py::arg("other"));
	cls_TopTools_SequenceOfShape.def("begin", (TopTools_SequenceOfShape::iterator (TopTools_SequenceOfShape::*)() const ) &TopTools_SequenceOfShape::begin, "Returns an iterator pointing to the first element in the sequence.");
	cls_TopTools_SequenceOfShape.def("end", (TopTools_SequenceOfShape::iterator (TopTools_SequenceOfShape::*)() const ) &TopTools_SequenceOfShape::end, "Returns an iterator referring to the past-the-end element in the sequence.");
	cls_TopTools_SequenceOfShape.def("cbegin", (TopTools_SequenceOfShape::const_iterator (TopTools_SequenceOfShape::*)() const ) &TopTools_SequenceOfShape::cbegin, "Returns a const iterator pointing to the first element in the sequence.");
	cls_TopTools_SequenceOfShape.def("cend", (TopTools_SequenceOfShape::const_iterator (TopTools_SequenceOfShape::*)() const ) &TopTools_SequenceOfShape::cend, "Returns a const iterator referring to the past-the-end element in the sequence.");
	cls_TopTools_SequenceOfShape.def("Size", (Standard_Integer (TopTools_SequenceOfShape::*)() const ) &TopTools_SequenceOfShape::Size, "Number of items");
	cls_TopTools_SequenceOfShape.def("Length", (Standard_Integer (TopTools_SequenceOfShape::*)() const ) &TopTools_SequenceOfShape::Length, "Number of items");
	cls_TopTools_SequenceOfShape.def("Lower", (Standard_Integer (TopTools_SequenceOfShape::*)() const ) &TopTools_SequenceOfShape::Lower, "Method for consistency with other collections.");
	cls_TopTools_SequenceOfShape.def("Upper", (Standard_Integer (TopTools_SequenceOfShape::*)() const ) &TopTools_SequenceOfShape::Upper, "Method for consistency with other collections.");
	cls_TopTools_SequenceOfShape.def("IsEmpty", (Standard_Boolean (TopTools_SequenceOfShape::*)() const ) &TopTools_SequenceOfShape::IsEmpty, "Empty query");
	cls_TopTools_SequenceOfShape.def("Reverse", (void (TopTools_SequenceOfShape::*)()) &TopTools_SequenceOfShape::Reverse, "Reverse sequence");
	cls_TopTools_SequenceOfShape.def("Exchange", (void (TopTools_SequenceOfShape::*)(const Standard_Integer, const Standard_Integer)) &TopTools_SequenceOfShape::Exchange, "Exchange two members", py::arg("I"), py::arg("J"));
	cls_TopTools_SequenceOfShape.def_static("delNode_", (void (*)(NCollection_SeqNode *, opencascade::handle<NCollection_BaseAllocator> &)) &TopTools_SequenceOfShape::delNode, "Static deleter to be passed to BaseSequence", py::arg("theNode"), py::arg("theAl"));
	cls_TopTools_SequenceOfShape.def("Clear", [](TopTools_SequenceOfShape &self) -> void { return self.Clear(); });
	cls_TopTools_SequenceOfShape.def("Clear", (void (TopTools_SequenceOfShape::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &TopTools_SequenceOfShape::Clear, "Clear the items out, take a new allocator if non null", py::arg("theAllocator"));
	cls_TopTools_SequenceOfShape.def("Assign", (TopTools_SequenceOfShape & (TopTools_SequenceOfShape::*)(const TopTools_SequenceOfShape &)) &TopTools_SequenceOfShape::Assign, "Replace this sequence by the items of theOther. This method does not change the internal allocator.", py::arg("theOther"));
	cls_TopTools_SequenceOfShape.def("assign", (TopTools_SequenceOfShape & (TopTools_SequenceOfShape::*)(const TopTools_SequenceOfShape &)) &TopTools_SequenceOfShape::operator=, py::is_operator(), "Replacement operator", py::arg("theOther"));
	cls_TopTools_SequenceOfShape.def("Remove", (void (TopTools_SequenceOfShape::*)(TopTools_SequenceOfShape::Iterator &)) &TopTools_SequenceOfShape::Remove, "Remove one item", py::arg("thePosition"));
	cls_TopTools_SequenceOfShape.def("Remove", (void (TopTools_SequenceOfShape::*)(const Standard_Integer)) &TopTools_SequenceOfShape::Remove, "Remove one item", py::arg("theIndex"));
	cls_TopTools_SequenceOfShape.def("Remove", (void (TopTools_SequenceOfShape::*)(const Standard_Integer, const Standard_Integer)) &TopTools_SequenceOfShape::Remove, "Remove range of items", py::arg("theFromIndex"), py::arg("theToIndex"));
	cls_TopTools_SequenceOfShape.def("Append", (void (TopTools_SequenceOfShape::*)(const TopoDS_Shape &)) &TopTools_SequenceOfShape::Append, "Append one item", py::arg("theItem"));
	cls_TopTools_SequenceOfShape.def("Append", (void (TopTools_SequenceOfShape::*)(TopTools_SequenceOfShape &)) &TopTools_SequenceOfShape::Append, "Append another sequence (making it empty)", py::arg("theSeq"));
	cls_TopTools_SequenceOfShape.def("Prepend", (void (TopTools_SequenceOfShape::*)(const TopoDS_Shape &)) &TopTools_SequenceOfShape::Prepend, "Prepend one item", py::arg("theItem"));
	cls_TopTools_SequenceOfShape.def("Prepend", (void (TopTools_SequenceOfShape::*)(TopTools_SequenceOfShape &)) &TopTools_SequenceOfShape::Prepend, "Prepend another sequence (making it empty)", py::arg("theSeq"));
	cls_TopTools_SequenceOfShape.def("InsertBefore", (void (TopTools_SequenceOfShape::*)(const Standard_Integer, const TopoDS_Shape &)) &TopTools_SequenceOfShape::InsertBefore, "InsertBefore theIndex theItem", py::arg("theIndex"), py::arg("theItem"));
	cls_TopTools_SequenceOfShape.def("InsertBefore", (void (TopTools_SequenceOfShape::*)(const Standard_Integer, TopTools_SequenceOfShape &)) &TopTools_SequenceOfShape::InsertBefore, "InsertBefore theIndex another sequence", py::arg("theIndex"), py::arg("theSeq"));
	cls_TopTools_SequenceOfShape.def("InsertAfter", (void (TopTools_SequenceOfShape::*)(TopTools_SequenceOfShape::Iterator &, const TopoDS_Shape &)) &TopTools_SequenceOfShape::InsertAfter, "InsertAfter the position of iterator", py::arg("thePosition"), py::arg("theItem"));
	cls_TopTools_SequenceOfShape.def("InsertAfter", (void (TopTools_SequenceOfShape::*)(const Standard_Integer, TopTools_SequenceOfShape &)) &TopTools_SequenceOfShape::InsertAfter, "InsertAfter theIndex theItem", py::arg("theIndex"), py::arg("theSeq"));
	cls_TopTools_SequenceOfShape.def("InsertAfter", (void (TopTools_SequenceOfShape::*)(const Standard_Integer, const TopoDS_Shape &)) &TopTools_SequenceOfShape::InsertAfter, "InsertAfter theIndex another sequence", py::arg("theIndex"), py::arg("theItem"));
	cls_TopTools_SequenceOfShape.def("Split", (void (TopTools_SequenceOfShape::*)(const Standard_Integer, TopTools_SequenceOfShape &)) &TopTools_SequenceOfShape::Split, "Split in two sequences", py::arg("theIndex"), py::arg("theSeq"));
	cls_TopTools_SequenceOfShape.def("First", (const TopoDS_Shape & (TopTools_SequenceOfShape::*)() const ) &TopTools_SequenceOfShape::First, "First item access");
	cls_TopTools_SequenceOfShape.def("ChangeFirst", (TopoDS_Shape & (TopTools_SequenceOfShape::*)()) &TopTools_SequenceOfShape::ChangeFirst, "First item access");
	cls_TopTools_SequenceOfShape.def("Last", (const TopoDS_Shape & (TopTools_SequenceOfShape::*)() const ) &TopTools_SequenceOfShape::Last, "Last item access");
	cls_TopTools_SequenceOfShape.def("ChangeLast", (TopoDS_Shape & (TopTools_SequenceOfShape::*)()) &TopTools_SequenceOfShape::ChangeLast, "Last item access");
	cls_TopTools_SequenceOfShape.def("Value", (const TopoDS_Shape & (TopTools_SequenceOfShape::*)(const Standard_Integer) const ) &TopTools_SequenceOfShape::Value, "Constant item access by theIndex", py::arg("theIndex"));
	cls_TopTools_SequenceOfShape.def("__call__", (const TopoDS_Shape & (TopTools_SequenceOfShape::*)(const Standard_Integer) const ) &TopTools_SequenceOfShape::operator(), py::is_operator(), "Constant operator()", py::arg("theIndex"));
	cls_TopTools_SequenceOfShape.def("ChangeValue", (TopoDS_Shape & (TopTools_SequenceOfShape::*)(const Standard_Integer)) &TopTools_SequenceOfShape::ChangeValue, "Variable item access by theIndex", py::arg("theIndex"));
	cls_TopTools_SequenceOfShape.def("__call__", (TopoDS_Shape & (TopTools_SequenceOfShape::*)(const Standard_Integer)) &TopTools_SequenceOfShape::operator(), py::is_operator(), "Variable operator()", py::arg("theIndex"));
	cls_TopTools_SequenceOfShape.def("SetValue", (void (TopTools_SequenceOfShape::*)(const Standard_Integer, const TopoDS_Shape &)) &TopTools_SequenceOfShape::SetValue, "Set item value by theIndex", py::arg("theIndex"), py::arg("theItem"));
	cls_TopTools_SequenceOfShape.def("__iter__", [](const TopTools_SequenceOfShape &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\TopTools_LocationSet.hxx
	py::class_<TopTools_LocationSet, std::unique_ptr<TopTools_LocationSet, Deleter<TopTools_LocationSet>>> cls_TopTools_LocationSet(mod, "TopTools_LocationSet", "The class LocationSet stores a set of location in a relocatable state.");
	cls_TopTools_LocationSet.def(py::init<>());
	cls_TopTools_LocationSet.def("Clear", (void (TopTools_LocationSet::*)()) &TopTools_LocationSet::Clear, "Clears the content of the set.");
	cls_TopTools_LocationSet.def("Add", (Standard_Integer (TopTools_LocationSet::*)(const TopLoc_Location &)) &TopTools_LocationSet::Add, "Incorporate a new Location in the set and returns its index.", py::arg("L"));
	cls_TopTools_LocationSet.def("Location", (const TopLoc_Location & (TopTools_LocationSet::*)(const Standard_Integer) const ) &TopTools_LocationSet::Location, "Returns the location of index <I>.", py::arg("I"));
	cls_TopTools_LocationSet.def("Index", (Standard_Integer (TopTools_LocationSet::*)(const TopLoc_Location &) const ) &TopTools_LocationSet::Index, "Returns the index of <L>.", py::arg("L"));
	// FIXME cls_TopTools_LocationSet.def("Dump", (void (TopTools_LocationSet::*)(Standard_OStream &) const ) &TopTools_LocationSet::Dump, "Dumps the content of me on the stream <OS>.", py::arg("OS"));
	cls_TopTools_LocationSet.def("Write", (void (TopTools_LocationSet::*)(Standard_OStream &) const ) &TopTools_LocationSet::Write, "Writes the content of me on the stream <OS> in a format that can be read back by Read.", py::arg("OS"));
	cls_TopTools_LocationSet.def("Read", (void (TopTools_LocationSet::*)(Standard_IStream &)) &TopTools_LocationSet::Read, "Reads the content of me from the stream <IS>. me is first cleared.", py::arg("IS"));
	cls_TopTools_LocationSet.def("SetProgress", (void (TopTools_LocationSet::*)(const opencascade::handle<Message_ProgressIndicator> &)) &TopTools_LocationSet::SetProgress, "None", py::arg("PR"));
	cls_TopTools_LocationSet.def("GetProgress", (opencascade::handle<Message_ProgressIndicator> (TopTools_LocationSet::*)() const ) &TopTools_LocationSet::GetProgress, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\TopTools_ShapeSet.hxx
	py::class_<TopTools_ShapeSet, std::unique_ptr<TopTools_ShapeSet, Deleter<TopTools_ShapeSet>>> cls_TopTools_ShapeSet(mod, "TopTools_ShapeSet", "A ShapeSets contains a Shape and all its sub-shapes and locations. It can be dump, write and read.");
	cls_TopTools_ShapeSet.def(py::init<>());
	cls_TopTools_ShapeSet.def("SetFormatNb", (void (TopTools_ShapeSet::*)(const Standard_Integer)) &TopTools_ShapeSet::SetFormatNb, "None", py::arg("theFormatNb"));
	cls_TopTools_ShapeSet.def("FormatNb", (Standard_Integer (TopTools_ShapeSet::*)() const ) &TopTools_ShapeSet::FormatNb, "two formats available for the moment: First: does not write CurveOnSurface UV Points into the file on reading calls Check() method. Second: stores CurveOnSurface UV Points. On reading format is recognized from Version string.");
	cls_TopTools_ShapeSet.def("Clear", (void (TopTools_ShapeSet::*)()) &TopTools_ShapeSet::Clear, "Clears the content of the set. This method can be redefined.");
	cls_TopTools_ShapeSet.def("Add", (Standard_Integer (TopTools_ShapeSet::*)(const TopoDS_Shape &)) &TopTools_ShapeSet::Add, "Stores <S> and its sub-shape. Returns the index of <S>. The method AddGeometry is called on each sub-shape.", py::arg("S"));
	cls_TopTools_ShapeSet.def("Shape", (const TopoDS_Shape & (TopTools_ShapeSet::*)(const Standard_Integer) const ) &TopTools_ShapeSet::Shape, "Returns the sub-shape of index <I>.", py::arg("I"));
	cls_TopTools_ShapeSet.def("Index", (Standard_Integer (TopTools_ShapeSet::*)(const TopoDS_Shape &) const ) &TopTools_ShapeSet::Index, "Returns the index of <S>.", py::arg("S"));
	cls_TopTools_ShapeSet.def("Locations", (const TopTools_LocationSet & (TopTools_ShapeSet::*)() const ) &TopTools_ShapeSet::Locations, "None");
	cls_TopTools_ShapeSet.def("ChangeLocations", (TopTools_LocationSet & (TopTools_ShapeSet::*)()) &TopTools_ShapeSet::ChangeLocations, "None");
	cls_TopTools_ShapeSet.def("DumpExtent", (Standard_OStream & (TopTools_ShapeSet::*)(Standard_OStream &) const ) &TopTools_ShapeSet::DumpExtent, "Dumps the number of objects in me on the stream <OS>. (Number of shapes of each type)", py::arg("OS"));
	cls_TopTools_ShapeSet.def("DumpExtent", (void (TopTools_ShapeSet::*)(TCollection_AsciiString &) const ) &TopTools_ShapeSet::DumpExtent, "Dumps the number of objects in me in the string S (Number of shapes of each type)", py::arg("S"));
	// FIXME cls_TopTools_ShapeSet.def("Dump", (void (TopTools_ShapeSet::*)(Standard_OStream &) const ) &TopTools_ShapeSet::Dump, "Dumps the content of me on the stream <OS>.", py::arg("OS"));
	cls_TopTools_ShapeSet.def("Write", (void (TopTools_ShapeSet::*)(Standard_OStream &)) &TopTools_ShapeSet::Write, "Writes the content of me on the stream <OS> in a format that can be read back by Read.", py::arg("OS"));
	cls_TopTools_ShapeSet.def("Read", (void (TopTools_ShapeSet::*)(Standard_IStream &)) &TopTools_ShapeSet::Read, "Reads the content of me from the stream <IS>. me is first cleared.", py::arg("IS"));
	// FIXME cls_TopTools_ShapeSet.def("Dump", (void (TopTools_ShapeSet::*)(const TopoDS_Shape &, Standard_OStream &) const ) &TopTools_ShapeSet::Dump, "Dumps on <OS> the shape <S>. Dumps the orientation, the index of the TShape and the index of the Location.", py::arg("S"), py::arg("OS"));
	cls_TopTools_ShapeSet.def("Write", (void (TopTools_ShapeSet::*)(const TopoDS_Shape &, Standard_OStream &) const ) &TopTools_ShapeSet::Write, "Writes on <OS> the shape <S>. Writes the orientation, the index of the TShape and the index of the Location.", py::arg("S"), py::arg("OS"));
	cls_TopTools_ShapeSet.def("Read", (void (TopTools_ShapeSet::*)(TopoDS_Shape &, Standard_IStream &) const ) &TopTools_ShapeSet::Read, "Reads from <IS> a shape and returns it in S.", py::arg("S"), py::arg("IS"));
	cls_TopTools_ShapeSet.def("AddGeometry", (void (TopTools_ShapeSet::*)(const TopoDS_Shape &)) &TopTools_ShapeSet::AddGeometry, "Stores the geometry of <S>.", py::arg("S"));
	cls_TopTools_ShapeSet.def("DumpGeometry", (void (TopTools_ShapeSet::*)(Standard_OStream &) const ) &TopTools_ShapeSet::DumpGeometry, "Dumps the geometry of me on the stream <OS>.", py::arg("OS"));
	cls_TopTools_ShapeSet.def("WriteGeometry", (void (TopTools_ShapeSet::*)(Standard_OStream &)) &TopTools_ShapeSet::WriteGeometry, "Writes the geometry of me on the stream <OS> in a format that can be read back by Read.", py::arg("OS"));
	cls_TopTools_ShapeSet.def("ReadGeometry", (void (TopTools_ShapeSet::*)(Standard_IStream &)) &TopTools_ShapeSet::ReadGeometry, "Reads the geometry of me from the stream <IS>.", py::arg("IS"));
	cls_TopTools_ShapeSet.def("DumpGeometry", (void (TopTools_ShapeSet::*)(const TopoDS_Shape &, Standard_OStream &) const ) &TopTools_ShapeSet::DumpGeometry, "Dumps the geometry of <S> on the stream <OS>.", py::arg("S"), py::arg("OS"));
	cls_TopTools_ShapeSet.def("WriteGeometry", (void (TopTools_ShapeSet::*)(const TopoDS_Shape &, Standard_OStream &) const ) &TopTools_ShapeSet::WriteGeometry, "Writes the geometry of <S> on the stream <OS> in a format that can be read back by Read.", py::arg("S"), py::arg("OS"));
	cls_TopTools_ShapeSet.def("ReadGeometry", (void (TopTools_ShapeSet::*)(const TopAbs_ShapeEnum, Standard_IStream &, TopoDS_Shape &)) &TopTools_ShapeSet::ReadGeometry, "Reads the geometry of a shape of type <T> from the stream <IS> and returns it in <S>.", py::arg("T"), py::arg("IS"), py::arg("S"));
	cls_TopTools_ShapeSet.def("AddShapes", (void (TopTools_ShapeSet::*)(TopoDS_Shape &, const TopoDS_Shape &)) &TopTools_ShapeSet::AddShapes, "Inserts the shape <S2> in the shape <S1>. This method must be redefined to use the correct builder.", py::arg("S1"), py::arg("S2"));
	cls_TopTools_ShapeSet.def("Check", (void (TopTools_ShapeSet::*)(const TopAbs_ShapeEnum, TopoDS_Shape &)) &TopTools_ShapeSet::Check, "This method is called after each new completed shape. <T> is the type. <S> is the shape. In this class it does nothing, but it gives the opportunity in derived classes to perform extra treatment on shapes.", py::arg("T"), py::arg("S"));
	cls_TopTools_ShapeSet.def("NbShapes", (Standard_Integer (TopTools_ShapeSet::*)() const ) &TopTools_ShapeSet::NbShapes, "Returns number of shapes read from file.");
	cls_TopTools_ShapeSet.def("SetProgress", (void (TopTools_ShapeSet::*)(const opencascade::handle<Message_ProgressIndicator> &)) &TopTools_ShapeSet::SetProgress, "None", py::arg("PR"));
	cls_TopTools_ShapeSet.def("GetProgress", (opencascade::handle<Message_ProgressIndicator> (TopTools_ShapeSet::*)() const ) &TopTools_ShapeSet::GetProgress, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_Array1.hxx
	py::class_<TopTools_Array1OfListOfShape, std::unique_ptr<TopTools_Array1OfListOfShape, Deleter<TopTools_Array1OfListOfShape>>> cls_TopTools_Array1OfListOfShape(mod, "TopTools_Array1OfListOfShape", "Purpose: The class Array1 represents unidimensional arrays of fixed size known at run time. The range of the index is user defined. An array1 can be constructed with a 'C array'. This functionality is useful to call methods expecting an Array1. It allows to carry the bounds inside the arrays.");
	cls_TopTools_Array1OfListOfShape.def(py::init<>());
	cls_TopTools_Array1OfListOfShape.def(py::init<const Standard_Integer, const Standard_Integer>(), py::arg("theLower"), py::arg("theUpper"));
	cls_TopTools_Array1OfListOfShape.def(py::init([] (const TopTools_Array1OfListOfShape &other) {return new TopTools_Array1OfListOfShape(other);}), "Copy constructor", py::arg("other"));
	// FIXME cls_TopTools_Array1OfListOfShape.def(py::init<TopTools_Array1OfListOfShape &&>(), py::arg("theOther"));
	cls_TopTools_Array1OfListOfShape.def(py::init<const TopTools_ListOfShape &, const Standard_Integer, const Standard_Integer>(), py::arg("theBegin"), py::arg("theLower"), py::arg("theUpper"));
	cls_TopTools_Array1OfListOfShape.def("begin", (TopTools_Array1OfListOfShape::iterator (TopTools_Array1OfListOfShape::*)() const ) &TopTools_Array1OfListOfShape::begin, "Returns an iterator pointing to the first element in the array.");
	cls_TopTools_Array1OfListOfShape.def("end", (TopTools_Array1OfListOfShape::iterator (TopTools_Array1OfListOfShape::*)() const ) &TopTools_Array1OfListOfShape::end, "Returns an iterator referring to the past-the-end element in the array.");
	cls_TopTools_Array1OfListOfShape.def("cbegin", (TopTools_Array1OfListOfShape::const_iterator (TopTools_Array1OfListOfShape::*)() const ) &TopTools_Array1OfListOfShape::cbegin, "Returns a const iterator pointing to the first element in the array.");
	cls_TopTools_Array1OfListOfShape.def("cend", (TopTools_Array1OfListOfShape::const_iterator (TopTools_Array1OfListOfShape::*)() const ) &TopTools_Array1OfListOfShape::cend, "Returns a const iterator referring to the past-the-end element in the array.");
	cls_TopTools_Array1OfListOfShape.def("Init", (void (TopTools_Array1OfListOfShape::*)(const TopTools_ListOfShape &)) &TopTools_Array1OfListOfShape::Init, "Initialise the items with theValue", py::arg("theValue"));
	cls_TopTools_Array1OfListOfShape.def("Size", (Standard_Integer (TopTools_Array1OfListOfShape::*)() const ) &TopTools_Array1OfListOfShape::Size, "Size query");
	cls_TopTools_Array1OfListOfShape.def("Length", (Standard_Integer (TopTools_Array1OfListOfShape::*)() const ) &TopTools_Array1OfListOfShape::Length, "Length query (the same)");
	cls_TopTools_Array1OfListOfShape.def("IsEmpty", (Standard_Boolean (TopTools_Array1OfListOfShape::*)() const ) &TopTools_Array1OfListOfShape::IsEmpty, "Return TRUE if array has zero length.");
	cls_TopTools_Array1OfListOfShape.def("Lower", (Standard_Integer (TopTools_Array1OfListOfShape::*)() const ) &TopTools_Array1OfListOfShape::Lower, "Lower bound");
	cls_TopTools_Array1OfListOfShape.def("Upper", (Standard_Integer (TopTools_Array1OfListOfShape::*)() const ) &TopTools_Array1OfListOfShape::Upper, "Upper bound");
	cls_TopTools_Array1OfListOfShape.def("IsDeletable", (Standard_Boolean (TopTools_Array1OfListOfShape::*)() const ) &TopTools_Array1OfListOfShape::IsDeletable, "myDeletable flag");
	cls_TopTools_Array1OfListOfShape.def("IsAllocated", (Standard_Boolean (TopTools_Array1OfListOfShape::*)() const ) &TopTools_Array1OfListOfShape::IsAllocated, "IsAllocated flag - for naming compatibility");
	cls_TopTools_Array1OfListOfShape.def("Assign", (TopTools_Array1OfListOfShape & (TopTools_Array1OfListOfShape::*)(const TopTools_Array1OfListOfShape &)) &TopTools_Array1OfListOfShape::Assign, "Assignment", py::arg("theOther"));
	// FIXME cls_TopTools_Array1OfListOfShape.def("Move", (TopTools_Array1OfListOfShape & (TopTools_Array1OfListOfShape::*)(TopTools_Array1OfListOfShape &&)) &TopTools_Array1OfListOfShape::Move, "Move assignment", py::arg("theOther"));
	cls_TopTools_Array1OfListOfShape.def("assign", (TopTools_Array1OfListOfShape & (TopTools_Array1OfListOfShape::*)(const TopTools_Array1OfListOfShape &)) &TopTools_Array1OfListOfShape::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	// FIXME cls_TopTools_Array1OfListOfShape.def("assign", (TopTools_Array1OfListOfShape & (TopTools_Array1OfListOfShape::*)(TopTools_Array1OfListOfShape &&)) &TopTools_Array1OfListOfShape::operator=, py::is_operator(), "Move assignment operator.", py::arg("theOther"));
	cls_TopTools_Array1OfListOfShape.def("First", (const TopTools_ListOfShape & (TopTools_Array1OfListOfShape::*)() const ) &TopTools_Array1OfListOfShape::First, "Returns first element");
	cls_TopTools_Array1OfListOfShape.def("ChangeFirst", (TopTools_ListOfShape & (TopTools_Array1OfListOfShape::*)()) &TopTools_Array1OfListOfShape::ChangeFirst, "Returns first element");
	cls_TopTools_Array1OfListOfShape.def("Last", (const TopTools_ListOfShape & (TopTools_Array1OfListOfShape::*)() const ) &TopTools_Array1OfListOfShape::Last, "Returns last element");
	cls_TopTools_Array1OfListOfShape.def("ChangeLast", (TopTools_ListOfShape & (TopTools_Array1OfListOfShape::*)()) &TopTools_Array1OfListOfShape::ChangeLast, "Returns last element");
	cls_TopTools_Array1OfListOfShape.def("Value", (const TopTools_ListOfShape & (TopTools_Array1OfListOfShape::*)(const Standard_Integer) const ) &TopTools_Array1OfListOfShape::Value, "Constant value access", py::arg("theIndex"));
	cls_TopTools_Array1OfListOfShape.def("__call__", (const TopTools_ListOfShape & (TopTools_Array1OfListOfShape::*)(const Standard_Integer) const ) &TopTools_Array1OfListOfShape::operator(), py::is_operator(), "operator() - alias to Value", py::arg("theIndex"));
	cls_TopTools_Array1OfListOfShape.def("ChangeValue", (TopTools_ListOfShape & (TopTools_Array1OfListOfShape::*)(const Standard_Integer)) &TopTools_Array1OfListOfShape::ChangeValue, "Variable value access", py::arg("theIndex"));
	cls_TopTools_Array1OfListOfShape.def("__call__", (TopTools_ListOfShape & (TopTools_Array1OfListOfShape::*)(const Standard_Integer)) &TopTools_Array1OfListOfShape::operator(), py::is_operator(), "operator() - alias to ChangeValue", py::arg("theIndex"));
	cls_TopTools_Array1OfListOfShape.def("SetValue", (void (TopTools_Array1OfListOfShape::*)(const Standard_Integer, const TopTools_ListOfShape &)) &TopTools_Array1OfListOfShape::SetValue, "Set value", py::arg("theIndex"), py::arg("theItem"));
	cls_TopTools_Array1OfListOfShape.def("Resize", (void (TopTools_Array1OfListOfShape::*)(const Standard_Integer, const Standard_Integer, const Standard_Boolean)) &TopTools_Array1OfListOfShape::Resize, "Resizes the array to specified bounds. No re-allocation will be done if length of array does not change, but existing values will not be discarded if theToCopyData set to FALSE.", py::arg("theLower"), py::arg("theUpper"), py::arg("theToCopyData"));
	cls_TopTools_Array1OfListOfShape.def("__iter__", [](const TopTools_Array1OfListOfShape &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\TopTools.hxx
	py::class_<TopTools, std::unique_ptr<TopTools, Deleter<TopTools>>> cls_TopTools(mod, "TopTools", "The TopTools package provides utilities for the topological data structure.");
	cls_TopTools.def(py::init<>());
	// FIXME cls_TopTools.def_static("Dump_", (void (*)(const TopoDS_Shape &, Standard_OStream &)) &TopTools::Dump, "A set of Shapes. Can be dump, wrote or read. Dumps the topological structure of <Sh> on the stream <S>.", py::arg("Sh"), py::arg("S"));
	cls_TopTools.def_static("Dummy_", (void (*)(const Standard_Integer)) &TopTools::Dummy, "This is to bypass an extraction bug. It will force the inclusion of Standard_Integer.hxx itself including Standard_OStream.hxx at the correct position.", py::arg("I"));

	other_mod = py::module::import("OCCT.TopoDS");
	if (py::hasattr(other_mod, "TopoDS_ListOfShape")) {
		mod.attr("TopTools_ListOfShape") = other_mod.attr("TopoDS_ListOfShape");
	}

	other_mod = py::module::import("OCCT.TopoDS");
	if (py::hasattr(other_mod, "TopoDS_ListIteratorOfListOfShape")) {
		mod.attr("TopTools_ListIteratorOfListOfShape") = other_mod.attr("TopoDS_ListIteratorOfListOfShape");
	}

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_DataMap.hxx
	py::class_<TopTools_DataMapOfIntegerListOfShape, std::unique_ptr<TopTools_DataMapOfIntegerListOfShape, Deleter<TopTools_DataMapOfIntegerListOfShape>>, NCollection_BaseMap> cls_TopTools_DataMapOfIntegerListOfShape(mod, "TopTools_DataMapOfIntegerListOfShape", "Purpose: The DataMap is a Map to store keys with associated Items. See Map from NCollection for a discussion about the number of buckets.");
	cls_TopTools_DataMapOfIntegerListOfShape.def(py::init<>());
	cls_TopTools_DataMapOfIntegerListOfShape.def(py::init<const Standard_Integer>(), py::arg("NbBuckets"));
	cls_TopTools_DataMapOfIntegerListOfShape.def(py::init<const Standard_Integer, const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("NbBuckets"), py::arg("theAllocator"));
	cls_TopTools_DataMapOfIntegerListOfShape.def(py::init([] (const TopTools_DataMapOfIntegerListOfShape &other) {return new TopTools_DataMapOfIntegerListOfShape(other);}), "Copy constructor", py::arg("other"));
	cls_TopTools_DataMapOfIntegerListOfShape.def("begin", (TopTools_DataMapOfIntegerListOfShape::iterator (TopTools_DataMapOfIntegerListOfShape::*)() const ) &TopTools_DataMapOfIntegerListOfShape::begin, "Returns an iterator pointing to the first element in the map.");
	cls_TopTools_DataMapOfIntegerListOfShape.def("end", (TopTools_DataMapOfIntegerListOfShape::iterator (TopTools_DataMapOfIntegerListOfShape::*)() const ) &TopTools_DataMapOfIntegerListOfShape::end, "Returns an iterator referring to the past-the-end element in the map.");
	cls_TopTools_DataMapOfIntegerListOfShape.def("cbegin", (TopTools_DataMapOfIntegerListOfShape::const_iterator (TopTools_DataMapOfIntegerListOfShape::*)() const ) &TopTools_DataMapOfIntegerListOfShape::cbegin, "Returns a const iterator pointing to the first element in the map.");
	cls_TopTools_DataMapOfIntegerListOfShape.def("cend", (TopTools_DataMapOfIntegerListOfShape::const_iterator (TopTools_DataMapOfIntegerListOfShape::*)() const ) &TopTools_DataMapOfIntegerListOfShape::cend, "Returns a const iterator referring to the past-the-end element in the map.");
	cls_TopTools_DataMapOfIntegerListOfShape.def("Exchange", (void (TopTools_DataMapOfIntegerListOfShape::*)(TopTools_DataMapOfIntegerListOfShape &)) &TopTools_DataMapOfIntegerListOfShape::Exchange, "Exchange the content of two maps without re-allocations. Notice that allocators will be swapped as well!", py::arg("theOther"));
	cls_TopTools_DataMapOfIntegerListOfShape.def("Assign", (TopTools_DataMapOfIntegerListOfShape & (TopTools_DataMapOfIntegerListOfShape::*)(const TopTools_DataMapOfIntegerListOfShape &)) &TopTools_DataMapOfIntegerListOfShape::Assign, "Assignment. This method does not change the internal allocator.", py::arg("theOther"));
	cls_TopTools_DataMapOfIntegerListOfShape.def("assign", (TopTools_DataMapOfIntegerListOfShape & (TopTools_DataMapOfIntegerListOfShape::*)(const TopTools_DataMapOfIntegerListOfShape &)) &TopTools_DataMapOfIntegerListOfShape::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	cls_TopTools_DataMapOfIntegerListOfShape.def("ReSize", (void (TopTools_DataMapOfIntegerListOfShape::*)(const Standard_Integer)) &TopTools_DataMapOfIntegerListOfShape::ReSize, "ReSize", py::arg("N"));
	cls_TopTools_DataMapOfIntegerListOfShape.def("Bind", (Standard_Boolean (TopTools_DataMapOfIntegerListOfShape::*)(const Standard_Integer &, const TopTools_ListOfShape &)) &TopTools_DataMapOfIntegerListOfShape::Bind, "Bind binds Item to Key in map. Returns Standard_True if Key was not exist in the map. If the Key was already bound, the Item will be rebinded and Standard_False will be returned.", py::arg("theKey"), py::arg("theItem"));
	// FIXME cls_TopTools_DataMapOfIntegerListOfShape.def("Bound", (TopTools_ListOfShape * (TopTools_DataMapOfIntegerListOfShape::*)(const Standard_Integer &, const TopTools_ListOfShape &)) &TopTools_DataMapOfIntegerListOfShape::Bound, "Bound binds Item to Key in map. Returns modifiable Item", py::arg("theKey"), py::arg("theItem"));
	cls_TopTools_DataMapOfIntegerListOfShape.def("IsBound", (Standard_Boolean (TopTools_DataMapOfIntegerListOfShape::*)(const Standard_Integer &) const ) &TopTools_DataMapOfIntegerListOfShape::IsBound, "IsBound", py::arg("theKey"));
	cls_TopTools_DataMapOfIntegerListOfShape.def("UnBind", (Standard_Boolean (TopTools_DataMapOfIntegerListOfShape::*)(const Standard_Integer &)) &TopTools_DataMapOfIntegerListOfShape::UnBind, "UnBind removes Item Key pair from map", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfIntegerListOfShape.def("Seek", (const TopTools_ListOfShape * (TopTools_DataMapOfIntegerListOfShape::*)(const Standard_Integer &) const ) &TopTools_DataMapOfIntegerListOfShape::Seek, "Seek returns pointer to Item by Key. Returns NULL is Key was not bound.", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfIntegerListOfShape.def("Find", (const TopTools_ListOfShape & (TopTools_DataMapOfIntegerListOfShape::*)(const Standard_Integer &) const ) &TopTools_DataMapOfIntegerListOfShape::Find, "Find returns the Item for Key. Raises if Key was not bound", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfIntegerListOfShape.def("Find", (Standard_Boolean (TopTools_DataMapOfIntegerListOfShape::*)(const Standard_Integer &, TopTools_ListOfShape &) const ) &TopTools_DataMapOfIntegerListOfShape::Find, "Find Item for key with copying.", py::arg("theKey"), py::arg("theValue"));
	cls_TopTools_DataMapOfIntegerListOfShape.def("__call__", (const TopTools_ListOfShape & (TopTools_DataMapOfIntegerListOfShape::*)(const Standard_Integer &) const ) &TopTools_DataMapOfIntegerListOfShape::operator(), py::is_operator(), "operator ()", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfIntegerListOfShape.def("ChangeSeek", (TopTools_ListOfShape * (TopTools_DataMapOfIntegerListOfShape::*)(const Standard_Integer &)) &TopTools_DataMapOfIntegerListOfShape::ChangeSeek, "ChangeSeek returns modifiable pointer to Item by Key. Returns NULL is Key was not bound.", py::arg("theKey"));
	cls_TopTools_DataMapOfIntegerListOfShape.def("ChangeFind", (TopTools_ListOfShape & (TopTools_DataMapOfIntegerListOfShape::*)(const Standard_Integer &)) &TopTools_DataMapOfIntegerListOfShape::ChangeFind, "ChangeFind returns mofifiable Item by Key. Raises if Key was not bound", py::arg("theKey"));
	cls_TopTools_DataMapOfIntegerListOfShape.def("__call__", (TopTools_ListOfShape & (TopTools_DataMapOfIntegerListOfShape::*)(const Standard_Integer &)) &TopTools_DataMapOfIntegerListOfShape::operator(), py::is_operator(), "operator ()", py::arg("theKey"));
	cls_TopTools_DataMapOfIntegerListOfShape.def("Clear", [](TopTools_DataMapOfIntegerListOfShape &self) -> void { return self.Clear(); });
	cls_TopTools_DataMapOfIntegerListOfShape.def("Clear", (void (TopTools_DataMapOfIntegerListOfShape::*)(const Standard_Boolean)) &TopTools_DataMapOfIntegerListOfShape::Clear, "Clear data. If doReleaseMemory is false then the table of buckets is not released and will be reused.", py::arg("doReleaseMemory"));
	cls_TopTools_DataMapOfIntegerListOfShape.def("Clear", (void (TopTools_DataMapOfIntegerListOfShape::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &TopTools_DataMapOfIntegerListOfShape::Clear, "Clear data and reset allocator", py::arg("theAllocator"));
	cls_TopTools_DataMapOfIntegerListOfShape.def("Size", (Standard_Integer (TopTools_DataMapOfIntegerListOfShape::*)() const ) &TopTools_DataMapOfIntegerListOfShape::Size, "Size");
	cls_TopTools_DataMapOfIntegerListOfShape.def("__iter__", [](const TopTools_DataMapOfIntegerListOfShape &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\TopTools_DataMapOfIntegerListOfShape.hxx
	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_Map.hxx
	py::class_<TopTools_MapOfShape, std::unique_ptr<TopTools_MapOfShape, Deleter<TopTools_MapOfShape>>, NCollection_BaseMap> cls_TopTools_MapOfShape(mod, "TopTools_MapOfShape", "Purpose: Single hashed Map. This Map is used to store and retrieve keys in linear time.");
	cls_TopTools_MapOfShape.def(py::init<>());
	cls_TopTools_MapOfShape.def(py::init<const Standard_Integer>(), py::arg("NbBuckets"));
	cls_TopTools_MapOfShape.def(py::init<const Standard_Integer, const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("NbBuckets"), py::arg("theAllocator"));
	cls_TopTools_MapOfShape.def(py::init([] (const TopTools_MapOfShape &other) {return new TopTools_MapOfShape(other);}), "Copy constructor", py::arg("other"));
	cls_TopTools_MapOfShape.def("cbegin", (TopTools_MapOfShape::const_iterator (TopTools_MapOfShape::*)() const ) &TopTools_MapOfShape::cbegin, "Returns a const iterator pointing to the first element in the map.");
	cls_TopTools_MapOfShape.def("cend", (TopTools_MapOfShape::const_iterator (TopTools_MapOfShape::*)() const ) &TopTools_MapOfShape::cend, "Returns a const iterator referring to the past-the-end element in the map.");
	cls_TopTools_MapOfShape.def("Exchange", (void (TopTools_MapOfShape::*)(TopTools_MapOfShape &)) &TopTools_MapOfShape::Exchange, "Exchange the content of two maps without re-allocations. Notice that allocators will be swapped as well!", py::arg("theOther"));
	cls_TopTools_MapOfShape.def("Assign", (TopTools_MapOfShape & (TopTools_MapOfShape::*)(const TopTools_MapOfShape &)) &TopTools_MapOfShape::Assign, "Assign. This method does not change the internal allocator.", py::arg("theOther"));
	cls_TopTools_MapOfShape.def("assign", (TopTools_MapOfShape & (TopTools_MapOfShape::*)(const TopTools_MapOfShape &)) &TopTools_MapOfShape::operator=, py::is_operator(), "Assign operator", py::arg("theOther"));
	cls_TopTools_MapOfShape.def("ReSize", (void (TopTools_MapOfShape::*)(const Standard_Integer)) &TopTools_MapOfShape::ReSize, "ReSize", py::arg("N"));
	cls_TopTools_MapOfShape.def("Add", (Standard_Boolean (TopTools_MapOfShape::*)(const TopoDS_Shape &)) &TopTools_MapOfShape::Add, "Add", py::arg("K"));
	cls_TopTools_MapOfShape.def("Added", (const TopoDS_Shape & (TopTools_MapOfShape::*)(const TopoDS_Shape &)) &TopTools_MapOfShape::Added, "Added: add a new key if not yet in the map, and return reference to either newly added or previously existing object", py::arg("K"));
	cls_TopTools_MapOfShape.def("Contains", (Standard_Boolean (TopTools_MapOfShape::*)(const TopoDS_Shape &) const ) &TopTools_MapOfShape::Contains, "Contains", py::arg("K"));
	cls_TopTools_MapOfShape.def("Remove", (Standard_Boolean (TopTools_MapOfShape::*)(const TopoDS_Shape &)) &TopTools_MapOfShape::Remove, "Remove", py::arg("K"));
	cls_TopTools_MapOfShape.def("Clear", [](TopTools_MapOfShape &self) -> void { return self.Clear(); });
	cls_TopTools_MapOfShape.def("Clear", (void (TopTools_MapOfShape::*)(const Standard_Boolean)) &TopTools_MapOfShape::Clear, "Clear data. If doReleaseMemory is false then the table of buckets is not released and will be reused.", py::arg("doReleaseMemory"));
	cls_TopTools_MapOfShape.def("Clear", (void (TopTools_MapOfShape::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &TopTools_MapOfShape::Clear, "Clear data and reset allocator", py::arg("theAllocator"));
	cls_TopTools_MapOfShape.def("Size", (Standard_Integer (TopTools_MapOfShape::*)() const ) &TopTools_MapOfShape::Size, "Size");
	cls_TopTools_MapOfShape.def("IsEqual", (Standard_Boolean (TopTools_MapOfShape::*)(const TopTools_MapOfShape &) const ) &TopTools_MapOfShape::IsEqual, "Returns true if two maps contains exactly the same keys", py::arg("theOther"));
	cls_TopTools_MapOfShape.def("Contains", (Standard_Boolean (TopTools_MapOfShape::*)(const TopTools_MapOfShape &) const ) &TopTools_MapOfShape::Contains, "Returns true if this map contains ALL keys of another map.", py::arg("theOther"));
	cls_TopTools_MapOfShape.def("Union", (void (TopTools_MapOfShape::*)(const TopTools_MapOfShape &, const TopTools_MapOfShape &)) &TopTools_MapOfShape::Union, "Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps The new Map contains the values that are contained either in the first map or in the second map or in both. All previous content of this Map is cleared. This map (result of the boolean operation) can also be passed as one of operands.", py::arg("theLeft"), py::arg("theRight"));
	cls_TopTools_MapOfShape.def("Unite", (Standard_Boolean (TopTools_MapOfShape::*)(const TopTools_MapOfShape &)) &TopTools_MapOfShape::Unite, "Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map. The result contains the values that were previously contained in this map or contained in the given (operand) map. This algorithm is similar to method Union(). Returns True if contents of this map is changed.", py::arg("theOther"));
	cls_TopTools_MapOfShape.def("HasIntersection", (Standard_Boolean (TopTools_MapOfShape::*)(const TopTools_MapOfShape &) const ) &TopTools_MapOfShape::HasIntersection, "Returns true if this and theMap have common elements.", py::arg("theMap"));
	cls_TopTools_MapOfShape.def("Intersection", (void (TopTools_MapOfShape::*)(const TopTools_MapOfShape &, const TopTools_MapOfShape &)) &TopTools_MapOfShape::Intersection, "Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps. The new Map contains only the values that are contained in both map operands. All previous content of this Map is cleared. This same map (result of the boolean operation) can also be used as one of operands.", py::arg("theLeft"), py::arg("theRight"));
	cls_TopTools_MapOfShape.def("Intersect", (Standard_Boolean (TopTools_MapOfShape::*)(const TopTools_MapOfShape &)) &TopTools_MapOfShape::Intersect, "Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map. The result contains only the values that are contained in both this and the given maps. This algorithm is similar to method Intersection(). Returns True if contents of this map is changed.", py::arg("theOther"));
	cls_TopTools_MapOfShape.def("Subtraction", (void (TopTools_MapOfShape::*)(const TopTools_MapOfShape &, const TopTools_MapOfShape &)) &TopTools_MapOfShape::Subtraction, "Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement, exclude, cut, boolean NOT) operation between two given Maps. The new Map contains only the values that are contained in the first map operands and not contained in the second one. All previous content of this Map is cleared.", py::arg("theLeft"), py::arg("theRight"));
	cls_TopTools_MapOfShape.def("Subtract", (Standard_Boolean (TopTools_MapOfShape::*)(const TopTools_MapOfShape &)) &TopTools_MapOfShape::Subtract, "Apply to this Map the subtraction (aka set-theoretic difference, relative complement, exclude, cut, boolean NOT) operation with another (given) Map. The result contains only the values that were previously contained in this map and not contained in this map. This algorithm is similar to method Subtract() with two operands. Returns True if contents of this map is changed.", py::arg("theOther"));
	cls_TopTools_MapOfShape.def("Difference", (void (TopTools_MapOfShape::*)(const TopTools_MapOfShape &, const TopTools_MapOfShape &)) &TopTools_MapOfShape::Difference, "Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps. The new Map contains the values that are contained only in the first or the second operand maps but not in both. All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands.", py::arg("theLeft"), py::arg("theRight"));
	cls_TopTools_MapOfShape.def("Differ", (Standard_Boolean (TopTools_MapOfShape::*)(const TopTools_MapOfShape &)) &TopTools_MapOfShape::Differ, "Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map. The result contains the values that are contained only in this or the operand map, but not in both. This algorithm is similar to method Difference(). Returns True if contents of this map is changed.", py::arg("theOther"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\TopTools_MapOfShape.hxx
	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_IndexedMap.hxx
	py::class_<TopTools_IndexedMapOfShape, std::unique_ptr<TopTools_IndexedMapOfShape, Deleter<TopTools_IndexedMapOfShape>>, NCollection_BaseMap> cls_TopTools_IndexedMapOfShape(mod, "TopTools_IndexedMapOfShape", "Purpose: An indexed map is used to store keys and to bind an index to them. Each new key stored in the map gets an index. Index are incremented as keys are stored in the map. A key can be found by the index and an index by the key. No key but the last can be removed so the indices are in the range 1..Extent. See the class Map from NCollection for a discussion about the number of buckets.");
	cls_TopTools_IndexedMapOfShape.def(py::init<>());
	cls_TopTools_IndexedMapOfShape.def(py::init<const Standard_Integer>(), py::arg("NbBuckets"));
	cls_TopTools_IndexedMapOfShape.def(py::init<const Standard_Integer, const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("NbBuckets"), py::arg("theAllocator"));
	cls_TopTools_IndexedMapOfShape.def(py::init([] (const TopTools_IndexedMapOfShape &other) {return new TopTools_IndexedMapOfShape(other);}), "Copy constructor", py::arg("other"));
	cls_TopTools_IndexedMapOfShape.def("cbegin", (TopTools_IndexedMapOfShape::const_iterator (TopTools_IndexedMapOfShape::*)() const ) &TopTools_IndexedMapOfShape::cbegin, "Returns a const iterator pointing to the first element in the map.");
	cls_TopTools_IndexedMapOfShape.def("cend", (TopTools_IndexedMapOfShape::const_iterator (TopTools_IndexedMapOfShape::*)() const ) &TopTools_IndexedMapOfShape::cend, "Returns a const iterator referring to the past-the-end element in the map.");
	cls_TopTools_IndexedMapOfShape.def("Exchange", (void (TopTools_IndexedMapOfShape::*)(TopTools_IndexedMapOfShape &)) &TopTools_IndexedMapOfShape::Exchange, "Exchange the content of two maps without re-allocations. Notice that allocators will be swapped as well!", py::arg("theOther"));
	cls_TopTools_IndexedMapOfShape.def("Assign", (TopTools_IndexedMapOfShape & (TopTools_IndexedMapOfShape::*)(const TopTools_IndexedMapOfShape &)) &TopTools_IndexedMapOfShape::Assign, "Assign. This method does not change the internal allocator.", py::arg("theOther"));
	cls_TopTools_IndexedMapOfShape.def("assign", (TopTools_IndexedMapOfShape & (TopTools_IndexedMapOfShape::*)(const TopTools_IndexedMapOfShape &)) &TopTools_IndexedMapOfShape::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	cls_TopTools_IndexedMapOfShape.def("ReSize", (void (TopTools_IndexedMapOfShape::*)(const Standard_Integer)) &TopTools_IndexedMapOfShape::ReSize, "ReSize", py::arg("N"));
	cls_TopTools_IndexedMapOfShape.def("Add", (Standard_Integer (TopTools_IndexedMapOfShape::*)(const TopoDS_Shape &)) &TopTools_IndexedMapOfShape::Add, "Add", py::arg("theKey1"));
	cls_TopTools_IndexedMapOfShape.def("Contains", (Standard_Boolean (TopTools_IndexedMapOfShape::*)(const TopoDS_Shape &) const ) &TopTools_IndexedMapOfShape::Contains, "Contains", py::arg("theKey1"));
	cls_TopTools_IndexedMapOfShape.def("Substitute", (void (TopTools_IndexedMapOfShape::*)(const Standard_Integer, const TopoDS_Shape &)) &TopTools_IndexedMapOfShape::Substitute, "Substitute", py::arg("theIndex"), py::arg("theKey1"));
	cls_TopTools_IndexedMapOfShape.def("Swap", (void (TopTools_IndexedMapOfShape::*)(const Standard_Integer, const Standard_Integer)) &TopTools_IndexedMapOfShape::Swap, "Swaps two elements with the given indices.", py::arg("theIndex1"), py::arg("theIndex2"));
	cls_TopTools_IndexedMapOfShape.def("RemoveLast", (void (TopTools_IndexedMapOfShape::*)()) &TopTools_IndexedMapOfShape::RemoveLast, "RemoveLast");
	cls_TopTools_IndexedMapOfShape.def("RemoveFromIndex", (void (TopTools_IndexedMapOfShape::*)(const Standard_Integer)) &TopTools_IndexedMapOfShape::RemoveFromIndex, "Remove the key of the given index. Caution! The index of the last key can be changed.", py::arg("theKey2"));
	cls_TopTools_IndexedMapOfShape.def("RemoveKey", (Standard_Boolean (TopTools_IndexedMapOfShape::*)(const TopoDS_Shape &)) &TopTools_IndexedMapOfShape::RemoveKey, "Remove the given key. Caution! The index of the last key can be changed.", py::arg("theKey1"));
	cls_TopTools_IndexedMapOfShape.def("FindKey", (const TopoDS_Shape & (TopTools_IndexedMapOfShape::*)(const Standard_Integer) const ) &TopTools_IndexedMapOfShape::FindKey, "FindKey", py::arg("theKey2"));
	cls_TopTools_IndexedMapOfShape.def("__call__", (const TopoDS_Shape & (TopTools_IndexedMapOfShape::*)(const Standard_Integer) const ) &TopTools_IndexedMapOfShape::operator(), py::is_operator(), "operator ()", py::arg("theKey2"));
	cls_TopTools_IndexedMapOfShape.def("FindIndex", (Standard_Integer (TopTools_IndexedMapOfShape::*)(const TopoDS_Shape &) const ) &TopTools_IndexedMapOfShape::FindIndex, "FindIndex", py::arg("theKey1"));
	cls_TopTools_IndexedMapOfShape.def("Clear", [](TopTools_IndexedMapOfShape &self) -> void { return self.Clear(); });
	cls_TopTools_IndexedMapOfShape.def("Clear", (void (TopTools_IndexedMapOfShape::*)(const Standard_Boolean)) &TopTools_IndexedMapOfShape::Clear, "Clear data. If doReleaseMemory is false then the table of buckets is not released and will be reused.", py::arg("doReleaseMemory"));
	cls_TopTools_IndexedMapOfShape.def("Clear", (void (TopTools_IndexedMapOfShape::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &TopTools_IndexedMapOfShape::Clear, "Clear data and reset allocator", py::arg("theAllocator"));
	cls_TopTools_IndexedMapOfShape.def("Size", (Standard_Integer (TopTools_IndexedMapOfShape::*)() const ) &TopTools_IndexedMapOfShape::Size, "Size");

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_IndexedDataMap.hxx
	py::class_<TopTools_IndexedDataMapOfShapeListOfShape, std::unique_ptr<TopTools_IndexedDataMapOfShapeListOfShape, Deleter<TopTools_IndexedDataMapOfShapeListOfShape>>, NCollection_BaseMap> cls_TopTools_IndexedDataMapOfShapeListOfShape(mod, "TopTools_IndexedDataMapOfShapeListOfShape", "Purpose: An indexed map is used to store keys and to bind an index to them. Each new key stored in the map gets an index. Index are incremented as keys are stored in the map. A key can be found by the index and an index by the key. No key but the last can be removed so the indices are in the range 1.. Extent. An Item is stored with each key.");
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def(py::init<>());
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def(py::init<const Standard_Integer>(), py::arg("NbBuckets"));
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def(py::init<const Standard_Integer, const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("NbBuckets"), py::arg("theAllocator"));
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def(py::init([] (const TopTools_IndexedDataMapOfShapeListOfShape &other) {return new TopTools_IndexedDataMapOfShapeListOfShape(other);}), "Copy constructor", py::arg("other"));
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("begin", (TopTools_IndexedDataMapOfShapeListOfShape::iterator (TopTools_IndexedDataMapOfShapeListOfShape::*)() const ) &TopTools_IndexedDataMapOfShapeListOfShape::begin, "Returns an iterator pointing to the first element in the map.");
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("end", (TopTools_IndexedDataMapOfShapeListOfShape::iterator (TopTools_IndexedDataMapOfShapeListOfShape::*)() const ) &TopTools_IndexedDataMapOfShapeListOfShape::end, "Returns an iterator referring to the past-the-end element in the map.");
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("cbegin", (TopTools_IndexedDataMapOfShapeListOfShape::const_iterator (TopTools_IndexedDataMapOfShapeListOfShape::*)() const ) &TopTools_IndexedDataMapOfShapeListOfShape::cbegin, "Returns a const iterator pointing to the first element in the map.");
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("cend", (TopTools_IndexedDataMapOfShapeListOfShape::const_iterator (TopTools_IndexedDataMapOfShapeListOfShape::*)() const ) &TopTools_IndexedDataMapOfShapeListOfShape::cend, "Returns a const iterator referring to the past-the-end element in the map.");
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("Exchange", (void (TopTools_IndexedDataMapOfShapeListOfShape::*)(TopTools_IndexedDataMapOfShapeListOfShape &)) &TopTools_IndexedDataMapOfShapeListOfShape::Exchange, "Exchange the content of two maps without re-allocations. Notice that allocators will be swapped as well!", py::arg("theOther"));
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("Assign", (TopTools_IndexedDataMapOfShapeListOfShape & (TopTools_IndexedDataMapOfShapeListOfShape::*)(const TopTools_IndexedDataMapOfShapeListOfShape &)) &TopTools_IndexedDataMapOfShapeListOfShape::Assign, "Assignment. This method does not change the internal allocator.", py::arg("theOther"));
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("assign", (TopTools_IndexedDataMapOfShapeListOfShape & (TopTools_IndexedDataMapOfShapeListOfShape::*)(const TopTools_IndexedDataMapOfShapeListOfShape &)) &TopTools_IndexedDataMapOfShapeListOfShape::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("ReSize", (void (TopTools_IndexedDataMapOfShapeListOfShape::*)(const Standard_Integer)) &TopTools_IndexedDataMapOfShapeListOfShape::ReSize, "ReSize", py::arg("N"));
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("Add", (Standard_Integer (TopTools_IndexedDataMapOfShapeListOfShape::*)(const TopoDS_Shape &, const TopTools_ListOfShape &)) &TopTools_IndexedDataMapOfShapeListOfShape::Add, "Add", py::arg("theKey1"), py::arg("theItem"));
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("Contains", (Standard_Boolean (TopTools_IndexedDataMapOfShapeListOfShape::*)(const TopoDS_Shape &) const ) &TopTools_IndexedDataMapOfShapeListOfShape::Contains, "Contains", py::arg("theKey1"));
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("Substitute", (void (TopTools_IndexedDataMapOfShapeListOfShape::*)(const Standard_Integer, const TopoDS_Shape &, const TopTools_ListOfShape &)) &TopTools_IndexedDataMapOfShapeListOfShape::Substitute, "Substitute", py::arg("theIndex"), py::arg("theKey1"), py::arg("theItem"));
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("Swap", (void (TopTools_IndexedDataMapOfShapeListOfShape::*)(const Standard_Integer, const Standard_Integer)) &TopTools_IndexedDataMapOfShapeListOfShape::Swap, "Swaps two elements with the given indices.", py::arg("theIndex1"), py::arg("theIndex2"));
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("RemoveLast", (void (TopTools_IndexedDataMapOfShapeListOfShape::*)()) &TopTools_IndexedDataMapOfShapeListOfShape::RemoveLast, "RemoveLast");
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("RemoveFromIndex", (void (TopTools_IndexedDataMapOfShapeListOfShape::*)(const Standard_Integer)) &TopTools_IndexedDataMapOfShapeListOfShape::RemoveFromIndex, "Remove the key of the given index. Caution! The index of the last key can be changed.", py::arg("theKey2"));
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("RemoveKey", (void (TopTools_IndexedDataMapOfShapeListOfShape::*)(const TopoDS_Shape &)) &TopTools_IndexedDataMapOfShapeListOfShape::RemoveKey, "Remove the given key. Caution! The index of the last key can be changed.", py::arg("theKey1"));
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("FindKey", (const TopoDS_Shape & (TopTools_IndexedDataMapOfShapeListOfShape::*)(const Standard_Integer) const ) &TopTools_IndexedDataMapOfShapeListOfShape::FindKey, "FindKey", py::arg("theKey2"));
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("FindFromIndex", (const TopTools_ListOfShape & (TopTools_IndexedDataMapOfShapeListOfShape::*)(const Standard_Integer) const ) &TopTools_IndexedDataMapOfShapeListOfShape::FindFromIndex, "FindFromIndex", py::arg("theKey2"));
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("__call__", (const TopTools_ListOfShape & (TopTools_IndexedDataMapOfShapeListOfShape::*)(const Standard_Integer) const ) &TopTools_IndexedDataMapOfShapeListOfShape::operator(), py::is_operator(), "operator ()", py::arg("theKey2"));
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("ChangeFromIndex", (TopTools_ListOfShape & (TopTools_IndexedDataMapOfShapeListOfShape::*)(const Standard_Integer)) &TopTools_IndexedDataMapOfShapeListOfShape::ChangeFromIndex, "ChangeFromIndex", py::arg("theKey2"));
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("__call__", (TopTools_ListOfShape & (TopTools_IndexedDataMapOfShapeListOfShape::*)(const Standard_Integer)) &TopTools_IndexedDataMapOfShapeListOfShape::operator(), py::is_operator(), "operator ()", py::arg("theKey2"));
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("FindIndex", (Standard_Integer (TopTools_IndexedDataMapOfShapeListOfShape::*)(const TopoDS_Shape &) const ) &TopTools_IndexedDataMapOfShapeListOfShape::FindIndex, "FindIndex", py::arg("theKey1"));
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("FindFromKey", (const TopTools_ListOfShape & (TopTools_IndexedDataMapOfShapeListOfShape::*)(const TopoDS_Shape &) const ) &TopTools_IndexedDataMapOfShapeListOfShape::FindFromKey, "FindFromKey", py::arg("theKey1"));
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("ChangeFromKey", (TopTools_ListOfShape & (TopTools_IndexedDataMapOfShapeListOfShape::*)(const TopoDS_Shape &)) &TopTools_IndexedDataMapOfShapeListOfShape::ChangeFromKey, "ChangeFromKey", py::arg("theKey1"));
	// FIXME cls_TopTools_IndexedDataMapOfShapeListOfShape.def("Seek", (const TopTools_ListOfShape * (TopTools_IndexedDataMapOfShapeListOfShape::*)(const TopoDS_Shape &) const ) &TopTools_IndexedDataMapOfShapeListOfShape::Seek, "Seek returns pointer to Item by Key. Returns NULL if Key was not found.", py::arg("theKey1"));
	// FIXME cls_TopTools_IndexedDataMapOfShapeListOfShape.def("ChangeSeek", (TopTools_ListOfShape * (TopTools_IndexedDataMapOfShapeListOfShape::*)(const TopoDS_Shape &)) &TopTools_IndexedDataMapOfShapeListOfShape::ChangeSeek, "ChangeSeek returns modifiable pointer to Item by Key. Returns NULL if Key was not found.", py::arg("theKey1"));
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("FindFromKey", (Standard_Boolean (TopTools_IndexedDataMapOfShapeListOfShape::*)(const TopoDS_Shape &, TopTools_ListOfShape &) const ) &TopTools_IndexedDataMapOfShapeListOfShape::FindFromKey, "Find value for key with copying.", py::arg("theKey1"), py::arg("theValue"));
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("Clear", [](TopTools_IndexedDataMapOfShapeListOfShape &self) -> void { return self.Clear(); });
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("Clear", (void (TopTools_IndexedDataMapOfShapeListOfShape::*)(const Standard_Boolean)) &TopTools_IndexedDataMapOfShapeListOfShape::Clear, "Clear data. If doReleaseMemory is false then the table of buckets is not released and will be reused.", py::arg("doReleaseMemory"));
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("Clear", (void (TopTools_IndexedDataMapOfShapeListOfShape::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &TopTools_IndexedDataMapOfShapeListOfShape::Clear, "Clear data and reset allocator", py::arg("theAllocator"));
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("Size", (Standard_Integer (TopTools_IndexedDataMapOfShapeListOfShape::*)() const ) &TopTools_IndexedDataMapOfShapeListOfShape::Size, "Size");
	cls_TopTools_IndexedDataMapOfShapeListOfShape.def("__iter__", [](const TopTools_IndexedDataMapOfShapeListOfShape &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_DataMap.hxx
	py::class_<TopTools_DataMapOfShapeListOfShape, std::unique_ptr<TopTools_DataMapOfShapeListOfShape, Deleter<TopTools_DataMapOfShapeListOfShape>>, NCollection_BaseMap> cls_TopTools_DataMapOfShapeListOfShape(mod, "TopTools_DataMapOfShapeListOfShape", "Purpose: The DataMap is a Map to store keys with associated Items. See Map from NCollection for a discussion about the number of buckets.");
	cls_TopTools_DataMapOfShapeListOfShape.def(py::init<>());
	cls_TopTools_DataMapOfShapeListOfShape.def(py::init<const Standard_Integer>(), py::arg("NbBuckets"));
	cls_TopTools_DataMapOfShapeListOfShape.def(py::init<const Standard_Integer, const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("NbBuckets"), py::arg("theAllocator"));
	cls_TopTools_DataMapOfShapeListOfShape.def(py::init([] (const TopTools_DataMapOfShapeListOfShape &other) {return new TopTools_DataMapOfShapeListOfShape(other);}), "Copy constructor", py::arg("other"));
	cls_TopTools_DataMapOfShapeListOfShape.def("begin", (TopTools_DataMapOfShapeListOfShape::iterator (TopTools_DataMapOfShapeListOfShape::*)() const ) &TopTools_DataMapOfShapeListOfShape::begin, "Returns an iterator pointing to the first element in the map.");
	cls_TopTools_DataMapOfShapeListOfShape.def("end", (TopTools_DataMapOfShapeListOfShape::iterator (TopTools_DataMapOfShapeListOfShape::*)() const ) &TopTools_DataMapOfShapeListOfShape::end, "Returns an iterator referring to the past-the-end element in the map.");
	cls_TopTools_DataMapOfShapeListOfShape.def("cbegin", (TopTools_DataMapOfShapeListOfShape::const_iterator (TopTools_DataMapOfShapeListOfShape::*)() const ) &TopTools_DataMapOfShapeListOfShape::cbegin, "Returns a const iterator pointing to the first element in the map.");
	cls_TopTools_DataMapOfShapeListOfShape.def("cend", (TopTools_DataMapOfShapeListOfShape::const_iterator (TopTools_DataMapOfShapeListOfShape::*)() const ) &TopTools_DataMapOfShapeListOfShape::cend, "Returns a const iterator referring to the past-the-end element in the map.");
	cls_TopTools_DataMapOfShapeListOfShape.def("Exchange", (void (TopTools_DataMapOfShapeListOfShape::*)(TopTools_DataMapOfShapeListOfShape &)) &TopTools_DataMapOfShapeListOfShape::Exchange, "Exchange the content of two maps without re-allocations. Notice that allocators will be swapped as well!", py::arg("theOther"));
	cls_TopTools_DataMapOfShapeListOfShape.def("Assign", (TopTools_DataMapOfShapeListOfShape & (TopTools_DataMapOfShapeListOfShape::*)(const TopTools_DataMapOfShapeListOfShape &)) &TopTools_DataMapOfShapeListOfShape::Assign, "Assignment. This method does not change the internal allocator.", py::arg("theOther"));
	cls_TopTools_DataMapOfShapeListOfShape.def("assign", (TopTools_DataMapOfShapeListOfShape & (TopTools_DataMapOfShapeListOfShape::*)(const TopTools_DataMapOfShapeListOfShape &)) &TopTools_DataMapOfShapeListOfShape::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	cls_TopTools_DataMapOfShapeListOfShape.def("ReSize", (void (TopTools_DataMapOfShapeListOfShape::*)(const Standard_Integer)) &TopTools_DataMapOfShapeListOfShape::ReSize, "ReSize", py::arg("N"));
	cls_TopTools_DataMapOfShapeListOfShape.def("Bind", (Standard_Boolean (TopTools_DataMapOfShapeListOfShape::*)(const TopoDS_Shape &, const TopTools_ListOfShape &)) &TopTools_DataMapOfShapeListOfShape::Bind, "Bind binds Item to Key in map. Returns Standard_True if Key was not exist in the map. If the Key was already bound, the Item will be rebinded and Standard_False will be returned.", py::arg("theKey"), py::arg("theItem"));
	// FIXME cls_TopTools_DataMapOfShapeListOfShape.def("Bound", (TopTools_ListOfShape * (TopTools_DataMapOfShapeListOfShape::*)(const TopoDS_Shape &, const TopTools_ListOfShape &)) &TopTools_DataMapOfShapeListOfShape::Bound, "Bound binds Item to Key in map. Returns modifiable Item", py::arg("theKey"), py::arg("theItem"));
	cls_TopTools_DataMapOfShapeListOfShape.def("IsBound", (Standard_Boolean (TopTools_DataMapOfShapeListOfShape::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfShapeListOfShape::IsBound, "IsBound", py::arg("theKey"));
	cls_TopTools_DataMapOfShapeListOfShape.def("UnBind", (Standard_Boolean (TopTools_DataMapOfShapeListOfShape::*)(const TopoDS_Shape &)) &TopTools_DataMapOfShapeListOfShape::UnBind, "UnBind removes Item Key pair from map", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfShapeListOfShape.def("Seek", (const TopTools_ListOfShape * (TopTools_DataMapOfShapeListOfShape::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfShapeListOfShape::Seek, "Seek returns pointer to Item by Key. Returns NULL is Key was not bound.", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfShapeListOfShape.def("Find", (const TopTools_ListOfShape & (TopTools_DataMapOfShapeListOfShape::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfShapeListOfShape::Find, "Find returns the Item for Key. Raises if Key was not bound", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfShapeListOfShape.def("Find", (Standard_Boolean (TopTools_DataMapOfShapeListOfShape::*)(const TopoDS_Shape &, TopTools_ListOfShape &) const ) &TopTools_DataMapOfShapeListOfShape::Find, "Find Item for key with copying.", py::arg("theKey"), py::arg("theValue"));
	cls_TopTools_DataMapOfShapeListOfShape.def("__call__", (const TopTools_ListOfShape & (TopTools_DataMapOfShapeListOfShape::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfShapeListOfShape::operator(), py::is_operator(), "operator ()", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfShapeListOfShape.def("ChangeSeek", (TopTools_ListOfShape * (TopTools_DataMapOfShapeListOfShape::*)(const TopoDS_Shape &)) &TopTools_DataMapOfShapeListOfShape::ChangeSeek, "ChangeSeek returns modifiable pointer to Item by Key. Returns NULL is Key was not bound.", py::arg("theKey"));
	cls_TopTools_DataMapOfShapeListOfShape.def("ChangeFind", (TopTools_ListOfShape & (TopTools_DataMapOfShapeListOfShape::*)(const TopoDS_Shape &)) &TopTools_DataMapOfShapeListOfShape::ChangeFind, "ChangeFind returns mofifiable Item by Key. Raises if Key was not bound", py::arg("theKey"));
	cls_TopTools_DataMapOfShapeListOfShape.def("__call__", (TopTools_ListOfShape & (TopTools_DataMapOfShapeListOfShape::*)(const TopoDS_Shape &)) &TopTools_DataMapOfShapeListOfShape::operator(), py::is_operator(), "operator ()", py::arg("theKey"));
	cls_TopTools_DataMapOfShapeListOfShape.def("Clear", [](TopTools_DataMapOfShapeListOfShape &self) -> void { return self.Clear(); });
	cls_TopTools_DataMapOfShapeListOfShape.def("Clear", (void (TopTools_DataMapOfShapeListOfShape::*)(const Standard_Boolean)) &TopTools_DataMapOfShapeListOfShape::Clear, "Clear data. If doReleaseMemory is false then the table of buckets is not released and will be reused.", py::arg("doReleaseMemory"));
	cls_TopTools_DataMapOfShapeListOfShape.def("Clear", (void (TopTools_DataMapOfShapeListOfShape::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &TopTools_DataMapOfShapeListOfShape::Clear, "Clear data and reset allocator", py::arg("theAllocator"));
	cls_TopTools_DataMapOfShapeListOfShape.def("Size", (Standard_Integer (TopTools_DataMapOfShapeListOfShape::*)() const ) &TopTools_DataMapOfShapeListOfShape::Size, "Size");
	cls_TopTools_DataMapOfShapeListOfShape.def("__iter__", [](const TopTools_DataMapOfShapeListOfShape &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\TopTools_DataMapOfShapeListOfShape.hxx
	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_DataMap.hxx
	py::class_<TopTools_DataMapOfShapeShape, std::unique_ptr<TopTools_DataMapOfShapeShape, Deleter<TopTools_DataMapOfShapeShape>>, NCollection_BaseMap> cls_TopTools_DataMapOfShapeShape(mod, "TopTools_DataMapOfShapeShape", "Purpose: The DataMap is a Map to store keys with associated Items. See Map from NCollection for a discussion about the number of buckets.");
	cls_TopTools_DataMapOfShapeShape.def(py::init<>());
	cls_TopTools_DataMapOfShapeShape.def(py::init<const Standard_Integer>(), py::arg("NbBuckets"));
	cls_TopTools_DataMapOfShapeShape.def(py::init<const Standard_Integer, const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("NbBuckets"), py::arg("theAllocator"));
	cls_TopTools_DataMapOfShapeShape.def(py::init([] (const TopTools_DataMapOfShapeShape &other) {return new TopTools_DataMapOfShapeShape(other);}), "Copy constructor", py::arg("other"));
	cls_TopTools_DataMapOfShapeShape.def("begin", (TopTools_DataMapOfShapeShape::iterator (TopTools_DataMapOfShapeShape::*)() const ) &TopTools_DataMapOfShapeShape::begin, "Returns an iterator pointing to the first element in the map.");
	cls_TopTools_DataMapOfShapeShape.def("end", (TopTools_DataMapOfShapeShape::iterator (TopTools_DataMapOfShapeShape::*)() const ) &TopTools_DataMapOfShapeShape::end, "Returns an iterator referring to the past-the-end element in the map.");
	cls_TopTools_DataMapOfShapeShape.def("cbegin", (TopTools_DataMapOfShapeShape::const_iterator (TopTools_DataMapOfShapeShape::*)() const ) &TopTools_DataMapOfShapeShape::cbegin, "Returns a const iterator pointing to the first element in the map.");
	cls_TopTools_DataMapOfShapeShape.def("cend", (TopTools_DataMapOfShapeShape::const_iterator (TopTools_DataMapOfShapeShape::*)() const ) &TopTools_DataMapOfShapeShape::cend, "Returns a const iterator referring to the past-the-end element in the map.");
	cls_TopTools_DataMapOfShapeShape.def("Exchange", (void (TopTools_DataMapOfShapeShape::*)(TopTools_DataMapOfShapeShape &)) &TopTools_DataMapOfShapeShape::Exchange, "Exchange the content of two maps without re-allocations. Notice that allocators will be swapped as well!", py::arg("theOther"));
	cls_TopTools_DataMapOfShapeShape.def("Assign", (TopTools_DataMapOfShapeShape & (TopTools_DataMapOfShapeShape::*)(const TopTools_DataMapOfShapeShape &)) &TopTools_DataMapOfShapeShape::Assign, "Assignment. This method does not change the internal allocator.", py::arg("theOther"));
	cls_TopTools_DataMapOfShapeShape.def("assign", (TopTools_DataMapOfShapeShape & (TopTools_DataMapOfShapeShape::*)(const TopTools_DataMapOfShapeShape &)) &TopTools_DataMapOfShapeShape::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	cls_TopTools_DataMapOfShapeShape.def("ReSize", (void (TopTools_DataMapOfShapeShape::*)(const Standard_Integer)) &TopTools_DataMapOfShapeShape::ReSize, "ReSize", py::arg("N"));
	cls_TopTools_DataMapOfShapeShape.def("Bind", (Standard_Boolean (TopTools_DataMapOfShapeShape::*)(const TopoDS_Shape &, const TopoDS_Shape &)) &TopTools_DataMapOfShapeShape::Bind, "Bind binds Item to Key in map. Returns Standard_True if Key was not exist in the map. If the Key was already bound, the Item will be rebinded and Standard_False will be returned.", py::arg("theKey"), py::arg("theItem"));
	// FIXME cls_TopTools_DataMapOfShapeShape.def("Bound", (TopoDS_Shape * (TopTools_DataMapOfShapeShape::*)(const TopoDS_Shape &, const TopoDS_Shape &)) &TopTools_DataMapOfShapeShape::Bound, "Bound binds Item to Key in map. Returns modifiable Item", py::arg("theKey"), py::arg("theItem"));
	cls_TopTools_DataMapOfShapeShape.def("IsBound", (Standard_Boolean (TopTools_DataMapOfShapeShape::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfShapeShape::IsBound, "IsBound", py::arg("theKey"));
	cls_TopTools_DataMapOfShapeShape.def("UnBind", (Standard_Boolean (TopTools_DataMapOfShapeShape::*)(const TopoDS_Shape &)) &TopTools_DataMapOfShapeShape::UnBind, "UnBind removes Item Key pair from map", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfShapeShape.def("Seek", (const TopoDS_Shape * (TopTools_DataMapOfShapeShape::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfShapeShape::Seek, "Seek returns pointer to Item by Key. Returns NULL is Key was not bound.", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfShapeShape.def("Find", (const TopoDS_Shape & (TopTools_DataMapOfShapeShape::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfShapeShape::Find, "Find returns the Item for Key. Raises if Key was not bound", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfShapeShape.def("Find", (Standard_Boolean (TopTools_DataMapOfShapeShape::*)(const TopoDS_Shape &, TopoDS_Shape &) const ) &TopTools_DataMapOfShapeShape::Find, "Find Item for key with copying.", py::arg("theKey"), py::arg("theValue"));
	cls_TopTools_DataMapOfShapeShape.def("__call__", (const TopoDS_Shape & (TopTools_DataMapOfShapeShape::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfShapeShape::operator(), py::is_operator(), "operator ()", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfShapeShape.def("ChangeSeek", (TopoDS_Shape * (TopTools_DataMapOfShapeShape::*)(const TopoDS_Shape &)) &TopTools_DataMapOfShapeShape::ChangeSeek, "ChangeSeek returns modifiable pointer to Item by Key. Returns NULL is Key was not bound.", py::arg("theKey"));
	cls_TopTools_DataMapOfShapeShape.def("ChangeFind", (TopoDS_Shape & (TopTools_DataMapOfShapeShape::*)(const TopoDS_Shape &)) &TopTools_DataMapOfShapeShape::ChangeFind, "ChangeFind returns mofifiable Item by Key. Raises if Key was not bound", py::arg("theKey"));
	cls_TopTools_DataMapOfShapeShape.def("__call__", (TopoDS_Shape & (TopTools_DataMapOfShapeShape::*)(const TopoDS_Shape &)) &TopTools_DataMapOfShapeShape::operator(), py::is_operator(), "operator ()", py::arg("theKey"));
	cls_TopTools_DataMapOfShapeShape.def("Clear", [](TopTools_DataMapOfShapeShape &self) -> void { return self.Clear(); });
	cls_TopTools_DataMapOfShapeShape.def("Clear", (void (TopTools_DataMapOfShapeShape::*)(const Standard_Boolean)) &TopTools_DataMapOfShapeShape::Clear, "Clear data. If doReleaseMemory is false then the table of buckets is not released and will be reused.", py::arg("doReleaseMemory"));
	cls_TopTools_DataMapOfShapeShape.def("Clear", (void (TopTools_DataMapOfShapeShape::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &TopTools_DataMapOfShapeShape::Clear, "Clear data and reset allocator", py::arg("theAllocator"));
	cls_TopTools_DataMapOfShapeShape.def("Size", (Standard_Integer (TopTools_DataMapOfShapeShape::*)() const ) &TopTools_DataMapOfShapeShape::Size, "Size");
	cls_TopTools_DataMapOfShapeShape.def("__iter__", [](const TopTools_DataMapOfShapeShape &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\TopTools_DataMapOfShapeShape.hxx
	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_IndexedMap.hxx
	py::class_<TopTools_IndexedMapOfOrientedShape, std::unique_ptr<TopTools_IndexedMapOfOrientedShape, Deleter<TopTools_IndexedMapOfOrientedShape>>, NCollection_BaseMap> cls_TopTools_IndexedMapOfOrientedShape(mod, "TopTools_IndexedMapOfOrientedShape", "Purpose: An indexed map is used to store keys and to bind an index to them. Each new key stored in the map gets an index. Index are incremented as keys are stored in the map. A key can be found by the index and an index by the key. No key but the last can be removed so the indices are in the range 1..Extent. See the class Map from NCollection for a discussion about the number of buckets.");
	cls_TopTools_IndexedMapOfOrientedShape.def(py::init<>());
	cls_TopTools_IndexedMapOfOrientedShape.def(py::init<const Standard_Integer>(), py::arg("NbBuckets"));
	cls_TopTools_IndexedMapOfOrientedShape.def(py::init<const Standard_Integer, const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("NbBuckets"), py::arg("theAllocator"));
	cls_TopTools_IndexedMapOfOrientedShape.def(py::init([] (const TopTools_IndexedMapOfOrientedShape &other) {return new TopTools_IndexedMapOfOrientedShape(other);}), "Copy constructor", py::arg("other"));
	cls_TopTools_IndexedMapOfOrientedShape.def("cbegin", (TopTools_IndexedMapOfOrientedShape::const_iterator (TopTools_IndexedMapOfOrientedShape::*)() const ) &TopTools_IndexedMapOfOrientedShape::cbegin, "Returns a const iterator pointing to the first element in the map.");
	cls_TopTools_IndexedMapOfOrientedShape.def("cend", (TopTools_IndexedMapOfOrientedShape::const_iterator (TopTools_IndexedMapOfOrientedShape::*)() const ) &TopTools_IndexedMapOfOrientedShape::cend, "Returns a const iterator referring to the past-the-end element in the map.");
	cls_TopTools_IndexedMapOfOrientedShape.def("Exchange", (void (TopTools_IndexedMapOfOrientedShape::*)(TopTools_IndexedMapOfOrientedShape &)) &TopTools_IndexedMapOfOrientedShape::Exchange, "Exchange the content of two maps without re-allocations. Notice that allocators will be swapped as well!", py::arg("theOther"));
	cls_TopTools_IndexedMapOfOrientedShape.def("Assign", (TopTools_IndexedMapOfOrientedShape & (TopTools_IndexedMapOfOrientedShape::*)(const TopTools_IndexedMapOfOrientedShape &)) &TopTools_IndexedMapOfOrientedShape::Assign, "Assign. This method does not change the internal allocator.", py::arg("theOther"));
	cls_TopTools_IndexedMapOfOrientedShape.def("assign", (TopTools_IndexedMapOfOrientedShape & (TopTools_IndexedMapOfOrientedShape::*)(const TopTools_IndexedMapOfOrientedShape &)) &TopTools_IndexedMapOfOrientedShape::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	cls_TopTools_IndexedMapOfOrientedShape.def("ReSize", (void (TopTools_IndexedMapOfOrientedShape::*)(const Standard_Integer)) &TopTools_IndexedMapOfOrientedShape::ReSize, "ReSize", py::arg("N"));
	cls_TopTools_IndexedMapOfOrientedShape.def("Add", (Standard_Integer (TopTools_IndexedMapOfOrientedShape::*)(const TopoDS_Shape &)) &TopTools_IndexedMapOfOrientedShape::Add, "Add", py::arg("theKey1"));
	cls_TopTools_IndexedMapOfOrientedShape.def("Contains", (Standard_Boolean (TopTools_IndexedMapOfOrientedShape::*)(const TopoDS_Shape &) const ) &TopTools_IndexedMapOfOrientedShape::Contains, "Contains", py::arg("theKey1"));
	cls_TopTools_IndexedMapOfOrientedShape.def("Substitute", (void (TopTools_IndexedMapOfOrientedShape::*)(const Standard_Integer, const TopoDS_Shape &)) &TopTools_IndexedMapOfOrientedShape::Substitute, "Substitute", py::arg("theIndex"), py::arg("theKey1"));
	cls_TopTools_IndexedMapOfOrientedShape.def("Swap", (void (TopTools_IndexedMapOfOrientedShape::*)(const Standard_Integer, const Standard_Integer)) &TopTools_IndexedMapOfOrientedShape::Swap, "Swaps two elements with the given indices.", py::arg("theIndex1"), py::arg("theIndex2"));
	cls_TopTools_IndexedMapOfOrientedShape.def("RemoveLast", (void (TopTools_IndexedMapOfOrientedShape::*)()) &TopTools_IndexedMapOfOrientedShape::RemoveLast, "RemoveLast");
	cls_TopTools_IndexedMapOfOrientedShape.def("RemoveFromIndex", (void (TopTools_IndexedMapOfOrientedShape::*)(const Standard_Integer)) &TopTools_IndexedMapOfOrientedShape::RemoveFromIndex, "Remove the key of the given index. Caution! The index of the last key can be changed.", py::arg("theKey2"));
	cls_TopTools_IndexedMapOfOrientedShape.def("RemoveKey", (Standard_Boolean (TopTools_IndexedMapOfOrientedShape::*)(const TopoDS_Shape &)) &TopTools_IndexedMapOfOrientedShape::RemoveKey, "Remove the given key. Caution! The index of the last key can be changed.", py::arg("theKey1"));
	cls_TopTools_IndexedMapOfOrientedShape.def("FindKey", (const TopoDS_Shape & (TopTools_IndexedMapOfOrientedShape::*)(const Standard_Integer) const ) &TopTools_IndexedMapOfOrientedShape::FindKey, "FindKey", py::arg("theKey2"));
	cls_TopTools_IndexedMapOfOrientedShape.def("__call__", (const TopoDS_Shape & (TopTools_IndexedMapOfOrientedShape::*)(const Standard_Integer) const ) &TopTools_IndexedMapOfOrientedShape::operator(), py::is_operator(), "operator ()", py::arg("theKey2"));
	cls_TopTools_IndexedMapOfOrientedShape.def("FindIndex", (Standard_Integer (TopTools_IndexedMapOfOrientedShape::*)(const TopoDS_Shape &) const ) &TopTools_IndexedMapOfOrientedShape::FindIndex, "FindIndex", py::arg("theKey1"));
	cls_TopTools_IndexedMapOfOrientedShape.def("Clear", [](TopTools_IndexedMapOfOrientedShape &self) -> void { return self.Clear(); });
	cls_TopTools_IndexedMapOfOrientedShape.def("Clear", (void (TopTools_IndexedMapOfOrientedShape::*)(const Standard_Boolean)) &TopTools_IndexedMapOfOrientedShape::Clear, "Clear data. If doReleaseMemory is false then the table of buckets is not released and will be reused.", py::arg("doReleaseMemory"));
	cls_TopTools_IndexedMapOfOrientedShape.def("Clear", (void (TopTools_IndexedMapOfOrientedShape::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &TopTools_IndexedMapOfOrientedShape::Clear, "Clear data and reset allocator", py::arg("theAllocator"));
	cls_TopTools_IndexedMapOfOrientedShape.def("Size", (Standard_Integer (TopTools_IndexedMapOfOrientedShape::*)() const ) &TopTools_IndexedMapOfOrientedShape::Size, "Size");

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_DataMap.hxx
	py::class_<TopTools_DataMapOfShapeInteger, std::unique_ptr<TopTools_DataMapOfShapeInteger, Deleter<TopTools_DataMapOfShapeInteger>>, NCollection_BaseMap> cls_TopTools_DataMapOfShapeInteger(mod, "TopTools_DataMapOfShapeInteger", "Purpose: The DataMap is a Map to store keys with associated Items. See Map from NCollection for a discussion about the number of buckets.");
	cls_TopTools_DataMapOfShapeInteger.def(py::init<>());
	cls_TopTools_DataMapOfShapeInteger.def(py::init<const Standard_Integer>(), py::arg("NbBuckets"));
	cls_TopTools_DataMapOfShapeInteger.def(py::init<const Standard_Integer, const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("NbBuckets"), py::arg("theAllocator"));
	cls_TopTools_DataMapOfShapeInteger.def(py::init([] (const TopTools_DataMapOfShapeInteger &other) {return new TopTools_DataMapOfShapeInteger(other);}), "Copy constructor", py::arg("other"));
	cls_TopTools_DataMapOfShapeInteger.def("begin", (TopTools_DataMapOfShapeInteger::iterator (TopTools_DataMapOfShapeInteger::*)() const ) &TopTools_DataMapOfShapeInteger::begin, "Returns an iterator pointing to the first element in the map.");
	cls_TopTools_DataMapOfShapeInteger.def("end", (TopTools_DataMapOfShapeInteger::iterator (TopTools_DataMapOfShapeInteger::*)() const ) &TopTools_DataMapOfShapeInteger::end, "Returns an iterator referring to the past-the-end element in the map.");
	cls_TopTools_DataMapOfShapeInteger.def("cbegin", (TopTools_DataMapOfShapeInteger::const_iterator (TopTools_DataMapOfShapeInteger::*)() const ) &TopTools_DataMapOfShapeInteger::cbegin, "Returns a const iterator pointing to the first element in the map.");
	cls_TopTools_DataMapOfShapeInteger.def("cend", (TopTools_DataMapOfShapeInteger::const_iterator (TopTools_DataMapOfShapeInteger::*)() const ) &TopTools_DataMapOfShapeInteger::cend, "Returns a const iterator referring to the past-the-end element in the map.");
	cls_TopTools_DataMapOfShapeInteger.def("Exchange", (void (TopTools_DataMapOfShapeInteger::*)(TopTools_DataMapOfShapeInteger &)) &TopTools_DataMapOfShapeInteger::Exchange, "Exchange the content of two maps without re-allocations. Notice that allocators will be swapped as well!", py::arg("theOther"));
	cls_TopTools_DataMapOfShapeInteger.def("Assign", (TopTools_DataMapOfShapeInteger & (TopTools_DataMapOfShapeInteger::*)(const TopTools_DataMapOfShapeInteger &)) &TopTools_DataMapOfShapeInteger::Assign, "Assignment. This method does not change the internal allocator.", py::arg("theOther"));
	cls_TopTools_DataMapOfShapeInteger.def("assign", (TopTools_DataMapOfShapeInteger & (TopTools_DataMapOfShapeInteger::*)(const TopTools_DataMapOfShapeInteger &)) &TopTools_DataMapOfShapeInteger::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	cls_TopTools_DataMapOfShapeInteger.def("ReSize", (void (TopTools_DataMapOfShapeInteger::*)(const Standard_Integer)) &TopTools_DataMapOfShapeInteger::ReSize, "ReSize", py::arg("N"));
	cls_TopTools_DataMapOfShapeInteger.def("Bind", (Standard_Boolean (TopTools_DataMapOfShapeInteger::*)(const TopoDS_Shape &, const Standard_Integer &)) &TopTools_DataMapOfShapeInteger::Bind, "Bind binds Item to Key in map. Returns Standard_True if Key was not exist in the map. If the Key was already bound, the Item will be rebinded and Standard_False will be returned.", py::arg("theKey"), py::arg("theItem"));
	// FIXME cls_TopTools_DataMapOfShapeInteger.def("Bound", (Standard_Integer * (TopTools_DataMapOfShapeInteger::*)(const TopoDS_Shape &, const Standard_Integer &)) &TopTools_DataMapOfShapeInteger::Bound, "Bound binds Item to Key in map. Returns modifiable Item", py::arg("theKey"), py::arg("theItem"));
	cls_TopTools_DataMapOfShapeInteger.def("IsBound", (Standard_Boolean (TopTools_DataMapOfShapeInteger::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfShapeInteger::IsBound, "IsBound", py::arg("theKey"));
	cls_TopTools_DataMapOfShapeInteger.def("UnBind", (Standard_Boolean (TopTools_DataMapOfShapeInteger::*)(const TopoDS_Shape &)) &TopTools_DataMapOfShapeInteger::UnBind, "UnBind removes Item Key pair from map", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfShapeInteger.def("Seek", (const Standard_Integer * (TopTools_DataMapOfShapeInteger::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfShapeInteger::Seek, "Seek returns pointer to Item by Key. Returns NULL is Key was not bound.", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfShapeInteger.def("Find", (const Standard_Integer & (TopTools_DataMapOfShapeInteger::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfShapeInteger::Find, "Find returns the Item for Key. Raises if Key was not bound", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfShapeInteger.def("Find", (Standard_Boolean (TopTools_DataMapOfShapeInteger::*)(const TopoDS_Shape &, Standard_Integer &) const ) &TopTools_DataMapOfShapeInteger::Find, "Find Item for key with copying.", py::arg("theKey"), py::arg("theValue"));
	cls_TopTools_DataMapOfShapeInteger.def("__call__", (const Standard_Integer & (TopTools_DataMapOfShapeInteger::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfShapeInteger::operator(), py::is_operator(), "operator ()", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfShapeInteger.def("ChangeSeek", (Standard_Integer * (TopTools_DataMapOfShapeInteger::*)(const TopoDS_Shape &)) &TopTools_DataMapOfShapeInteger::ChangeSeek, "ChangeSeek returns modifiable pointer to Item by Key. Returns NULL is Key was not bound.", py::arg("theKey"));
	cls_TopTools_DataMapOfShapeInteger.def("ChangeFind", (Standard_Integer & (TopTools_DataMapOfShapeInteger::*)(const TopoDS_Shape &)) &TopTools_DataMapOfShapeInteger::ChangeFind, "ChangeFind returns mofifiable Item by Key. Raises if Key was not bound", py::arg("theKey"));
	cls_TopTools_DataMapOfShapeInteger.def("__call__", (Standard_Integer & (TopTools_DataMapOfShapeInteger::*)(const TopoDS_Shape &)) &TopTools_DataMapOfShapeInteger::operator(), py::is_operator(), "operator ()", py::arg("theKey"));
	cls_TopTools_DataMapOfShapeInteger.def("Clear", [](TopTools_DataMapOfShapeInteger &self) -> void { return self.Clear(); });
	cls_TopTools_DataMapOfShapeInteger.def("Clear", (void (TopTools_DataMapOfShapeInteger::*)(const Standard_Boolean)) &TopTools_DataMapOfShapeInteger::Clear, "Clear data. If doReleaseMemory is false then the table of buckets is not released and will be reused.", py::arg("doReleaseMemory"));
	cls_TopTools_DataMapOfShapeInteger.def("Clear", (void (TopTools_DataMapOfShapeInteger::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &TopTools_DataMapOfShapeInteger::Clear, "Clear data and reset allocator", py::arg("theAllocator"));
	cls_TopTools_DataMapOfShapeInteger.def("Size", (Standard_Integer (TopTools_DataMapOfShapeInteger::*)() const ) &TopTools_DataMapOfShapeInteger::Size, "Size");
	cls_TopTools_DataMapOfShapeInteger.def("__iter__", [](const TopTools_DataMapOfShapeInteger &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\TopTools_DataMapOfShapeInteger.hxx
	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_DataMap.hxx
	py::class_<TopTools_DataMapOfOrientedShapeInteger, std::unique_ptr<TopTools_DataMapOfOrientedShapeInteger, Deleter<TopTools_DataMapOfOrientedShapeInteger>>, NCollection_BaseMap> cls_TopTools_DataMapOfOrientedShapeInteger(mod, "TopTools_DataMapOfOrientedShapeInteger", "Purpose: The DataMap is a Map to store keys with associated Items. See Map from NCollection for a discussion about the number of buckets.");
	cls_TopTools_DataMapOfOrientedShapeInteger.def(py::init<>());
	cls_TopTools_DataMapOfOrientedShapeInteger.def(py::init<const Standard_Integer>(), py::arg("NbBuckets"));
	cls_TopTools_DataMapOfOrientedShapeInteger.def(py::init<const Standard_Integer, const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("NbBuckets"), py::arg("theAllocator"));
	cls_TopTools_DataMapOfOrientedShapeInteger.def(py::init([] (const TopTools_DataMapOfOrientedShapeInteger &other) {return new TopTools_DataMapOfOrientedShapeInteger(other);}), "Copy constructor", py::arg("other"));
	cls_TopTools_DataMapOfOrientedShapeInteger.def("begin", (TopTools_DataMapOfOrientedShapeInteger::iterator (TopTools_DataMapOfOrientedShapeInteger::*)() const ) &TopTools_DataMapOfOrientedShapeInteger::begin, "Returns an iterator pointing to the first element in the map.");
	cls_TopTools_DataMapOfOrientedShapeInteger.def("end", (TopTools_DataMapOfOrientedShapeInteger::iterator (TopTools_DataMapOfOrientedShapeInteger::*)() const ) &TopTools_DataMapOfOrientedShapeInteger::end, "Returns an iterator referring to the past-the-end element in the map.");
	cls_TopTools_DataMapOfOrientedShapeInteger.def("cbegin", (TopTools_DataMapOfOrientedShapeInteger::const_iterator (TopTools_DataMapOfOrientedShapeInteger::*)() const ) &TopTools_DataMapOfOrientedShapeInteger::cbegin, "Returns a const iterator pointing to the first element in the map.");
	cls_TopTools_DataMapOfOrientedShapeInteger.def("cend", (TopTools_DataMapOfOrientedShapeInteger::const_iterator (TopTools_DataMapOfOrientedShapeInteger::*)() const ) &TopTools_DataMapOfOrientedShapeInteger::cend, "Returns a const iterator referring to the past-the-end element in the map.");
	cls_TopTools_DataMapOfOrientedShapeInteger.def("Exchange", (void (TopTools_DataMapOfOrientedShapeInteger::*)(TopTools_DataMapOfOrientedShapeInteger &)) &TopTools_DataMapOfOrientedShapeInteger::Exchange, "Exchange the content of two maps without re-allocations. Notice that allocators will be swapped as well!", py::arg("theOther"));
	cls_TopTools_DataMapOfOrientedShapeInteger.def("Assign", (TopTools_DataMapOfOrientedShapeInteger & (TopTools_DataMapOfOrientedShapeInteger::*)(const TopTools_DataMapOfOrientedShapeInteger &)) &TopTools_DataMapOfOrientedShapeInteger::Assign, "Assignment. This method does not change the internal allocator.", py::arg("theOther"));
	cls_TopTools_DataMapOfOrientedShapeInteger.def("assign", (TopTools_DataMapOfOrientedShapeInteger & (TopTools_DataMapOfOrientedShapeInteger::*)(const TopTools_DataMapOfOrientedShapeInteger &)) &TopTools_DataMapOfOrientedShapeInteger::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	cls_TopTools_DataMapOfOrientedShapeInteger.def("ReSize", (void (TopTools_DataMapOfOrientedShapeInteger::*)(const Standard_Integer)) &TopTools_DataMapOfOrientedShapeInteger::ReSize, "ReSize", py::arg("N"));
	cls_TopTools_DataMapOfOrientedShapeInteger.def("Bind", (Standard_Boolean (TopTools_DataMapOfOrientedShapeInteger::*)(const TopoDS_Shape &, const Standard_Integer &)) &TopTools_DataMapOfOrientedShapeInteger::Bind, "Bind binds Item to Key in map. Returns Standard_True if Key was not exist in the map. If the Key was already bound, the Item will be rebinded and Standard_False will be returned.", py::arg("theKey"), py::arg("theItem"));
	// FIXME cls_TopTools_DataMapOfOrientedShapeInteger.def("Bound", (Standard_Integer * (TopTools_DataMapOfOrientedShapeInteger::*)(const TopoDS_Shape &, const Standard_Integer &)) &TopTools_DataMapOfOrientedShapeInteger::Bound, "Bound binds Item to Key in map. Returns modifiable Item", py::arg("theKey"), py::arg("theItem"));
	cls_TopTools_DataMapOfOrientedShapeInteger.def("IsBound", (Standard_Boolean (TopTools_DataMapOfOrientedShapeInteger::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfOrientedShapeInteger::IsBound, "IsBound", py::arg("theKey"));
	cls_TopTools_DataMapOfOrientedShapeInteger.def("UnBind", (Standard_Boolean (TopTools_DataMapOfOrientedShapeInteger::*)(const TopoDS_Shape &)) &TopTools_DataMapOfOrientedShapeInteger::UnBind, "UnBind removes Item Key pair from map", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfOrientedShapeInteger.def("Seek", (const Standard_Integer * (TopTools_DataMapOfOrientedShapeInteger::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfOrientedShapeInteger::Seek, "Seek returns pointer to Item by Key. Returns NULL is Key was not bound.", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfOrientedShapeInteger.def("Find", (const Standard_Integer & (TopTools_DataMapOfOrientedShapeInteger::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfOrientedShapeInteger::Find, "Find returns the Item for Key. Raises if Key was not bound", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfOrientedShapeInteger.def("Find", (Standard_Boolean (TopTools_DataMapOfOrientedShapeInteger::*)(const TopoDS_Shape &, Standard_Integer &) const ) &TopTools_DataMapOfOrientedShapeInteger::Find, "Find Item for key with copying.", py::arg("theKey"), py::arg("theValue"));
	cls_TopTools_DataMapOfOrientedShapeInteger.def("__call__", (const Standard_Integer & (TopTools_DataMapOfOrientedShapeInteger::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfOrientedShapeInteger::operator(), py::is_operator(), "operator ()", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfOrientedShapeInteger.def("ChangeSeek", (Standard_Integer * (TopTools_DataMapOfOrientedShapeInteger::*)(const TopoDS_Shape &)) &TopTools_DataMapOfOrientedShapeInteger::ChangeSeek, "ChangeSeek returns modifiable pointer to Item by Key. Returns NULL is Key was not bound.", py::arg("theKey"));
	cls_TopTools_DataMapOfOrientedShapeInteger.def("ChangeFind", (Standard_Integer & (TopTools_DataMapOfOrientedShapeInteger::*)(const TopoDS_Shape &)) &TopTools_DataMapOfOrientedShapeInteger::ChangeFind, "ChangeFind returns mofifiable Item by Key. Raises if Key was not bound", py::arg("theKey"));
	cls_TopTools_DataMapOfOrientedShapeInteger.def("__call__", (Standard_Integer & (TopTools_DataMapOfOrientedShapeInteger::*)(const TopoDS_Shape &)) &TopTools_DataMapOfOrientedShapeInteger::operator(), py::is_operator(), "operator ()", py::arg("theKey"));
	cls_TopTools_DataMapOfOrientedShapeInteger.def("Clear", [](TopTools_DataMapOfOrientedShapeInteger &self) -> void { return self.Clear(); });
	cls_TopTools_DataMapOfOrientedShapeInteger.def("Clear", (void (TopTools_DataMapOfOrientedShapeInteger::*)(const Standard_Boolean)) &TopTools_DataMapOfOrientedShapeInteger::Clear, "Clear data. If doReleaseMemory is false then the table of buckets is not released and will be reused.", py::arg("doReleaseMemory"));
	cls_TopTools_DataMapOfOrientedShapeInteger.def("Clear", (void (TopTools_DataMapOfOrientedShapeInteger::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &TopTools_DataMapOfOrientedShapeInteger::Clear, "Clear data and reset allocator", py::arg("theAllocator"));
	cls_TopTools_DataMapOfOrientedShapeInteger.def("Size", (Standard_Integer (TopTools_DataMapOfOrientedShapeInteger::*)() const ) &TopTools_DataMapOfOrientedShapeInteger::Size, "Size");
	cls_TopTools_DataMapOfOrientedShapeInteger.def("__iter__", [](const TopTools_DataMapOfOrientedShapeInteger &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\TopTools_DataMapOfOrientedShapeInteger.hxx
	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_IndexedDataMap.hxx
	py::class_<TopTools_IndexedDataMapOfShapeShape, std::unique_ptr<TopTools_IndexedDataMapOfShapeShape, Deleter<TopTools_IndexedDataMapOfShapeShape>>, NCollection_BaseMap> cls_TopTools_IndexedDataMapOfShapeShape(mod, "TopTools_IndexedDataMapOfShapeShape", "Purpose: An indexed map is used to store keys and to bind an index to them. Each new key stored in the map gets an index. Index are incremented as keys are stored in the map. A key can be found by the index and an index by the key. No key but the last can be removed so the indices are in the range 1.. Extent. An Item is stored with each key.");
	cls_TopTools_IndexedDataMapOfShapeShape.def(py::init<>());
	cls_TopTools_IndexedDataMapOfShapeShape.def(py::init<const Standard_Integer>(), py::arg("NbBuckets"));
	cls_TopTools_IndexedDataMapOfShapeShape.def(py::init<const Standard_Integer, const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("NbBuckets"), py::arg("theAllocator"));
	cls_TopTools_IndexedDataMapOfShapeShape.def(py::init([] (const TopTools_IndexedDataMapOfShapeShape &other) {return new TopTools_IndexedDataMapOfShapeShape(other);}), "Copy constructor", py::arg("other"));
	cls_TopTools_IndexedDataMapOfShapeShape.def("begin", (TopTools_IndexedDataMapOfShapeShape::iterator (TopTools_IndexedDataMapOfShapeShape::*)() const ) &TopTools_IndexedDataMapOfShapeShape::begin, "Returns an iterator pointing to the first element in the map.");
	cls_TopTools_IndexedDataMapOfShapeShape.def("end", (TopTools_IndexedDataMapOfShapeShape::iterator (TopTools_IndexedDataMapOfShapeShape::*)() const ) &TopTools_IndexedDataMapOfShapeShape::end, "Returns an iterator referring to the past-the-end element in the map.");
	cls_TopTools_IndexedDataMapOfShapeShape.def("cbegin", (TopTools_IndexedDataMapOfShapeShape::const_iterator (TopTools_IndexedDataMapOfShapeShape::*)() const ) &TopTools_IndexedDataMapOfShapeShape::cbegin, "Returns a const iterator pointing to the first element in the map.");
	cls_TopTools_IndexedDataMapOfShapeShape.def("cend", (TopTools_IndexedDataMapOfShapeShape::const_iterator (TopTools_IndexedDataMapOfShapeShape::*)() const ) &TopTools_IndexedDataMapOfShapeShape::cend, "Returns a const iterator referring to the past-the-end element in the map.");
	cls_TopTools_IndexedDataMapOfShapeShape.def("Exchange", (void (TopTools_IndexedDataMapOfShapeShape::*)(TopTools_IndexedDataMapOfShapeShape &)) &TopTools_IndexedDataMapOfShapeShape::Exchange, "Exchange the content of two maps without re-allocations. Notice that allocators will be swapped as well!", py::arg("theOther"));
	cls_TopTools_IndexedDataMapOfShapeShape.def("Assign", (TopTools_IndexedDataMapOfShapeShape & (TopTools_IndexedDataMapOfShapeShape::*)(const TopTools_IndexedDataMapOfShapeShape &)) &TopTools_IndexedDataMapOfShapeShape::Assign, "Assignment. This method does not change the internal allocator.", py::arg("theOther"));
	cls_TopTools_IndexedDataMapOfShapeShape.def("assign", (TopTools_IndexedDataMapOfShapeShape & (TopTools_IndexedDataMapOfShapeShape::*)(const TopTools_IndexedDataMapOfShapeShape &)) &TopTools_IndexedDataMapOfShapeShape::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	cls_TopTools_IndexedDataMapOfShapeShape.def("ReSize", (void (TopTools_IndexedDataMapOfShapeShape::*)(const Standard_Integer)) &TopTools_IndexedDataMapOfShapeShape::ReSize, "ReSize", py::arg("N"));
	cls_TopTools_IndexedDataMapOfShapeShape.def("Add", (Standard_Integer (TopTools_IndexedDataMapOfShapeShape::*)(const TopoDS_Shape &, const TopoDS_Shape &)) &TopTools_IndexedDataMapOfShapeShape::Add, "Add", py::arg("theKey1"), py::arg("theItem"));
	cls_TopTools_IndexedDataMapOfShapeShape.def("Contains", (Standard_Boolean (TopTools_IndexedDataMapOfShapeShape::*)(const TopoDS_Shape &) const ) &TopTools_IndexedDataMapOfShapeShape::Contains, "Contains", py::arg("theKey1"));
	cls_TopTools_IndexedDataMapOfShapeShape.def("Substitute", (void (TopTools_IndexedDataMapOfShapeShape::*)(const Standard_Integer, const TopoDS_Shape &, const TopoDS_Shape &)) &TopTools_IndexedDataMapOfShapeShape::Substitute, "Substitute", py::arg("theIndex"), py::arg("theKey1"), py::arg("theItem"));
	cls_TopTools_IndexedDataMapOfShapeShape.def("Swap", (void (TopTools_IndexedDataMapOfShapeShape::*)(const Standard_Integer, const Standard_Integer)) &TopTools_IndexedDataMapOfShapeShape::Swap, "Swaps two elements with the given indices.", py::arg("theIndex1"), py::arg("theIndex2"));
	cls_TopTools_IndexedDataMapOfShapeShape.def("RemoveLast", (void (TopTools_IndexedDataMapOfShapeShape::*)()) &TopTools_IndexedDataMapOfShapeShape::RemoveLast, "RemoveLast");
	cls_TopTools_IndexedDataMapOfShapeShape.def("RemoveFromIndex", (void (TopTools_IndexedDataMapOfShapeShape::*)(const Standard_Integer)) &TopTools_IndexedDataMapOfShapeShape::RemoveFromIndex, "Remove the key of the given index. Caution! The index of the last key can be changed.", py::arg("theKey2"));
	cls_TopTools_IndexedDataMapOfShapeShape.def("RemoveKey", (void (TopTools_IndexedDataMapOfShapeShape::*)(const TopoDS_Shape &)) &TopTools_IndexedDataMapOfShapeShape::RemoveKey, "Remove the given key. Caution! The index of the last key can be changed.", py::arg("theKey1"));
	cls_TopTools_IndexedDataMapOfShapeShape.def("FindKey", (const TopoDS_Shape & (TopTools_IndexedDataMapOfShapeShape::*)(const Standard_Integer) const ) &TopTools_IndexedDataMapOfShapeShape::FindKey, "FindKey", py::arg("theKey2"));
	cls_TopTools_IndexedDataMapOfShapeShape.def("FindFromIndex", (const TopoDS_Shape & (TopTools_IndexedDataMapOfShapeShape::*)(const Standard_Integer) const ) &TopTools_IndexedDataMapOfShapeShape::FindFromIndex, "FindFromIndex", py::arg("theKey2"));
	cls_TopTools_IndexedDataMapOfShapeShape.def("__call__", (const TopoDS_Shape & (TopTools_IndexedDataMapOfShapeShape::*)(const Standard_Integer) const ) &TopTools_IndexedDataMapOfShapeShape::operator(), py::is_operator(), "operator ()", py::arg("theKey2"));
	cls_TopTools_IndexedDataMapOfShapeShape.def("ChangeFromIndex", (TopoDS_Shape & (TopTools_IndexedDataMapOfShapeShape::*)(const Standard_Integer)) &TopTools_IndexedDataMapOfShapeShape::ChangeFromIndex, "ChangeFromIndex", py::arg("theKey2"));
	cls_TopTools_IndexedDataMapOfShapeShape.def("__call__", (TopoDS_Shape & (TopTools_IndexedDataMapOfShapeShape::*)(const Standard_Integer)) &TopTools_IndexedDataMapOfShapeShape::operator(), py::is_operator(), "operator ()", py::arg("theKey2"));
	cls_TopTools_IndexedDataMapOfShapeShape.def("FindIndex", (Standard_Integer (TopTools_IndexedDataMapOfShapeShape::*)(const TopoDS_Shape &) const ) &TopTools_IndexedDataMapOfShapeShape::FindIndex, "FindIndex", py::arg("theKey1"));
	cls_TopTools_IndexedDataMapOfShapeShape.def("FindFromKey", (const TopoDS_Shape & (TopTools_IndexedDataMapOfShapeShape::*)(const TopoDS_Shape &) const ) &TopTools_IndexedDataMapOfShapeShape::FindFromKey, "FindFromKey", py::arg("theKey1"));
	cls_TopTools_IndexedDataMapOfShapeShape.def("ChangeFromKey", (TopoDS_Shape & (TopTools_IndexedDataMapOfShapeShape::*)(const TopoDS_Shape &)) &TopTools_IndexedDataMapOfShapeShape::ChangeFromKey, "ChangeFromKey", py::arg("theKey1"));
	// FIXME cls_TopTools_IndexedDataMapOfShapeShape.def("Seek", (const TopoDS_Shape * (TopTools_IndexedDataMapOfShapeShape::*)(const TopoDS_Shape &) const ) &TopTools_IndexedDataMapOfShapeShape::Seek, "Seek returns pointer to Item by Key. Returns NULL if Key was not found.", py::arg("theKey1"));
	// FIXME cls_TopTools_IndexedDataMapOfShapeShape.def("ChangeSeek", (TopoDS_Shape * (TopTools_IndexedDataMapOfShapeShape::*)(const TopoDS_Shape &)) &TopTools_IndexedDataMapOfShapeShape::ChangeSeek, "ChangeSeek returns modifiable pointer to Item by Key. Returns NULL if Key was not found.", py::arg("theKey1"));
	cls_TopTools_IndexedDataMapOfShapeShape.def("FindFromKey", (Standard_Boolean (TopTools_IndexedDataMapOfShapeShape::*)(const TopoDS_Shape &, TopoDS_Shape &) const ) &TopTools_IndexedDataMapOfShapeShape::FindFromKey, "Find value for key with copying.", py::arg("theKey1"), py::arg("theValue"));
	cls_TopTools_IndexedDataMapOfShapeShape.def("Clear", [](TopTools_IndexedDataMapOfShapeShape &self) -> void { return self.Clear(); });
	cls_TopTools_IndexedDataMapOfShapeShape.def("Clear", (void (TopTools_IndexedDataMapOfShapeShape::*)(const Standard_Boolean)) &TopTools_IndexedDataMapOfShapeShape::Clear, "Clear data. If doReleaseMemory is false then the table of buckets is not released and will be reused.", py::arg("doReleaseMemory"));
	cls_TopTools_IndexedDataMapOfShapeShape.def("Clear", (void (TopTools_IndexedDataMapOfShapeShape::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &TopTools_IndexedDataMapOfShapeShape::Clear, "Clear data and reset allocator", py::arg("theAllocator"));
	cls_TopTools_IndexedDataMapOfShapeShape.def("Size", (Standard_Integer (TopTools_IndexedDataMapOfShapeShape::*)() const ) &TopTools_IndexedDataMapOfShapeShape::Size, "Size");
	cls_TopTools_IndexedDataMapOfShapeShape.def("__iter__", [](const TopTools_IndexedDataMapOfShapeShape &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\TopTools_HSequenceOfShape.hxx
	py::class_<TopTools_HSequenceOfShape, opencascade::handle<TopTools_HSequenceOfShape>, TopTools_SequenceOfShape, Standard_Transient> cls_TopTools_HSequenceOfShape(mod, "TopTools_HSequenceOfShape", "None");
	cls_TopTools_HSequenceOfShape.def(py::init<>());
	cls_TopTools_HSequenceOfShape.def(py::init<const TopTools_SequenceOfShape &>(), py::arg("theOther"));
	cls_TopTools_HSequenceOfShape.def("Sequence", (const TopTools_SequenceOfShape & (TopTools_HSequenceOfShape::*)() const ) &TopTools_HSequenceOfShape::Sequence, "None");
	cls_TopTools_HSequenceOfShape.def("Append", (void (TopTools_HSequenceOfShape::*)(const TopTools_SequenceOfShape::value_type &)) &TopTools_HSequenceOfShape::Append, "None", py::arg("theItem"));
	cls_TopTools_HSequenceOfShape.def("Append", (void (TopTools_HSequenceOfShape::*)(TopTools_SequenceOfShape &)) &TopTools_HSequenceOfShape::Append, "None", py::arg("theSequence"));
	cls_TopTools_HSequenceOfShape.def("ChangeSequence", (TopTools_SequenceOfShape & (TopTools_HSequenceOfShape::*)()) &TopTools_HSequenceOfShape::ChangeSequence, "None");
	cls_TopTools_HSequenceOfShape.def_static("get_type_name_", (const char * (*)()) &TopTools_HSequenceOfShape::get_type_name, "None");
	cls_TopTools_HSequenceOfShape.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &TopTools_HSequenceOfShape::get_type_descriptor, "None");
	cls_TopTools_HSequenceOfShape.def("DynamicType", (const opencascade::handle<Standard_Type> & (TopTools_HSequenceOfShape::*)() const ) &TopTools_HSequenceOfShape::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_DataMap.hxx
	py::class_<TopTools_DataMapOfShapeListOfInteger, std::unique_ptr<TopTools_DataMapOfShapeListOfInteger, Deleter<TopTools_DataMapOfShapeListOfInteger>>, NCollection_BaseMap> cls_TopTools_DataMapOfShapeListOfInteger(mod, "TopTools_DataMapOfShapeListOfInteger", "Purpose: The DataMap is a Map to store keys with associated Items. See Map from NCollection for a discussion about the number of buckets.");
	cls_TopTools_DataMapOfShapeListOfInteger.def(py::init<>());
	cls_TopTools_DataMapOfShapeListOfInteger.def(py::init<const Standard_Integer>(), py::arg("NbBuckets"));
	cls_TopTools_DataMapOfShapeListOfInteger.def(py::init<const Standard_Integer, const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("NbBuckets"), py::arg("theAllocator"));
	cls_TopTools_DataMapOfShapeListOfInteger.def(py::init([] (const TopTools_DataMapOfShapeListOfInteger &other) {return new TopTools_DataMapOfShapeListOfInteger(other);}), "Copy constructor", py::arg("other"));
	cls_TopTools_DataMapOfShapeListOfInteger.def("begin", (TopTools_DataMapOfShapeListOfInteger::iterator (TopTools_DataMapOfShapeListOfInteger::*)() const ) &TopTools_DataMapOfShapeListOfInteger::begin, "Returns an iterator pointing to the first element in the map.");
	cls_TopTools_DataMapOfShapeListOfInteger.def("end", (TopTools_DataMapOfShapeListOfInteger::iterator (TopTools_DataMapOfShapeListOfInteger::*)() const ) &TopTools_DataMapOfShapeListOfInteger::end, "Returns an iterator referring to the past-the-end element in the map.");
	cls_TopTools_DataMapOfShapeListOfInteger.def("cbegin", (TopTools_DataMapOfShapeListOfInteger::const_iterator (TopTools_DataMapOfShapeListOfInteger::*)() const ) &TopTools_DataMapOfShapeListOfInteger::cbegin, "Returns a const iterator pointing to the first element in the map.");
	cls_TopTools_DataMapOfShapeListOfInteger.def("cend", (TopTools_DataMapOfShapeListOfInteger::const_iterator (TopTools_DataMapOfShapeListOfInteger::*)() const ) &TopTools_DataMapOfShapeListOfInteger::cend, "Returns a const iterator referring to the past-the-end element in the map.");
	cls_TopTools_DataMapOfShapeListOfInteger.def("Exchange", (void (TopTools_DataMapOfShapeListOfInteger::*)(TopTools_DataMapOfShapeListOfInteger &)) &TopTools_DataMapOfShapeListOfInteger::Exchange, "Exchange the content of two maps without re-allocations. Notice that allocators will be swapped as well!", py::arg("theOther"));
	cls_TopTools_DataMapOfShapeListOfInteger.def("Assign", (TopTools_DataMapOfShapeListOfInteger & (TopTools_DataMapOfShapeListOfInteger::*)(const TopTools_DataMapOfShapeListOfInteger &)) &TopTools_DataMapOfShapeListOfInteger::Assign, "Assignment. This method does not change the internal allocator.", py::arg("theOther"));
	cls_TopTools_DataMapOfShapeListOfInteger.def("assign", (TopTools_DataMapOfShapeListOfInteger & (TopTools_DataMapOfShapeListOfInteger::*)(const TopTools_DataMapOfShapeListOfInteger &)) &TopTools_DataMapOfShapeListOfInteger::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	cls_TopTools_DataMapOfShapeListOfInteger.def("ReSize", (void (TopTools_DataMapOfShapeListOfInteger::*)(const Standard_Integer)) &TopTools_DataMapOfShapeListOfInteger::ReSize, "ReSize", py::arg("N"));
	cls_TopTools_DataMapOfShapeListOfInteger.def("Bind", (Standard_Boolean (TopTools_DataMapOfShapeListOfInteger::*)(const TopoDS_Shape &, const TColStd_ListOfInteger &)) &TopTools_DataMapOfShapeListOfInteger::Bind, "Bind binds Item to Key in map. Returns Standard_True if Key was not exist in the map. If the Key was already bound, the Item will be rebinded and Standard_False will be returned.", py::arg("theKey"), py::arg("theItem"));
	// FIXME cls_TopTools_DataMapOfShapeListOfInteger.def("Bound", (TColStd_ListOfInteger * (TopTools_DataMapOfShapeListOfInteger::*)(const TopoDS_Shape &, const TColStd_ListOfInteger &)) &TopTools_DataMapOfShapeListOfInteger::Bound, "Bound binds Item to Key in map. Returns modifiable Item", py::arg("theKey"), py::arg("theItem"));
	cls_TopTools_DataMapOfShapeListOfInteger.def("IsBound", (Standard_Boolean (TopTools_DataMapOfShapeListOfInteger::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfShapeListOfInteger::IsBound, "IsBound", py::arg("theKey"));
	cls_TopTools_DataMapOfShapeListOfInteger.def("UnBind", (Standard_Boolean (TopTools_DataMapOfShapeListOfInteger::*)(const TopoDS_Shape &)) &TopTools_DataMapOfShapeListOfInteger::UnBind, "UnBind removes Item Key pair from map", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfShapeListOfInteger.def("Seek", (const TColStd_ListOfInteger * (TopTools_DataMapOfShapeListOfInteger::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfShapeListOfInteger::Seek, "Seek returns pointer to Item by Key. Returns NULL is Key was not bound.", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfShapeListOfInteger.def("Find", (const TColStd_ListOfInteger & (TopTools_DataMapOfShapeListOfInteger::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfShapeListOfInteger::Find, "Find returns the Item for Key. Raises if Key was not bound", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfShapeListOfInteger.def("Find", (Standard_Boolean (TopTools_DataMapOfShapeListOfInteger::*)(const TopoDS_Shape &, TColStd_ListOfInteger &) const ) &TopTools_DataMapOfShapeListOfInteger::Find, "Find Item for key with copying.", py::arg("theKey"), py::arg("theValue"));
	cls_TopTools_DataMapOfShapeListOfInteger.def("__call__", (const TColStd_ListOfInteger & (TopTools_DataMapOfShapeListOfInteger::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfShapeListOfInteger::operator(), py::is_operator(), "operator ()", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfShapeListOfInteger.def("ChangeSeek", (TColStd_ListOfInteger * (TopTools_DataMapOfShapeListOfInteger::*)(const TopoDS_Shape &)) &TopTools_DataMapOfShapeListOfInteger::ChangeSeek, "ChangeSeek returns modifiable pointer to Item by Key. Returns NULL is Key was not bound.", py::arg("theKey"));
	cls_TopTools_DataMapOfShapeListOfInteger.def("ChangeFind", (TColStd_ListOfInteger & (TopTools_DataMapOfShapeListOfInteger::*)(const TopoDS_Shape &)) &TopTools_DataMapOfShapeListOfInteger::ChangeFind, "ChangeFind returns mofifiable Item by Key. Raises if Key was not bound", py::arg("theKey"));
	cls_TopTools_DataMapOfShapeListOfInteger.def("__call__", (TColStd_ListOfInteger & (TopTools_DataMapOfShapeListOfInteger::*)(const TopoDS_Shape &)) &TopTools_DataMapOfShapeListOfInteger::operator(), py::is_operator(), "operator ()", py::arg("theKey"));
	cls_TopTools_DataMapOfShapeListOfInteger.def("Clear", [](TopTools_DataMapOfShapeListOfInteger &self) -> void { return self.Clear(); });
	cls_TopTools_DataMapOfShapeListOfInteger.def("Clear", (void (TopTools_DataMapOfShapeListOfInteger::*)(const Standard_Boolean)) &TopTools_DataMapOfShapeListOfInteger::Clear, "Clear data. If doReleaseMemory is false then the table of buckets is not released and will be reused.", py::arg("doReleaseMemory"));
	cls_TopTools_DataMapOfShapeListOfInteger.def("Clear", (void (TopTools_DataMapOfShapeListOfInteger::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &TopTools_DataMapOfShapeListOfInteger::Clear, "Clear data and reset allocator", py::arg("theAllocator"));
	cls_TopTools_DataMapOfShapeListOfInteger.def("Size", (Standard_Integer (TopTools_DataMapOfShapeListOfInteger::*)() const ) &TopTools_DataMapOfShapeListOfInteger::Size, "Size");
	cls_TopTools_DataMapOfShapeListOfInteger.def("__iter__", [](const TopTools_DataMapOfShapeListOfInteger &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\TopTools_DataMapOfShapeListOfInteger.hxx
	// C:\Miniconda\envs\occt\Library\include\opencascade\TopTools_HArray1OfShape.hxx
	py::class_<TopTools_HArray1OfShape, opencascade::handle<TopTools_HArray1OfShape>, TopTools_Array1OfShape, Standard_Transient> cls_TopTools_HArray1OfShape(mod, "TopTools_HArray1OfShape", "None");
	cls_TopTools_HArray1OfShape.def(py::init<const Standard_Integer, const Standard_Integer>(), py::arg("theLower"), py::arg("theUpper"));
	cls_TopTools_HArray1OfShape.def(py::init<const Standard_Integer, const Standard_Integer, const TopTools_Array1OfShape::value_type &>(), py::arg("theLower"), py::arg("theUpper"), py::arg("theValue"));
	cls_TopTools_HArray1OfShape.def(py::init<const TopTools_Array1OfShape &>(), py::arg("theOther"));
	cls_TopTools_HArray1OfShape.def("Array1", (const TopTools_Array1OfShape & (TopTools_HArray1OfShape::*)() const ) &TopTools_HArray1OfShape::Array1, "None");
	cls_TopTools_HArray1OfShape.def("ChangeArray1", (TopTools_Array1OfShape & (TopTools_HArray1OfShape::*)()) &TopTools_HArray1OfShape::ChangeArray1, "None");
	cls_TopTools_HArray1OfShape.def_static("get_type_name_", (const char * (*)()) &TopTools_HArray1OfShape::get_type_name, "None");
	cls_TopTools_HArray1OfShape.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &TopTools_HArray1OfShape::get_type_descriptor, "None");
	cls_TopTools_HArray1OfShape.def("DynamicType", (const opencascade::handle<Standard_Type> & (TopTools_HArray1OfShape::*)() const ) &TopTools_HArray1OfShape::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\TopTools_HArray2OfShape.hxx
	py::class_<TopTools_HArray2OfShape, opencascade::handle<TopTools_HArray2OfShape>, TopTools_Array2OfShape, Standard_Transient> cls_TopTools_HArray2OfShape(mod, "TopTools_HArray2OfShape", "None");
	cls_TopTools_HArray2OfShape.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer>(), py::arg("theRowLow"), py::arg("theRowUpp"), py::arg("theColLow"), py::arg("theColUpp"));
	cls_TopTools_HArray2OfShape.def(py::init<const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const TopTools_Array2OfShape::value_type &>(), py::arg("theRowLow"), py::arg("theRowUpp"), py::arg("theColLow"), py::arg("theColUpp"), py::arg("theValue"));
	cls_TopTools_HArray2OfShape.def(py::init<const TopTools_Array2OfShape &>(), py::arg("theOther"));
	cls_TopTools_HArray2OfShape.def("Array2", (const TopTools_Array2OfShape & (TopTools_HArray2OfShape::*)() const ) &TopTools_HArray2OfShape::Array2, "None");
	cls_TopTools_HArray2OfShape.def("ChangeArray2", (TopTools_Array2OfShape & (TopTools_HArray2OfShape::*)()) &TopTools_HArray2OfShape::ChangeArray2, "None");
	cls_TopTools_HArray2OfShape.def_static("get_type_name_", (const char * (*)()) &TopTools_HArray2OfShape::get_type_name, "None");
	cls_TopTools_HArray2OfShape.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &TopTools_HArray2OfShape::get_type_descriptor, "None");
	cls_TopTools_HArray2OfShape.def("DynamicType", (const opencascade::handle<Standard_Type> & (TopTools_HArray2OfShape::*)() const ) &TopTools_HArray2OfShape::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_DataMap.hxx
	py::class_<TopTools_DataMapOfIntegerShape, std::unique_ptr<TopTools_DataMapOfIntegerShape, Deleter<TopTools_DataMapOfIntegerShape>>, NCollection_BaseMap> cls_TopTools_DataMapOfIntegerShape(mod, "TopTools_DataMapOfIntegerShape", "Purpose: The DataMap is a Map to store keys with associated Items. See Map from NCollection for a discussion about the number of buckets.");
	cls_TopTools_DataMapOfIntegerShape.def(py::init<>());
	cls_TopTools_DataMapOfIntegerShape.def(py::init<const Standard_Integer>(), py::arg("NbBuckets"));
	cls_TopTools_DataMapOfIntegerShape.def(py::init<const Standard_Integer, const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("NbBuckets"), py::arg("theAllocator"));
	cls_TopTools_DataMapOfIntegerShape.def(py::init([] (const TopTools_DataMapOfIntegerShape &other) {return new TopTools_DataMapOfIntegerShape(other);}), "Copy constructor", py::arg("other"));
	cls_TopTools_DataMapOfIntegerShape.def("begin", (TopTools_DataMapOfIntegerShape::iterator (TopTools_DataMapOfIntegerShape::*)() const ) &TopTools_DataMapOfIntegerShape::begin, "Returns an iterator pointing to the first element in the map.");
	cls_TopTools_DataMapOfIntegerShape.def("end", (TopTools_DataMapOfIntegerShape::iterator (TopTools_DataMapOfIntegerShape::*)() const ) &TopTools_DataMapOfIntegerShape::end, "Returns an iterator referring to the past-the-end element in the map.");
	cls_TopTools_DataMapOfIntegerShape.def("cbegin", (TopTools_DataMapOfIntegerShape::const_iterator (TopTools_DataMapOfIntegerShape::*)() const ) &TopTools_DataMapOfIntegerShape::cbegin, "Returns a const iterator pointing to the first element in the map.");
	cls_TopTools_DataMapOfIntegerShape.def("cend", (TopTools_DataMapOfIntegerShape::const_iterator (TopTools_DataMapOfIntegerShape::*)() const ) &TopTools_DataMapOfIntegerShape::cend, "Returns a const iterator referring to the past-the-end element in the map.");
	cls_TopTools_DataMapOfIntegerShape.def("Exchange", (void (TopTools_DataMapOfIntegerShape::*)(TopTools_DataMapOfIntegerShape &)) &TopTools_DataMapOfIntegerShape::Exchange, "Exchange the content of two maps without re-allocations. Notice that allocators will be swapped as well!", py::arg("theOther"));
	cls_TopTools_DataMapOfIntegerShape.def("Assign", (TopTools_DataMapOfIntegerShape & (TopTools_DataMapOfIntegerShape::*)(const TopTools_DataMapOfIntegerShape &)) &TopTools_DataMapOfIntegerShape::Assign, "Assignment. This method does not change the internal allocator.", py::arg("theOther"));
	cls_TopTools_DataMapOfIntegerShape.def("assign", (TopTools_DataMapOfIntegerShape & (TopTools_DataMapOfIntegerShape::*)(const TopTools_DataMapOfIntegerShape &)) &TopTools_DataMapOfIntegerShape::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	cls_TopTools_DataMapOfIntegerShape.def("ReSize", (void (TopTools_DataMapOfIntegerShape::*)(const Standard_Integer)) &TopTools_DataMapOfIntegerShape::ReSize, "ReSize", py::arg("N"));
	cls_TopTools_DataMapOfIntegerShape.def("Bind", (Standard_Boolean (TopTools_DataMapOfIntegerShape::*)(const Standard_Integer &, const TopoDS_Shape &)) &TopTools_DataMapOfIntegerShape::Bind, "Bind binds Item to Key in map. Returns Standard_True if Key was not exist in the map. If the Key was already bound, the Item will be rebinded and Standard_False will be returned.", py::arg("theKey"), py::arg("theItem"));
	// FIXME cls_TopTools_DataMapOfIntegerShape.def("Bound", (TopoDS_Shape * (TopTools_DataMapOfIntegerShape::*)(const Standard_Integer &, const TopoDS_Shape &)) &TopTools_DataMapOfIntegerShape::Bound, "Bound binds Item to Key in map. Returns modifiable Item", py::arg("theKey"), py::arg("theItem"));
	cls_TopTools_DataMapOfIntegerShape.def("IsBound", (Standard_Boolean (TopTools_DataMapOfIntegerShape::*)(const Standard_Integer &) const ) &TopTools_DataMapOfIntegerShape::IsBound, "IsBound", py::arg("theKey"));
	cls_TopTools_DataMapOfIntegerShape.def("UnBind", (Standard_Boolean (TopTools_DataMapOfIntegerShape::*)(const Standard_Integer &)) &TopTools_DataMapOfIntegerShape::UnBind, "UnBind removes Item Key pair from map", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfIntegerShape.def("Seek", (const TopoDS_Shape * (TopTools_DataMapOfIntegerShape::*)(const Standard_Integer &) const ) &TopTools_DataMapOfIntegerShape::Seek, "Seek returns pointer to Item by Key. Returns NULL is Key was not bound.", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfIntegerShape.def("Find", (const TopoDS_Shape & (TopTools_DataMapOfIntegerShape::*)(const Standard_Integer &) const ) &TopTools_DataMapOfIntegerShape::Find, "Find returns the Item for Key. Raises if Key was not bound", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfIntegerShape.def("Find", (Standard_Boolean (TopTools_DataMapOfIntegerShape::*)(const Standard_Integer &, TopoDS_Shape &) const ) &TopTools_DataMapOfIntegerShape::Find, "Find Item for key with copying.", py::arg("theKey"), py::arg("theValue"));
	cls_TopTools_DataMapOfIntegerShape.def("__call__", (const TopoDS_Shape & (TopTools_DataMapOfIntegerShape::*)(const Standard_Integer &) const ) &TopTools_DataMapOfIntegerShape::operator(), py::is_operator(), "operator ()", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfIntegerShape.def("ChangeSeek", (TopoDS_Shape * (TopTools_DataMapOfIntegerShape::*)(const Standard_Integer &)) &TopTools_DataMapOfIntegerShape::ChangeSeek, "ChangeSeek returns modifiable pointer to Item by Key. Returns NULL is Key was not bound.", py::arg("theKey"));
	cls_TopTools_DataMapOfIntegerShape.def("ChangeFind", (TopoDS_Shape & (TopTools_DataMapOfIntegerShape::*)(const Standard_Integer &)) &TopTools_DataMapOfIntegerShape::ChangeFind, "ChangeFind returns mofifiable Item by Key. Raises if Key was not bound", py::arg("theKey"));
	cls_TopTools_DataMapOfIntegerShape.def("__call__", (TopoDS_Shape & (TopTools_DataMapOfIntegerShape::*)(const Standard_Integer &)) &TopTools_DataMapOfIntegerShape::operator(), py::is_operator(), "operator ()", py::arg("theKey"));
	cls_TopTools_DataMapOfIntegerShape.def("Clear", [](TopTools_DataMapOfIntegerShape &self) -> void { return self.Clear(); });
	cls_TopTools_DataMapOfIntegerShape.def("Clear", (void (TopTools_DataMapOfIntegerShape::*)(const Standard_Boolean)) &TopTools_DataMapOfIntegerShape::Clear, "Clear data. If doReleaseMemory is false then the table of buckets is not released and will be reused.", py::arg("doReleaseMemory"));
	cls_TopTools_DataMapOfIntegerShape.def("Clear", (void (TopTools_DataMapOfIntegerShape::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &TopTools_DataMapOfIntegerShape::Clear, "Clear data and reset allocator", py::arg("theAllocator"));
	cls_TopTools_DataMapOfIntegerShape.def("Size", (Standard_Integer (TopTools_DataMapOfIntegerShape::*)() const ) &TopTools_DataMapOfIntegerShape::Size, "Size");
	cls_TopTools_DataMapOfIntegerShape.def("__iter__", [](const TopTools_DataMapOfIntegerShape &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\TopTools_DataMapOfIntegerShape.hxx
	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_DataMap.hxx
	py::class_<TopTools_DataMapOfShapeReal, std::unique_ptr<TopTools_DataMapOfShapeReal, Deleter<TopTools_DataMapOfShapeReal>>, NCollection_BaseMap> cls_TopTools_DataMapOfShapeReal(mod, "TopTools_DataMapOfShapeReal", "Purpose: The DataMap is a Map to store keys with associated Items. See Map from NCollection for a discussion about the number of buckets.");
	cls_TopTools_DataMapOfShapeReal.def(py::init<>());
	cls_TopTools_DataMapOfShapeReal.def(py::init<const Standard_Integer>(), py::arg("NbBuckets"));
	cls_TopTools_DataMapOfShapeReal.def(py::init<const Standard_Integer, const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("NbBuckets"), py::arg("theAllocator"));
	cls_TopTools_DataMapOfShapeReal.def(py::init([] (const TopTools_DataMapOfShapeReal &other) {return new TopTools_DataMapOfShapeReal(other);}), "Copy constructor", py::arg("other"));
	cls_TopTools_DataMapOfShapeReal.def("begin", (TopTools_DataMapOfShapeReal::iterator (TopTools_DataMapOfShapeReal::*)() const ) &TopTools_DataMapOfShapeReal::begin, "Returns an iterator pointing to the first element in the map.");
	cls_TopTools_DataMapOfShapeReal.def("end", (TopTools_DataMapOfShapeReal::iterator (TopTools_DataMapOfShapeReal::*)() const ) &TopTools_DataMapOfShapeReal::end, "Returns an iterator referring to the past-the-end element in the map.");
	cls_TopTools_DataMapOfShapeReal.def("cbegin", (TopTools_DataMapOfShapeReal::const_iterator (TopTools_DataMapOfShapeReal::*)() const ) &TopTools_DataMapOfShapeReal::cbegin, "Returns a const iterator pointing to the first element in the map.");
	cls_TopTools_DataMapOfShapeReal.def("cend", (TopTools_DataMapOfShapeReal::const_iterator (TopTools_DataMapOfShapeReal::*)() const ) &TopTools_DataMapOfShapeReal::cend, "Returns a const iterator referring to the past-the-end element in the map.");
	cls_TopTools_DataMapOfShapeReal.def("Exchange", (void (TopTools_DataMapOfShapeReal::*)(TopTools_DataMapOfShapeReal &)) &TopTools_DataMapOfShapeReal::Exchange, "Exchange the content of two maps without re-allocations. Notice that allocators will be swapped as well!", py::arg("theOther"));
	cls_TopTools_DataMapOfShapeReal.def("Assign", (TopTools_DataMapOfShapeReal & (TopTools_DataMapOfShapeReal::*)(const TopTools_DataMapOfShapeReal &)) &TopTools_DataMapOfShapeReal::Assign, "Assignment. This method does not change the internal allocator.", py::arg("theOther"));
	cls_TopTools_DataMapOfShapeReal.def("assign", (TopTools_DataMapOfShapeReal & (TopTools_DataMapOfShapeReal::*)(const TopTools_DataMapOfShapeReal &)) &TopTools_DataMapOfShapeReal::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	cls_TopTools_DataMapOfShapeReal.def("ReSize", (void (TopTools_DataMapOfShapeReal::*)(const Standard_Integer)) &TopTools_DataMapOfShapeReal::ReSize, "ReSize", py::arg("N"));
	cls_TopTools_DataMapOfShapeReal.def("Bind", (Standard_Boolean (TopTools_DataMapOfShapeReal::*)(const TopoDS_Shape &, const Standard_Real &)) &TopTools_DataMapOfShapeReal::Bind, "Bind binds Item to Key in map. Returns Standard_True if Key was not exist in the map. If the Key was already bound, the Item will be rebinded and Standard_False will be returned.", py::arg("theKey"), py::arg("theItem"));
	// FIXME cls_TopTools_DataMapOfShapeReal.def("Bound", (Standard_Real * (TopTools_DataMapOfShapeReal::*)(const TopoDS_Shape &, const Standard_Real &)) &TopTools_DataMapOfShapeReal::Bound, "Bound binds Item to Key in map. Returns modifiable Item", py::arg("theKey"), py::arg("theItem"));
	cls_TopTools_DataMapOfShapeReal.def("IsBound", (Standard_Boolean (TopTools_DataMapOfShapeReal::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfShapeReal::IsBound, "IsBound", py::arg("theKey"));
	cls_TopTools_DataMapOfShapeReal.def("UnBind", (Standard_Boolean (TopTools_DataMapOfShapeReal::*)(const TopoDS_Shape &)) &TopTools_DataMapOfShapeReal::UnBind, "UnBind removes Item Key pair from map", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfShapeReal.def("Seek", (const Standard_Real * (TopTools_DataMapOfShapeReal::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfShapeReal::Seek, "Seek returns pointer to Item by Key. Returns NULL is Key was not bound.", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfShapeReal.def("Find", (const Standard_Real & (TopTools_DataMapOfShapeReal::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfShapeReal::Find, "Find returns the Item for Key. Raises if Key was not bound", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfShapeReal.def("Find", (Standard_Boolean (TopTools_DataMapOfShapeReal::*)(const TopoDS_Shape &, Standard_Real &) const ) &TopTools_DataMapOfShapeReal::Find, "Find Item for key with copying.", py::arg("theKey"), py::arg("theValue"));
	cls_TopTools_DataMapOfShapeReal.def("__call__", (const Standard_Real & (TopTools_DataMapOfShapeReal::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfShapeReal::operator(), py::is_operator(), "operator ()", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfShapeReal.def("ChangeSeek", (Standard_Real * (TopTools_DataMapOfShapeReal::*)(const TopoDS_Shape &)) &TopTools_DataMapOfShapeReal::ChangeSeek, "ChangeSeek returns modifiable pointer to Item by Key. Returns NULL is Key was not bound.", py::arg("theKey"));
	cls_TopTools_DataMapOfShapeReal.def("ChangeFind", (Standard_Real & (TopTools_DataMapOfShapeReal::*)(const TopoDS_Shape &)) &TopTools_DataMapOfShapeReal::ChangeFind, "ChangeFind returns mofifiable Item by Key. Raises if Key was not bound", py::arg("theKey"));
	cls_TopTools_DataMapOfShapeReal.def("__call__", (Standard_Real & (TopTools_DataMapOfShapeReal::*)(const TopoDS_Shape &)) &TopTools_DataMapOfShapeReal::operator(), py::is_operator(), "operator ()", py::arg("theKey"));
	cls_TopTools_DataMapOfShapeReal.def("Clear", [](TopTools_DataMapOfShapeReal &self) -> void { return self.Clear(); });
	cls_TopTools_DataMapOfShapeReal.def("Clear", (void (TopTools_DataMapOfShapeReal::*)(const Standard_Boolean)) &TopTools_DataMapOfShapeReal::Clear, "Clear data. If doReleaseMemory is false then the table of buckets is not released and will be reused.", py::arg("doReleaseMemory"));
	cls_TopTools_DataMapOfShapeReal.def("Clear", (void (TopTools_DataMapOfShapeReal::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &TopTools_DataMapOfShapeReal::Clear, "Clear data and reset allocator", py::arg("theAllocator"));
	cls_TopTools_DataMapOfShapeReal.def("Size", (Standard_Integer (TopTools_DataMapOfShapeReal::*)() const ) &TopTools_DataMapOfShapeReal::Size, "Size");
	cls_TopTools_DataMapOfShapeReal.def("__iter__", [](const TopTools_DataMapOfShapeReal &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\TopTools_DataMapOfShapeReal.hxx
	// C:\Miniconda\envs\occt\Library\include\opencascade\TopTools_HArray1OfListOfShape.hxx
	py::class_<TopTools_HArray1OfListOfShape, opencascade::handle<TopTools_HArray1OfListOfShape>, TopTools_Array1OfListOfShape, Standard_Transient> cls_TopTools_HArray1OfListOfShape(mod, "TopTools_HArray1OfListOfShape", "None");
	cls_TopTools_HArray1OfListOfShape.def(py::init<const Standard_Integer, const Standard_Integer>(), py::arg("theLower"), py::arg("theUpper"));
	cls_TopTools_HArray1OfListOfShape.def(py::init<const Standard_Integer, const Standard_Integer, const TopTools_Array1OfListOfShape::value_type &>(), py::arg("theLower"), py::arg("theUpper"), py::arg("theValue"));
	cls_TopTools_HArray1OfListOfShape.def(py::init<const TopTools_Array1OfListOfShape &>(), py::arg("theOther"));
	cls_TopTools_HArray1OfListOfShape.def("Array1", (const TopTools_Array1OfListOfShape & (TopTools_HArray1OfListOfShape::*)() const ) &TopTools_HArray1OfListOfShape::Array1, "None");
	cls_TopTools_HArray1OfListOfShape.def("ChangeArray1", (TopTools_Array1OfListOfShape & (TopTools_HArray1OfListOfShape::*)()) &TopTools_HArray1OfListOfShape::ChangeArray1, "None");
	cls_TopTools_HArray1OfListOfShape.def_static("get_type_name_", (const char * (*)()) &TopTools_HArray1OfListOfShape::get_type_name, "None");
	cls_TopTools_HArray1OfListOfShape.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &TopTools_HArray1OfListOfShape::get_type_descriptor, "None");
	cls_TopTools_HArray1OfListOfShape.def("DynamicType", (const opencascade::handle<Standard_Type> & (TopTools_HArray1OfListOfShape::*)() const ) &TopTools_HArray1OfListOfShape::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_IndexedDataMap.hxx
	py::class_<TopTools_IndexedDataMapOfShapeAddress, std::unique_ptr<TopTools_IndexedDataMapOfShapeAddress, Deleter<TopTools_IndexedDataMapOfShapeAddress>>, NCollection_BaseMap> cls_TopTools_IndexedDataMapOfShapeAddress(mod, "TopTools_IndexedDataMapOfShapeAddress", "Purpose: An indexed map is used to store keys and to bind an index to them. Each new key stored in the map gets an index. Index are incremented as keys are stored in the map. A key can be found by the index and an index by the key. No key but the last can be removed so the indices are in the range 1.. Extent. An Item is stored with each key.");
	cls_TopTools_IndexedDataMapOfShapeAddress.def(py::init<>());
	cls_TopTools_IndexedDataMapOfShapeAddress.def(py::init<const Standard_Integer>(), py::arg("NbBuckets"));
	cls_TopTools_IndexedDataMapOfShapeAddress.def(py::init<const Standard_Integer, const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("NbBuckets"), py::arg("theAllocator"));
	cls_TopTools_IndexedDataMapOfShapeAddress.def(py::init([] (const TopTools_IndexedDataMapOfShapeAddress &other) {return new TopTools_IndexedDataMapOfShapeAddress(other);}), "Copy constructor", py::arg("other"));
	cls_TopTools_IndexedDataMapOfShapeAddress.def("begin", (TopTools_IndexedDataMapOfShapeAddress::iterator (TopTools_IndexedDataMapOfShapeAddress::*)() const ) &TopTools_IndexedDataMapOfShapeAddress::begin, "Returns an iterator pointing to the first element in the map.");
	cls_TopTools_IndexedDataMapOfShapeAddress.def("end", (TopTools_IndexedDataMapOfShapeAddress::iterator (TopTools_IndexedDataMapOfShapeAddress::*)() const ) &TopTools_IndexedDataMapOfShapeAddress::end, "Returns an iterator referring to the past-the-end element in the map.");
	cls_TopTools_IndexedDataMapOfShapeAddress.def("cbegin", (TopTools_IndexedDataMapOfShapeAddress::const_iterator (TopTools_IndexedDataMapOfShapeAddress::*)() const ) &TopTools_IndexedDataMapOfShapeAddress::cbegin, "Returns a const iterator pointing to the first element in the map.");
	cls_TopTools_IndexedDataMapOfShapeAddress.def("cend", (TopTools_IndexedDataMapOfShapeAddress::const_iterator (TopTools_IndexedDataMapOfShapeAddress::*)() const ) &TopTools_IndexedDataMapOfShapeAddress::cend, "Returns a const iterator referring to the past-the-end element in the map.");
	cls_TopTools_IndexedDataMapOfShapeAddress.def("Exchange", (void (TopTools_IndexedDataMapOfShapeAddress::*)(TopTools_IndexedDataMapOfShapeAddress &)) &TopTools_IndexedDataMapOfShapeAddress::Exchange, "Exchange the content of two maps without re-allocations. Notice that allocators will be swapped as well!", py::arg("theOther"));
	cls_TopTools_IndexedDataMapOfShapeAddress.def("Assign", (TopTools_IndexedDataMapOfShapeAddress & (TopTools_IndexedDataMapOfShapeAddress::*)(const TopTools_IndexedDataMapOfShapeAddress &)) &TopTools_IndexedDataMapOfShapeAddress::Assign, "Assignment. This method does not change the internal allocator.", py::arg("theOther"));
	cls_TopTools_IndexedDataMapOfShapeAddress.def("assign", (TopTools_IndexedDataMapOfShapeAddress & (TopTools_IndexedDataMapOfShapeAddress::*)(const TopTools_IndexedDataMapOfShapeAddress &)) &TopTools_IndexedDataMapOfShapeAddress::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	cls_TopTools_IndexedDataMapOfShapeAddress.def("ReSize", (void (TopTools_IndexedDataMapOfShapeAddress::*)(const Standard_Integer)) &TopTools_IndexedDataMapOfShapeAddress::ReSize, "ReSize", py::arg("N"));
	cls_TopTools_IndexedDataMapOfShapeAddress.def("Add", (Standard_Integer (TopTools_IndexedDataMapOfShapeAddress::*)(const TopoDS_Shape &, const Standard_Address &)) &TopTools_IndexedDataMapOfShapeAddress::Add, "Add", py::arg("theKey1"), py::arg("theItem"));
	cls_TopTools_IndexedDataMapOfShapeAddress.def("Contains", (Standard_Boolean (TopTools_IndexedDataMapOfShapeAddress::*)(const TopoDS_Shape &) const ) &TopTools_IndexedDataMapOfShapeAddress::Contains, "Contains", py::arg("theKey1"));
	cls_TopTools_IndexedDataMapOfShapeAddress.def("Substitute", (void (TopTools_IndexedDataMapOfShapeAddress::*)(const Standard_Integer, const TopoDS_Shape &, const Standard_Address &)) &TopTools_IndexedDataMapOfShapeAddress::Substitute, "Substitute", py::arg("theIndex"), py::arg("theKey1"), py::arg("theItem"));
	cls_TopTools_IndexedDataMapOfShapeAddress.def("Swap", (void (TopTools_IndexedDataMapOfShapeAddress::*)(const Standard_Integer, const Standard_Integer)) &TopTools_IndexedDataMapOfShapeAddress::Swap, "Swaps two elements with the given indices.", py::arg("theIndex1"), py::arg("theIndex2"));
	cls_TopTools_IndexedDataMapOfShapeAddress.def("RemoveLast", (void (TopTools_IndexedDataMapOfShapeAddress::*)()) &TopTools_IndexedDataMapOfShapeAddress::RemoveLast, "RemoveLast");
	cls_TopTools_IndexedDataMapOfShapeAddress.def("RemoveFromIndex", (void (TopTools_IndexedDataMapOfShapeAddress::*)(const Standard_Integer)) &TopTools_IndexedDataMapOfShapeAddress::RemoveFromIndex, "Remove the key of the given index. Caution! The index of the last key can be changed.", py::arg("theKey2"));
	cls_TopTools_IndexedDataMapOfShapeAddress.def("RemoveKey", (void (TopTools_IndexedDataMapOfShapeAddress::*)(const TopoDS_Shape &)) &TopTools_IndexedDataMapOfShapeAddress::RemoveKey, "Remove the given key. Caution! The index of the last key can be changed.", py::arg("theKey1"));
	cls_TopTools_IndexedDataMapOfShapeAddress.def("FindKey", (const TopoDS_Shape & (TopTools_IndexedDataMapOfShapeAddress::*)(const Standard_Integer) const ) &TopTools_IndexedDataMapOfShapeAddress::FindKey, "FindKey", py::arg("theKey2"));
	cls_TopTools_IndexedDataMapOfShapeAddress.def("FindFromIndex", (const Standard_Address & (TopTools_IndexedDataMapOfShapeAddress::*)(const Standard_Integer) const ) &TopTools_IndexedDataMapOfShapeAddress::FindFromIndex, "FindFromIndex", py::arg("theKey2"));
	cls_TopTools_IndexedDataMapOfShapeAddress.def("__call__", (const Standard_Address & (TopTools_IndexedDataMapOfShapeAddress::*)(const Standard_Integer) const ) &TopTools_IndexedDataMapOfShapeAddress::operator(), py::is_operator(), "operator ()", py::arg("theKey2"));
	cls_TopTools_IndexedDataMapOfShapeAddress.def("ChangeFromIndex", (Standard_Address & (TopTools_IndexedDataMapOfShapeAddress::*)(const Standard_Integer)) &TopTools_IndexedDataMapOfShapeAddress::ChangeFromIndex, "ChangeFromIndex", py::arg("theKey2"));
	cls_TopTools_IndexedDataMapOfShapeAddress.def("__call__", (Standard_Address & (TopTools_IndexedDataMapOfShapeAddress::*)(const Standard_Integer)) &TopTools_IndexedDataMapOfShapeAddress::operator(), py::is_operator(), "operator ()", py::arg("theKey2"));
	cls_TopTools_IndexedDataMapOfShapeAddress.def("FindIndex", (Standard_Integer (TopTools_IndexedDataMapOfShapeAddress::*)(const TopoDS_Shape &) const ) &TopTools_IndexedDataMapOfShapeAddress::FindIndex, "FindIndex", py::arg("theKey1"));
	cls_TopTools_IndexedDataMapOfShapeAddress.def("FindFromKey", (const Standard_Address & (TopTools_IndexedDataMapOfShapeAddress::*)(const TopoDS_Shape &) const ) &TopTools_IndexedDataMapOfShapeAddress::FindFromKey, "FindFromKey", py::arg("theKey1"));
	cls_TopTools_IndexedDataMapOfShapeAddress.def("ChangeFromKey", (Standard_Address & (TopTools_IndexedDataMapOfShapeAddress::*)(const TopoDS_Shape &)) &TopTools_IndexedDataMapOfShapeAddress::ChangeFromKey, "ChangeFromKey", py::arg("theKey1"));
	// FIXME cls_TopTools_IndexedDataMapOfShapeAddress.def("Seek", (const Standard_Address * (TopTools_IndexedDataMapOfShapeAddress::*)(const TopoDS_Shape &) const ) &TopTools_IndexedDataMapOfShapeAddress::Seek, "Seek returns pointer to Item by Key. Returns NULL if Key was not found.", py::arg("theKey1"));
	// FIXME cls_TopTools_IndexedDataMapOfShapeAddress.def("ChangeSeek", (Standard_Address * (TopTools_IndexedDataMapOfShapeAddress::*)(const TopoDS_Shape &)) &TopTools_IndexedDataMapOfShapeAddress::ChangeSeek, "ChangeSeek returns modifiable pointer to Item by Key. Returns NULL if Key was not found.", py::arg("theKey1"));
	cls_TopTools_IndexedDataMapOfShapeAddress.def("FindFromKey", (Standard_Boolean (TopTools_IndexedDataMapOfShapeAddress::*)(const TopoDS_Shape &, Standard_Address &) const ) &TopTools_IndexedDataMapOfShapeAddress::FindFromKey, "Find value for key with copying.", py::arg("theKey1"), py::arg("theValue"));
	cls_TopTools_IndexedDataMapOfShapeAddress.def("Clear", [](TopTools_IndexedDataMapOfShapeAddress &self) -> void { return self.Clear(); });
	cls_TopTools_IndexedDataMapOfShapeAddress.def("Clear", (void (TopTools_IndexedDataMapOfShapeAddress::*)(const Standard_Boolean)) &TopTools_IndexedDataMapOfShapeAddress::Clear, "Clear data. If doReleaseMemory is false then the table of buckets is not released and will be reused.", py::arg("doReleaseMemory"));
	cls_TopTools_IndexedDataMapOfShapeAddress.def("Clear", (void (TopTools_IndexedDataMapOfShapeAddress::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &TopTools_IndexedDataMapOfShapeAddress::Clear, "Clear data and reset allocator", py::arg("theAllocator"));
	cls_TopTools_IndexedDataMapOfShapeAddress.def("Size", (Standard_Integer (TopTools_IndexedDataMapOfShapeAddress::*)() const ) &TopTools_IndexedDataMapOfShapeAddress::Size, "Size");
	cls_TopTools_IndexedDataMapOfShapeAddress.def("__iter__", [](const TopTools_IndexedDataMapOfShapeAddress &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_DataMap.hxx
	py::class_<TopTools_DataMapOfOrientedShapeShape, std::unique_ptr<TopTools_DataMapOfOrientedShapeShape, Deleter<TopTools_DataMapOfOrientedShapeShape>>, NCollection_BaseMap> cls_TopTools_DataMapOfOrientedShapeShape(mod, "TopTools_DataMapOfOrientedShapeShape", "Purpose: The DataMap is a Map to store keys with associated Items. See Map from NCollection for a discussion about the number of buckets.");
	cls_TopTools_DataMapOfOrientedShapeShape.def(py::init<>());
	cls_TopTools_DataMapOfOrientedShapeShape.def(py::init<const Standard_Integer>(), py::arg("NbBuckets"));
	cls_TopTools_DataMapOfOrientedShapeShape.def(py::init<const Standard_Integer, const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("NbBuckets"), py::arg("theAllocator"));
	cls_TopTools_DataMapOfOrientedShapeShape.def(py::init([] (const TopTools_DataMapOfOrientedShapeShape &other) {return new TopTools_DataMapOfOrientedShapeShape(other);}), "Copy constructor", py::arg("other"));
	cls_TopTools_DataMapOfOrientedShapeShape.def("begin", (TopTools_DataMapOfOrientedShapeShape::iterator (TopTools_DataMapOfOrientedShapeShape::*)() const ) &TopTools_DataMapOfOrientedShapeShape::begin, "Returns an iterator pointing to the first element in the map.");
	cls_TopTools_DataMapOfOrientedShapeShape.def("end", (TopTools_DataMapOfOrientedShapeShape::iterator (TopTools_DataMapOfOrientedShapeShape::*)() const ) &TopTools_DataMapOfOrientedShapeShape::end, "Returns an iterator referring to the past-the-end element in the map.");
	cls_TopTools_DataMapOfOrientedShapeShape.def("cbegin", (TopTools_DataMapOfOrientedShapeShape::const_iterator (TopTools_DataMapOfOrientedShapeShape::*)() const ) &TopTools_DataMapOfOrientedShapeShape::cbegin, "Returns a const iterator pointing to the first element in the map.");
	cls_TopTools_DataMapOfOrientedShapeShape.def("cend", (TopTools_DataMapOfOrientedShapeShape::const_iterator (TopTools_DataMapOfOrientedShapeShape::*)() const ) &TopTools_DataMapOfOrientedShapeShape::cend, "Returns a const iterator referring to the past-the-end element in the map.");
	cls_TopTools_DataMapOfOrientedShapeShape.def("Exchange", (void (TopTools_DataMapOfOrientedShapeShape::*)(TopTools_DataMapOfOrientedShapeShape &)) &TopTools_DataMapOfOrientedShapeShape::Exchange, "Exchange the content of two maps without re-allocations. Notice that allocators will be swapped as well!", py::arg("theOther"));
	cls_TopTools_DataMapOfOrientedShapeShape.def("Assign", (TopTools_DataMapOfOrientedShapeShape & (TopTools_DataMapOfOrientedShapeShape::*)(const TopTools_DataMapOfOrientedShapeShape &)) &TopTools_DataMapOfOrientedShapeShape::Assign, "Assignment. This method does not change the internal allocator.", py::arg("theOther"));
	cls_TopTools_DataMapOfOrientedShapeShape.def("assign", (TopTools_DataMapOfOrientedShapeShape & (TopTools_DataMapOfOrientedShapeShape::*)(const TopTools_DataMapOfOrientedShapeShape &)) &TopTools_DataMapOfOrientedShapeShape::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	cls_TopTools_DataMapOfOrientedShapeShape.def("ReSize", (void (TopTools_DataMapOfOrientedShapeShape::*)(const Standard_Integer)) &TopTools_DataMapOfOrientedShapeShape::ReSize, "ReSize", py::arg("N"));
	cls_TopTools_DataMapOfOrientedShapeShape.def("Bind", (Standard_Boolean (TopTools_DataMapOfOrientedShapeShape::*)(const TopoDS_Shape &, const TopoDS_Shape &)) &TopTools_DataMapOfOrientedShapeShape::Bind, "Bind binds Item to Key in map. Returns Standard_True if Key was not exist in the map. If the Key was already bound, the Item will be rebinded and Standard_False will be returned.", py::arg("theKey"), py::arg("theItem"));
	// FIXME cls_TopTools_DataMapOfOrientedShapeShape.def("Bound", (TopoDS_Shape * (TopTools_DataMapOfOrientedShapeShape::*)(const TopoDS_Shape &, const TopoDS_Shape &)) &TopTools_DataMapOfOrientedShapeShape::Bound, "Bound binds Item to Key in map. Returns modifiable Item", py::arg("theKey"), py::arg("theItem"));
	cls_TopTools_DataMapOfOrientedShapeShape.def("IsBound", (Standard_Boolean (TopTools_DataMapOfOrientedShapeShape::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfOrientedShapeShape::IsBound, "IsBound", py::arg("theKey"));
	cls_TopTools_DataMapOfOrientedShapeShape.def("UnBind", (Standard_Boolean (TopTools_DataMapOfOrientedShapeShape::*)(const TopoDS_Shape &)) &TopTools_DataMapOfOrientedShapeShape::UnBind, "UnBind removes Item Key pair from map", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfOrientedShapeShape.def("Seek", (const TopoDS_Shape * (TopTools_DataMapOfOrientedShapeShape::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfOrientedShapeShape::Seek, "Seek returns pointer to Item by Key. Returns NULL is Key was not bound.", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfOrientedShapeShape.def("Find", (const TopoDS_Shape & (TopTools_DataMapOfOrientedShapeShape::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfOrientedShapeShape::Find, "Find returns the Item for Key. Raises if Key was not bound", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfOrientedShapeShape.def("Find", (Standard_Boolean (TopTools_DataMapOfOrientedShapeShape::*)(const TopoDS_Shape &, TopoDS_Shape &) const ) &TopTools_DataMapOfOrientedShapeShape::Find, "Find Item for key with copying.", py::arg("theKey"), py::arg("theValue"));
	cls_TopTools_DataMapOfOrientedShapeShape.def("__call__", (const TopoDS_Shape & (TopTools_DataMapOfOrientedShapeShape::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfOrientedShapeShape::operator(), py::is_operator(), "operator ()", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfOrientedShapeShape.def("ChangeSeek", (TopoDS_Shape * (TopTools_DataMapOfOrientedShapeShape::*)(const TopoDS_Shape &)) &TopTools_DataMapOfOrientedShapeShape::ChangeSeek, "ChangeSeek returns modifiable pointer to Item by Key. Returns NULL is Key was not bound.", py::arg("theKey"));
	cls_TopTools_DataMapOfOrientedShapeShape.def("ChangeFind", (TopoDS_Shape & (TopTools_DataMapOfOrientedShapeShape::*)(const TopoDS_Shape &)) &TopTools_DataMapOfOrientedShapeShape::ChangeFind, "ChangeFind returns mofifiable Item by Key. Raises if Key was not bound", py::arg("theKey"));
	cls_TopTools_DataMapOfOrientedShapeShape.def("__call__", (TopoDS_Shape & (TopTools_DataMapOfOrientedShapeShape::*)(const TopoDS_Shape &)) &TopTools_DataMapOfOrientedShapeShape::operator(), py::is_operator(), "operator ()", py::arg("theKey"));
	cls_TopTools_DataMapOfOrientedShapeShape.def("Clear", [](TopTools_DataMapOfOrientedShapeShape &self) -> void { return self.Clear(); });
	cls_TopTools_DataMapOfOrientedShapeShape.def("Clear", (void (TopTools_DataMapOfOrientedShapeShape::*)(const Standard_Boolean)) &TopTools_DataMapOfOrientedShapeShape::Clear, "Clear data. If doReleaseMemory is false then the table of buckets is not released and will be reused.", py::arg("doReleaseMemory"));
	cls_TopTools_DataMapOfOrientedShapeShape.def("Clear", (void (TopTools_DataMapOfOrientedShapeShape::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &TopTools_DataMapOfOrientedShapeShape::Clear, "Clear data and reset allocator", py::arg("theAllocator"));
	cls_TopTools_DataMapOfOrientedShapeShape.def("Size", (Standard_Integer (TopTools_DataMapOfOrientedShapeShape::*)() const ) &TopTools_DataMapOfOrientedShapeShape::Size, "Size");
	cls_TopTools_DataMapOfOrientedShapeShape.def("__iter__", [](const TopTools_DataMapOfOrientedShapeShape &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\TopTools_DataMapOfOrientedShapeShape.hxx
	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_DataMap.hxx
	py::class_<TopTools_DataMapOfShapeSequenceOfShape, std::unique_ptr<TopTools_DataMapOfShapeSequenceOfShape, Deleter<TopTools_DataMapOfShapeSequenceOfShape>>, NCollection_BaseMap> cls_TopTools_DataMapOfShapeSequenceOfShape(mod, "TopTools_DataMapOfShapeSequenceOfShape", "Purpose: The DataMap is a Map to store keys with associated Items. See Map from NCollection for a discussion about the number of buckets.");
	cls_TopTools_DataMapOfShapeSequenceOfShape.def(py::init<>());
	cls_TopTools_DataMapOfShapeSequenceOfShape.def(py::init<const Standard_Integer>(), py::arg("NbBuckets"));
	cls_TopTools_DataMapOfShapeSequenceOfShape.def(py::init<const Standard_Integer, const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("NbBuckets"), py::arg("theAllocator"));
	cls_TopTools_DataMapOfShapeSequenceOfShape.def(py::init([] (const TopTools_DataMapOfShapeSequenceOfShape &other) {return new TopTools_DataMapOfShapeSequenceOfShape(other);}), "Copy constructor", py::arg("other"));
	cls_TopTools_DataMapOfShapeSequenceOfShape.def("begin", (TopTools_DataMapOfShapeSequenceOfShape::iterator (TopTools_DataMapOfShapeSequenceOfShape::*)() const ) &TopTools_DataMapOfShapeSequenceOfShape::begin, "Returns an iterator pointing to the first element in the map.");
	cls_TopTools_DataMapOfShapeSequenceOfShape.def("end", (TopTools_DataMapOfShapeSequenceOfShape::iterator (TopTools_DataMapOfShapeSequenceOfShape::*)() const ) &TopTools_DataMapOfShapeSequenceOfShape::end, "Returns an iterator referring to the past-the-end element in the map.");
	cls_TopTools_DataMapOfShapeSequenceOfShape.def("cbegin", (TopTools_DataMapOfShapeSequenceOfShape::const_iterator (TopTools_DataMapOfShapeSequenceOfShape::*)() const ) &TopTools_DataMapOfShapeSequenceOfShape::cbegin, "Returns a const iterator pointing to the first element in the map.");
	cls_TopTools_DataMapOfShapeSequenceOfShape.def("cend", (TopTools_DataMapOfShapeSequenceOfShape::const_iterator (TopTools_DataMapOfShapeSequenceOfShape::*)() const ) &TopTools_DataMapOfShapeSequenceOfShape::cend, "Returns a const iterator referring to the past-the-end element in the map.");
	cls_TopTools_DataMapOfShapeSequenceOfShape.def("Exchange", (void (TopTools_DataMapOfShapeSequenceOfShape::*)(TopTools_DataMapOfShapeSequenceOfShape &)) &TopTools_DataMapOfShapeSequenceOfShape::Exchange, "Exchange the content of two maps without re-allocations. Notice that allocators will be swapped as well!", py::arg("theOther"));
	cls_TopTools_DataMapOfShapeSequenceOfShape.def("Assign", (TopTools_DataMapOfShapeSequenceOfShape & (TopTools_DataMapOfShapeSequenceOfShape::*)(const TopTools_DataMapOfShapeSequenceOfShape &)) &TopTools_DataMapOfShapeSequenceOfShape::Assign, "Assignment. This method does not change the internal allocator.", py::arg("theOther"));
	cls_TopTools_DataMapOfShapeSequenceOfShape.def("assign", (TopTools_DataMapOfShapeSequenceOfShape & (TopTools_DataMapOfShapeSequenceOfShape::*)(const TopTools_DataMapOfShapeSequenceOfShape &)) &TopTools_DataMapOfShapeSequenceOfShape::operator=, py::is_operator(), "Assignment operator", py::arg("theOther"));
	cls_TopTools_DataMapOfShapeSequenceOfShape.def("ReSize", (void (TopTools_DataMapOfShapeSequenceOfShape::*)(const Standard_Integer)) &TopTools_DataMapOfShapeSequenceOfShape::ReSize, "ReSize", py::arg("N"));
	cls_TopTools_DataMapOfShapeSequenceOfShape.def("Bind", (Standard_Boolean (TopTools_DataMapOfShapeSequenceOfShape::*)(const TopoDS_Shape &, const TopTools_SequenceOfShape &)) &TopTools_DataMapOfShapeSequenceOfShape::Bind, "Bind binds Item to Key in map. Returns Standard_True if Key was not exist in the map. If the Key was already bound, the Item will be rebinded and Standard_False will be returned.", py::arg("theKey"), py::arg("theItem"));
	// FIXME cls_TopTools_DataMapOfShapeSequenceOfShape.def("Bound", (TopTools_SequenceOfShape * (TopTools_DataMapOfShapeSequenceOfShape::*)(const TopoDS_Shape &, const TopTools_SequenceOfShape &)) &TopTools_DataMapOfShapeSequenceOfShape::Bound, "Bound binds Item to Key in map. Returns modifiable Item", py::arg("theKey"), py::arg("theItem"));
	cls_TopTools_DataMapOfShapeSequenceOfShape.def("IsBound", (Standard_Boolean (TopTools_DataMapOfShapeSequenceOfShape::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfShapeSequenceOfShape::IsBound, "IsBound", py::arg("theKey"));
	cls_TopTools_DataMapOfShapeSequenceOfShape.def("UnBind", (Standard_Boolean (TopTools_DataMapOfShapeSequenceOfShape::*)(const TopoDS_Shape &)) &TopTools_DataMapOfShapeSequenceOfShape::UnBind, "UnBind removes Item Key pair from map", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfShapeSequenceOfShape.def("Seek", (const TopTools_SequenceOfShape * (TopTools_DataMapOfShapeSequenceOfShape::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfShapeSequenceOfShape::Seek, "Seek returns pointer to Item by Key. Returns NULL is Key was not bound.", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfShapeSequenceOfShape.def("Find", (const TopTools_SequenceOfShape & (TopTools_DataMapOfShapeSequenceOfShape::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfShapeSequenceOfShape::Find, "Find returns the Item for Key. Raises if Key was not bound", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfShapeSequenceOfShape.def("Find", (Standard_Boolean (TopTools_DataMapOfShapeSequenceOfShape::*)(const TopoDS_Shape &, TopTools_SequenceOfShape &) const ) &TopTools_DataMapOfShapeSequenceOfShape::Find, "Find Item for key with copying.", py::arg("theKey"), py::arg("theValue"));
	cls_TopTools_DataMapOfShapeSequenceOfShape.def("__call__", (const TopTools_SequenceOfShape & (TopTools_DataMapOfShapeSequenceOfShape::*)(const TopoDS_Shape &) const ) &TopTools_DataMapOfShapeSequenceOfShape::operator(), py::is_operator(), "operator ()", py::arg("theKey"));
	// FIXME cls_TopTools_DataMapOfShapeSequenceOfShape.def("ChangeSeek", (TopTools_SequenceOfShape * (TopTools_DataMapOfShapeSequenceOfShape::*)(const TopoDS_Shape &)) &TopTools_DataMapOfShapeSequenceOfShape::ChangeSeek, "ChangeSeek returns modifiable pointer to Item by Key. Returns NULL is Key was not bound.", py::arg("theKey"));
	cls_TopTools_DataMapOfShapeSequenceOfShape.def("ChangeFind", (TopTools_SequenceOfShape & (TopTools_DataMapOfShapeSequenceOfShape::*)(const TopoDS_Shape &)) &TopTools_DataMapOfShapeSequenceOfShape::ChangeFind, "ChangeFind returns mofifiable Item by Key. Raises if Key was not bound", py::arg("theKey"));
	cls_TopTools_DataMapOfShapeSequenceOfShape.def("__call__", (TopTools_SequenceOfShape & (TopTools_DataMapOfShapeSequenceOfShape::*)(const TopoDS_Shape &)) &TopTools_DataMapOfShapeSequenceOfShape::operator(), py::is_operator(), "operator ()", py::arg("theKey"));
	cls_TopTools_DataMapOfShapeSequenceOfShape.def("Clear", [](TopTools_DataMapOfShapeSequenceOfShape &self) -> void { return self.Clear(); });
	cls_TopTools_DataMapOfShapeSequenceOfShape.def("Clear", (void (TopTools_DataMapOfShapeSequenceOfShape::*)(const Standard_Boolean)) &TopTools_DataMapOfShapeSequenceOfShape::Clear, "Clear data. If doReleaseMemory is false then the table of buckets is not released and will be reused.", py::arg("doReleaseMemory"));
	cls_TopTools_DataMapOfShapeSequenceOfShape.def("Clear", (void (TopTools_DataMapOfShapeSequenceOfShape::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &TopTools_DataMapOfShapeSequenceOfShape::Clear, "Clear data and reset allocator", py::arg("theAllocator"));
	cls_TopTools_DataMapOfShapeSequenceOfShape.def("Size", (Standard_Integer (TopTools_DataMapOfShapeSequenceOfShape::*)() const ) &TopTools_DataMapOfShapeSequenceOfShape::Size, "Size");
	cls_TopTools_DataMapOfShapeSequenceOfShape.def("__iter__", [](const TopTools_DataMapOfShapeSequenceOfShape &s) { return py::make_iterator(s.begin(), s.end()); }, py::keep_alive<0, 1>());

	// C:\Miniconda\envs\occt\Library\include\opencascade\TopTools_DataMapOfShapeSequenceOfShape.hxx
	// C:\Miniconda\envs\occt\Library\include\opencascade\TopTools_LocationSetPtr.hxx
	// C:\Miniconda\envs\occt\Library\include\opencascade\NCollection_Map.hxx
	py::class_<TopTools_MapOfOrientedShape, std::unique_ptr<TopTools_MapOfOrientedShape, Deleter<TopTools_MapOfOrientedShape>>, NCollection_BaseMap> cls_TopTools_MapOfOrientedShape(mod, "TopTools_MapOfOrientedShape", "Purpose: Single hashed Map. This Map is used to store and retrieve keys in linear time.");
	cls_TopTools_MapOfOrientedShape.def(py::init<>());
	cls_TopTools_MapOfOrientedShape.def(py::init<const Standard_Integer>(), py::arg("NbBuckets"));
	cls_TopTools_MapOfOrientedShape.def(py::init<const Standard_Integer, const opencascade::handle<NCollection_BaseAllocator> &>(), py::arg("NbBuckets"), py::arg("theAllocator"));
	cls_TopTools_MapOfOrientedShape.def(py::init([] (const TopTools_MapOfOrientedShape &other) {return new TopTools_MapOfOrientedShape(other);}), "Copy constructor", py::arg("other"));
	cls_TopTools_MapOfOrientedShape.def("cbegin", (TopTools_MapOfOrientedShape::const_iterator (TopTools_MapOfOrientedShape::*)() const ) &TopTools_MapOfOrientedShape::cbegin, "Returns a const iterator pointing to the first element in the map.");
	cls_TopTools_MapOfOrientedShape.def("cend", (TopTools_MapOfOrientedShape::const_iterator (TopTools_MapOfOrientedShape::*)() const ) &TopTools_MapOfOrientedShape::cend, "Returns a const iterator referring to the past-the-end element in the map.");
	cls_TopTools_MapOfOrientedShape.def("Exchange", (void (TopTools_MapOfOrientedShape::*)(TopTools_MapOfOrientedShape &)) &TopTools_MapOfOrientedShape::Exchange, "Exchange the content of two maps without re-allocations. Notice that allocators will be swapped as well!", py::arg("theOther"));
	cls_TopTools_MapOfOrientedShape.def("Assign", (TopTools_MapOfOrientedShape & (TopTools_MapOfOrientedShape::*)(const TopTools_MapOfOrientedShape &)) &TopTools_MapOfOrientedShape::Assign, "Assign. This method does not change the internal allocator.", py::arg("theOther"));
	cls_TopTools_MapOfOrientedShape.def("assign", (TopTools_MapOfOrientedShape & (TopTools_MapOfOrientedShape::*)(const TopTools_MapOfOrientedShape &)) &TopTools_MapOfOrientedShape::operator=, py::is_operator(), "Assign operator", py::arg("theOther"));
	cls_TopTools_MapOfOrientedShape.def("ReSize", (void (TopTools_MapOfOrientedShape::*)(const Standard_Integer)) &TopTools_MapOfOrientedShape::ReSize, "ReSize", py::arg("N"));
	cls_TopTools_MapOfOrientedShape.def("Add", (Standard_Boolean (TopTools_MapOfOrientedShape::*)(const TopoDS_Shape &)) &TopTools_MapOfOrientedShape::Add, "Add", py::arg("K"));
	cls_TopTools_MapOfOrientedShape.def("Added", (const TopoDS_Shape & (TopTools_MapOfOrientedShape::*)(const TopoDS_Shape &)) &TopTools_MapOfOrientedShape::Added, "Added: add a new key if not yet in the map, and return reference to either newly added or previously existing object", py::arg("K"));
	cls_TopTools_MapOfOrientedShape.def("Contains", (Standard_Boolean (TopTools_MapOfOrientedShape::*)(const TopoDS_Shape &) const ) &TopTools_MapOfOrientedShape::Contains, "Contains", py::arg("K"));
	cls_TopTools_MapOfOrientedShape.def("Remove", (Standard_Boolean (TopTools_MapOfOrientedShape::*)(const TopoDS_Shape &)) &TopTools_MapOfOrientedShape::Remove, "Remove", py::arg("K"));
	cls_TopTools_MapOfOrientedShape.def("Clear", [](TopTools_MapOfOrientedShape &self) -> void { return self.Clear(); });
	cls_TopTools_MapOfOrientedShape.def("Clear", (void (TopTools_MapOfOrientedShape::*)(const Standard_Boolean)) &TopTools_MapOfOrientedShape::Clear, "Clear data. If doReleaseMemory is false then the table of buckets is not released and will be reused.", py::arg("doReleaseMemory"));
	cls_TopTools_MapOfOrientedShape.def("Clear", (void (TopTools_MapOfOrientedShape::*)(const opencascade::handle<NCollection_BaseAllocator> &)) &TopTools_MapOfOrientedShape::Clear, "Clear data and reset allocator", py::arg("theAllocator"));
	cls_TopTools_MapOfOrientedShape.def("Size", (Standard_Integer (TopTools_MapOfOrientedShape::*)() const ) &TopTools_MapOfOrientedShape::Size, "Size");
	cls_TopTools_MapOfOrientedShape.def("IsEqual", (Standard_Boolean (TopTools_MapOfOrientedShape::*)(const TopTools_MapOfOrientedShape &) const ) &TopTools_MapOfOrientedShape::IsEqual, "Returns true if two maps contains exactly the same keys", py::arg("theOther"));
	cls_TopTools_MapOfOrientedShape.def("Contains", (Standard_Boolean (TopTools_MapOfOrientedShape::*)(const TopTools_MapOfOrientedShape &) const ) &TopTools_MapOfOrientedShape::Contains, "Returns true if this map contains ALL keys of another map.", py::arg("theOther"));
	cls_TopTools_MapOfOrientedShape.def("Union", (void (TopTools_MapOfOrientedShape::*)(const TopTools_MapOfOrientedShape &, const TopTools_MapOfOrientedShape &)) &TopTools_MapOfOrientedShape::Union, "Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps The new Map contains the values that are contained either in the first map or in the second map or in both. All previous content of this Map is cleared. This map (result of the boolean operation) can also be passed as one of operands.", py::arg("theLeft"), py::arg("theRight"));
	cls_TopTools_MapOfOrientedShape.def("Unite", (Standard_Boolean (TopTools_MapOfOrientedShape::*)(const TopTools_MapOfOrientedShape &)) &TopTools_MapOfOrientedShape::Unite, "Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map. The result contains the values that were previously contained in this map or contained in the given (operand) map. This algorithm is similar to method Union(). Returns True if contents of this map is changed.", py::arg("theOther"));
	cls_TopTools_MapOfOrientedShape.def("HasIntersection", (Standard_Boolean (TopTools_MapOfOrientedShape::*)(const TopTools_MapOfOrientedShape &) const ) &TopTools_MapOfOrientedShape::HasIntersection, "Returns true if this and theMap have common elements.", py::arg("theMap"));
	cls_TopTools_MapOfOrientedShape.def("Intersection", (void (TopTools_MapOfOrientedShape::*)(const TopTools_MapOfOrientedShape &, const TopTools_MapOfOrientedShape &)) &TopTools_MapOfOrientedShape::Intersection, "Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps. The new Map contains only the values that are contained in both map operands. All previous content of this Map is cleared. This same map (result of the boolean operation) can also be used as one of operands.", py::arg("theLeft"), py::arg("theRight"));
	cls_TopTools_MapOfOrientedShape.def("Intersect", (Standard_Boolean (TopTools_MapOfOrientedShape::*)(const TopTools_MapOfOrientedShape &)) &TopTools_MapOfOrientedShape::Intersect, "Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map. The result contains only the values that are contained in both this and the given maps. This algorithm is similar to method Intersection(). Returns True if contents of this map is changed.", py::arg("theOther"));
	cls_TopTools_MapOfOrientedShape.def("Subtraction", (void (TopTools_MapOfOrientedShape::*)(const TopTools_MapOfOrientedShape &, const TopTools_MapOfOrientedShape &)) &TopTools_MapOfOrientedShape::Subtraction, "Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement, exclude, cut, boolean NOT) operation between two given Maps. The new Map contains only the values that are contained in the first map operands and not contained in the second one. All previous content of this Map is cleared.", py::arg("theLeft"), py::arg("theRight"));
	cls_TopTools_MapOfOrientedShape.def("Subtract", (Standard_Boolean (TopTools_MapOfOrientedShape::*)(const TopTools_MapOfOrientedShape &)) &TopTools_MapOfOrientedShape::Subtract, "Apply to this Map the subtraction (aka set-theoretic difference, relative complement, exclude, cut, boolean NOT) operation with another (given) Map. The result contains only the values that were previously contained in this map and not contained in this map. This algorithm is similar to method Subtract() with two operands. Returns True if contents of this map is changed.", py::arg("theOther"));
	cls_TopTools_MapOfOrientedShape.def("Difference", (void (TopTools_MapOfOrientedShape::*)(const TopTools_MapOfOrientedShape &, const TopTools_MapOfOrientedShape &)) &TopTools_MapOfOrientedShape::Difference, "Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps. The new Map contains the values that are contained only in the first or the second operand maps but not in both. All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands.", py::arg("theLeft"), py::arg("theRight"));
	cls_TopTools_MapOfOrientedShape.def("Differ", (Standard_Boolean (TopTools_MapOfOrientedShape::*)(const TopTools_MapOfOrientedShape &)) &TopTools_MapOfOrientedShape::Differ, "Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map. The result contains the values that are contained only in this or the operand map, but not in both. This algorithm is similar to method Difference(). Returns True if contents of this map is changed.", py::arg("theOther"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\TopTools_MapOfOrientedShape.hxx

}
