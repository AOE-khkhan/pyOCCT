#include <pybind11/pybind11.h>
namespace py = pybind11;

#include <Standard_Handle.hxx>
PYBIND11_DECLARE_HOLDER_TYPE(T, opencascade::handle<T>, true);
PYBIND11_DECLARE_HOLDER_TYPE(T, T*);
using opencascade::handle;

// Deleter template for mixed holder types with public/hidden destructors.
template<typename T> struct Deleter { void operator() (T *o) const { delete o; } };

#include <Standard_TypeDef.hxx>
#include <BSplSLib_EvaluatorFunction.hxx>
#include <TColgp_Array2OfPnt.hxx>
#include <TColStd_Array2OfReal.hxx>
#include <TColStd_Array1OfReal.hxx>
#include <TColStd_Array1OfInteger.hxx>
#include <gp_Pnt.hxx>
#include <gp_Vec.hxx>
#include <TColgp_Array1OfPnt.hxx>
#include <BSplSLib.hxx>
#include <Standard_Transient.hxx>
#include <Standard_Handle.hxx>
#include <Standard_Type.hxx>
#include <BSplSLib_Cache.hxx>

PYBIND11_MODULE(BSplSLib, mod) {

	// IMPORT
	py::module::import("OCCT.Standard");
	py::module::import("OCCT.TColgp");
	py::module::import("OCCT.TColStd");
	py::module::import("OCCT.gp");

	py::module other_mod;

	// IMPORT GUARDS

	// ENUMS

	// FUNCTIONS

	// CLASSES
	// Callback for BSplSLib_EvaluatorFunction.
	class PyCallback_BSplSLib_EvaluatorFunction : public BSplSLib_EvaluatorFunction {
	public:
		using BSplSLib_EvaluatorFunction::BSplSLib_EvaluatorFunction;

		void Evaluate(const Standard_Integer theDerivativeRequest, const Standard_Real theUParameter, const Standard_Real theVParameter, Standard_Real & theResult, Standard_Integer & theErrorCode) const  override { PYBIND11_OVERLOAD_PURE(void, BSplSLib_EvaluatorFunction, Evaluate, theDerivativeRequest, theUParameter, theVParameter, theResult, theErrorCode); }
	};

	// C:\Miniconda\envs\occt\Library\include\opencascade\BSplSLib_EvaluatorFunction.hxx
	py::class_<BSplSLib_EvaluatorFunction, std::unique_ptr<BSplSLib_EvaluatorFunction, Deleter<BSplSLib_EvaluatorFunction>>, PyCallback_BSplSLib_EvaluatorFunction> cls_BSplSLib_EvaluatorFunction(mod, "BSplSLib_EvaluatorFunction", "None");
	cls_BSplSLib_EvaluatorFunction.def(py::init<>());
	cls_BSplSLib_EvaluatorFunction.def("Evaluate", (void (BSplSLib_EvaluatorFunction::*)(const Standard_Integer, const Standard_Real, const Standard_Real, Standard_Real &, Standard_Integer &) const ) &BSplSLib_EvaluatorFunction::Evaluate, "Function evaluation method to be defined by descendant", py::arg("theDerivativeRequest"), py::arg("theUParameter"), py::arg("theVParameter"), py::arg("theResult"), py::arg("theErrorCode"));
	cls_BSplSLib_EvaluatorFunction.def("__call__", (void (BSplSLib_EvaluatorFunction::*)(const Standard_Integer, const Standard_Real, const Standard_Real, Standard_Real &, Standard_Integer &) const ) &BSplSLib_EvaluatorFunction::operator(), py::is_operator(), "Shortcut for function-call style usage", py::arg("theDerivativeRequest"), py::arg("theUParameter"), py::arg("theVParameter"), py::arg("theResult"), py::arg("theErrorCode"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\BSplSLib.hxx
	py::class_<BSplSLib, std::unique_ptr<BSplSLib, Deleter<BSplSLib>>> cls_BSplSLib(mod, "BSplSLib", "BSplSLib B-spline surface Library This package provides an implementation of geometric functions for rational and non rational, periodic and non periodic B-spline surface computation.");
	cls_BSplSLib.def(py::init<>());
	cls_BSplSLib.def_static("RationalDerivative_", [](const Standard_Integer a0, const Standard_Integer a1, const Standard_Integer a2, const Standard_Integer a3, Standard_Real & a4, Standard_Real & a5) -> void { return BSplSLib::RationalDerivative(a0, a1, a2, a3, a4, a5); }, py::arg("UDeg"), py::arg("VDeg"), py::arg("N"), py::arg("M"), py::arg("Ders"), py::arg("RDers"));
	// FIXME cls_BSplSLib.def_static("RationalDerivative_", (void (*)(const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, Standard_Real &, Standard_Real &, const Standard_Boolean)) &BSplSLib::RationalDerivative, "this is a one dimensional function typedef void (*EvaluatorFunction) ( Standard_Integer // Derivative Request Standard_Real * // StartEnd[2][2] // [0] = U // [1] = V // [0] = start // [1] = end Standard_Real // UParameter Standard_Real // VParamerer Standard_Real & // Result Standard_Integer &) ;// Error Code serves to multiply a given vectorial BSpline by a function Computes the derivatives of a ratio of two-variables functions x(u,v) / w(u,v) at orders <N,M>, x(u,v) is a vector in dimension <3>.", py::arg("UDeg"), py::arg("VDeg"), py::arg("N"), py::arg("M"), py::arg("Ders"), py::arg("RDers"), py::arg("All"));
	cls_BSplSLib.def_static("D0_", (void (*)(const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer, const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger *, const TColStd_Array1OfInteger *, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, gp_Pnt &)) &BSplSLib::D0, "None", py::arg("U"), py::arg("V"), py::arg("UIndex"), py::arg("VIndex"), py::arg("Poles"), py::arg("Weights"), py::arg("UKnots"), py::arg("VKnots"), py::arg("UMults"), py::arg("VMults"), py::arg("UDegree"), py::arg("VDegree"), py::arg("URat"), py::arg("VRat"), py::arg("UPer"), py::arg("VPer"), py::arg("P"));
	cls_BSplSLib.def_static("D1_", (void (*)(const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer, const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger *, const TColStd_Array1OfInteger *, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, gp_Pnt &, gp_Vec &, gp_Vec &)) &BSplSLib::D1, "None", py::arg("U"), py::arg("V"), py::arg("UIndex"), py::arg("VIndex"), py::arg("Poles"), py::arg("Weights"), py::arg("UKnots"), py::arg("VKnots"), py::arg("UMults"), py::arg("VMults"), py::arg("Degree"), py::arg("VDegree"), py::arg("URat"), py::arg("VRat"), py::arg("UPer"), py::arg("VPer"), py::arg("P"), py::arg("Vu"), py::arg("Vv"));
	cls_BSplSLib.def_static("D2_", (void (*)(const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer, const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger *, const TColStd_Array1OfInteger *, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &)) &BSplSLib::D2, "None", py::arg("U"), py::arg("V"), py::arg("UIndex"), py::arg("VIndex"), py::arg("Poles"), py::arg("Weights"), py::arg("UKnots"), py::arg("VKnots"), py::arg("UMults"), py::arg("VMults"), py::arg("UDegree"), py::arg("VDegree"), py::arg("URat"), py::arg("VRat"), py::arg("UPer"), py::arg("VPer"), py::arg("P"), py::arg("Vu"), py::arg("Vv"), py::arg("Vuu"), py::arg("Vvv"), py::arg("Vuv"));
	cls_BSplSLib.def_static("D3_", (void (*)(const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer, const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger *, const TColStd_Array1OfInteger *, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &)) &BSplSLib::D3, "None", py::arg("U"), py::arg("V"), py::arg("UIndex"), py::arg("VIndex"), py::arg("Poles"), py::arg("Weights"), py::arg("UKnots"), py::arg("VKnots"), py::arg("UMults"), py::arg("VMults"), py::arg("UDegree"), py::arg("VDegree"), py::arg("URat"), py::arg("VRat"), py::arg("UPer"), py::arg("VPer"), py::arg("P"), py::arg("Vu"), py::arg("Vv"), py::arg("Vuu"), py::arg("Vvv"), py::arg("Vuv"), py::arg("Vuuu"), py::arg("Vvvv"), py::arg("Vuuv"), py::arg("Vuvv"));
	cls_BSplSLib.def_static("DN_", (void (*)(const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger *, const TColStd_Array1OfInteger *, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, gp_Vec &)) &BSplSLib::DN, "None", py::arg("U"), py::arg("V"), py::arg("Nu"), py::arg("Nv"), py::arg("UIndex"), py::arg("VIndex"), py::arg("Poles"), py::arg("Weights"), py::arg("UKnots"), py::arg("VKnots"), py::arg("UMults"), py::arg("VMults"), py::arg("UDegree"), py::arg("VDegree"), py::arg("URat"), py::arg("VRat"), py::arg("UPer"), py::arg("VPer"), py::arg("Vn"));
	cls_BSplSLib.def_static("Iso_", (void (*)(const Standard_Real, const Standard_Boolean, const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger *, const Standard_Integer, const Standard_Boolean, TColgp_Array1OfPnt &, TColStd_Array1OfReal *)) &BSplSLib::Iso, "Computes the poles and weights of an isoparametric curve at parameter <Param> (UIso if <IsU> is True, VIso else).", py::arg("Param"), py::arg("IsU"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("Degree"), py::arg("Periodic"), py::arg("CPoles"), py::arg("CWeights"));
	cls_BSplSLib.def_static("Reverse_", (void (*)(TColgp_Array2OfPnt &, const Standard_Integer, const Standard_Boolean)) &BSplSLib::Reverse, "Reverses the array of poles. Last is the Index of the new first Row( Col) of Poles. On a non periodic surface Last is Poles.Upper(). On a periodic curve last is (number of flat knots - degree - 1) or (sum of multiplicities(but for the last) + degree - 1)", py::arg("Poles"), py::arg("Last"), py::arg("UDirection"));
	cls_BSplSLib.def_static("HomogeneousD0_", (void (*)(const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer, const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger *, const TColStd_Array1OfInteger *, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, Standard_Real &, gp_Pnt &)) &BSplSLib::HomogeneousD0, "Makes an homogeneous evaluation of Poles and Weights any and returns in P the Numerator value and in W the Denominator value if Weights are present otherwise returns 1.0e0", py::arg("U"), py::arg("V"), py::arg("UIndex"), py::arg("VIndex"), py::arg("Poles"), py::arg("Weights"), py::arg("UKnots"), py::arg("VKnots"), py::arg("UMults"), py::arg("VMults"), py::arg("UDegree"), py::arg("VDegree"), py::arg("URat"), py::arg("VRat"), py::arg("UPer"), py::arg("VPer"), py::arg("W"), py::arg("P"));
	cls_BSplSLib.def_static("HomogeneousD1_", (void (*)(const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer, const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger *, const TColStd_Array1OfInteger *, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, gp_Pnt &, gp_Vec &, gp_Vec &, Standard_Real &, Standard_Real &, Standard_Real &)) &BSplSLib::HomogeneousD1, "Makes an homogeneous evaluation of Poles and Weights any and returns in P the Numerator value and in W the Denominator value if Weights are present otherwise returns 1.0e0", py::arg("U"), py::arg("V"), py::arg("UIndex"), py::arg("VIndex"), py::arg("Poles"), py::arg("Weights"), py::arg("UKnots"), py::arg("VKnots"), py::arg("UMults"), py::arg("VMults"), py::arg("UDegree"), py::arg("VDegree"), py::arg("URat"), py::arg("VRat"), py::arg("UPer"), py::arg("VPer"), py::arg("N"), py::arg("Nu"), py::arg("Nv"), py::arg("D"), py::arg("Du"), py::arg("Dv"));
	cls_BSplSLib.def_static("Reverse_", (void (*)(TColStd_Array2OfReal &, const Standard_Integer, const Standard_Boolean)) &BSplSLib::Reverse, "Reverses the array of weights.", py::arg("Weights"), py::arg("Last"), py::arg("UDirection"));
	cls_BSplSLib.def_static("IsRational_", [](const TColStd_Array2OfReal & a0, const Standard_Integer a1, const Standard_Integer a2, const Standard_Integer a3, const Standard_Integer a4) -> Standard_Boolean { return BSplSLib::IsRational(a0, a1, a2, a3, a4); }, py::arg("Weights"), py::arg("I1"), py::arg("I2"), py::arg("J1"), py::arg("J2"));
	// FIXME cls_BSplSLib.def_static("IsRational_", (Standard_Boolean (*)(const TColStd_Array2OfReal &, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Real)) &BSplSLib::IsRational, "Returns False if all the weights of the array <Weights> in the area [I1,I2] * [J1,J2] are identic. Epsilon is used for comparing weights. If Epsilon is 0. the Epsilon of the first weight is used.", py::arg("Weights"), py::arg("I1"), py::arg("I2"), py::arg("J1"), py::arg("J2"), py::arg("Epsilon"));
	cls_BSplSLib.def_static("SetPoles_", (void (*)(const TColgp_Array2OfPnt &, TColStd_Array1OfReal &, const Standard_Boolean)) &BSplSLib::SetPoles, "Copy in FP the coordinates of the poles.", py::arg("Poles"), py::arg("FP"), py::arg("UDirection"));
	cls_BSplSLib.def_static("SetPoles_", (void (*)(const TColgp_Array2OfPnt &, const TColStd_Array2OfReal &, TColStd_Array1OfReal &, const Standard_Boolean)) &BSplSLib::SetPoles, "Copy in FP the coordinates of the poles.", py::arg("Poles"), py::arg("Weights"), py::arg("FP"), py::arg("UDirection"));
	cls_BSplSLib.def_static("GetPoles_", (void (*)(const TColStd_Array1OfReal &, TColgp_Array2OfPnt &, const Standard_Boolean)) &BSplSLib::GetPoles, "Get from FP the coordinates of the poles.", py::arg("FP"), py::arg("Poles"), py::arg("UDirection"));
	cls_BSplSLib.def_static("GetPoles_", (void (*)(const TColStd_Array1OfReal &, TColgp_Array2OfPnt &, TColStd_Array2OfReal &, const Standard_Boolean)) &BSplSLib::GetPoles, "Get from FP the coordinates of the poles.", py::arg("FP"), py::arg("Poles"), py::arg("Weights"), py::arg("UDirection"));
	cls_BSplSLib.def_static("MovePoint_", (void (*)(const Standard_Real, const Standard_Real, const gp_Vec &, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const TColgp_Array2OfPnt &, const TColStd_Array2OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, Standard_Integer &, Standard_Integer &, Standard_Integer &, Standard_Integer &, TColgp_Array2OfPnt &)) &BSplSLib::MovePoint, "Find the new poles which allows an old point (with a given u,v as parameters) to reach a new position UIndex1,UIndex2 indicate the range of poles we can move for U (1, UNbPoles-1) or (2, UNbPoles) -> no constraint for one side in U (2, UNbPoles-1) -> the ends are enforced for U don't enter (1,NbPoles) and (1,VNbPoles) -> error: rigid move if problem in BSplineBasis calculation, no change for the curve and UFirstIndex, VLastIndex = 0 VFirstIndex, VLastIndex = 0", py::arg("U"), py::arg("V"), py::arg("Displ"), py::arg("UIndex1"), py::arg("UIndex2"), py::arg("VIndex1"), py::arg("VIndex2"), py::arg("UDegree"), py::arg("VDegree"), py::arg("Rational"), py::arg("Poles"), py::arg("Weights"), py::arg("UFlatKnots"), py::arg("VFlatKnots"), py::arg("UFirstIndex"), py::arg("ULastIndex"), py::arg("VFirstIndex"), py::arg("VLastIndex"), py::arg("NewPoles"));
	cls_BSplSLib.def_static("InsertKnots_", [](const Standard_Boolean a0, const Standard_Integer a1, const Standard_Boolean a2, const TColgp_Array2OfPnt & a3, const TColStd_Array2OfReal * a4, const TColStd_Array1OfReal & a5, const TColStd_Array1OfInteger & a6, const TColStd_Array1OfReal & a7, const TColStd_Array1OfInteger * a8, TColgp_Array2OfPnt & a9, TColStd_Array2OfReal * a10, TColStd_Array1OfReal & a11, TColStd_Array1OfInteger & a12, const Standard_Real a13) -> void { return BSplSLib::InsertKnots(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13); }, py::arg("UDirection"), py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("AddKnots"), py::arg("AddMults"), py::arg("NewPoles"), py::arg("NewWeights"), py::arg("NewKnots"), py::arg("NewMults"), py::arg("Epsilon"));
	cls_BSplSLib.def_static("InsertKnots_", (void (*)(const Standard_Boolean, const Standard_Integer, const Standard_Boolean, const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger *, TColgp_Array2OfPnt &, TColStd_Array2OfReal *, TColStd_Array1OfReal &, TColStd_Array1OfInteger &, const Standard_Real, const Standard_Boolean)) &BSplSLib::InsertKnots, "None", py::arg("UDirection"), py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("AddKnots"), py::arg("AddMults"), py::arg("NewPoles"), py::arg("NewWeights"), py::arg("NewKnots"), py::arg("NewMults"), py::arg("Epsilon"), py::arg("Add"));
	cls_BSplSLib.def_static("RemoveKnot_", (Standard_Boolean (*)(const Standard_Boolean, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, TColgp_Array2OfPnt &, TColStd_Array2OfReal *, TColStd_Array1OfReal &, TColStd_Array1OfInteger &, const Standard_Real)) &BSplSLib::RemoveKnot, "None", py::arg("UDirection"), py::arg("Index"), py::arg("Mult"), py::arg("Degree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("NewPoles"), py::arg("NewWeights"), py::arg("NewKnots"), py::arg("NewMults"), py::arg("Tolerance"));
	cls_BSplSLib.def_static("IncreaseDegree_", (void (*)(const Standard_Boolean, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, TColgp_Array2OfPnt &, TColStd_Array2OfReal *, TColStd_Array1OfReal &, TColStd_Array1OfInteger &)) &BSplSLib::IncreaseDegree, "None", py::arg("UDirection"), py::arg("Degree"), py::arg("NewDegree"), py::arg("Periodic"), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Mults"), py::arg("NewPoles"), py::arg("NewWeights"), py::arg("NewKnots"), py::arg("NewMults"));
	cls_BSplSLib.def_static("Unperiodize_", (void (*)(const Standard_Boolean, const Standard_Integer, const TColStd_Array1OfInteger &, const TColStd_Array1OfReal &, const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *, TColStd_Array1OfInteger &, TColStd_Array1OfReal &, TColgp_Array2OfPnt &, TColStd_Array2OfReal *)) &BSplSLib::Unperiodize, "None", py::arg("UDirection"), py::arg("Degree"), py::arg("Mults"), py::arg("Knots"), py::arg("Poles"), py::arg("Weights"), py::arg("NewMults"), py::arg("NewKnots"), py::arg("NewPoles"), py::arg("NewWeights"));
	cls_BSplSLib.def_static("NoWeights_", (TColStd_Array2OfReal * (*)()) &BSplSLib::NoWeights, "Used as argument for a non rational curve.");
	cls_BSplSLib.def_static("BuildCache_", (void (*)(const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Boolean, const Standard_Boolean, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *, TColgp_Array2OfPnt &, TColStd_Array2OfReal *)) &BSplSLib::BuildCache, "Perform the evaluation of the Taylor expansion of the Bspline normalized between 0 and 1. If rational computes the homogeneous Taylor expension for the numerator and stores it in CachePoles", py::arg("U"), py::arg("V"), py::arg("USpanDomain"), py::arg("VSpanDomain"), py::arg("UPeriodicFlag"), py::arg("VPeriodicFlag"), py::arg("UDegree"), py::arg("VDegree"), py::arg("UIndex"), py::arg("VIndex"), py::arg("UFlatKnots"), py::arg("VFlatKnots"), py::arg("Poles"), py::arg("Weights"), py::arg("CachePoles"), py::arg("CacheWeights"));
	cls_BSplSLib.def_static("BuildCache_", (void (*)(const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Boolean, const Standard_Boolean, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *, TColStd_Array2OfReal &)) &BSplSLib::BuildCache, "Perform the evaluation of the Taylor expansion of the Bspline normalized between 0 and 1. Structure of result optimized for BSplSLib_Cache.", py::arg("theU"), py::arg("theV"), py::arg("theUSpanDomain"), py::arg("theVSpanDomain"), py::arg("theUPeriodic"), py::arg("theVPeriodic"), py::arg("theUDegree"), py::arg("theVDegree"), py::arg("theUIndex"), py::arg("theVIndex"), py::arg("theUFlatKnots"), py::arg("theVFlatKnots"), py::arg("thePoles"), py::arg("theWeights"), py::arg("theCacheArray"));
	cls_BSplSLib.def_static("CacheD0_", (void (*)(const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *, gp_Pnt &)) &BSplSLib::CacheD0, "Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects", py::arg("U"), py::arg("V"), py::arg("UDegree"), py::arg("VDegree"), py::arg("UCacheParameter"), py::arg("VCacheParameter"), py::arg("USpanLenght"), py::arg("VSpanLength"), py::arg("Poles"), py::arg("Weights"), py::arg("Point"));
	cls_BSplSLib.def_static("CoefsD0_", (void (*)(const Standard_Real, const Standard_Real, const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *, gp_Pnt &)) &BSplSLib::CoefsD0, "Calls CacheD0 for Bezier Surfaces Arrays computed with the method PolesCoefficients. Warning: To be used for BezierSurfaces ONLY!!!", py::arg("U"), py::arg("V"), py::arg("Poles"), py::arg("Weights"), py::arg("Point"));
	cls_BSplSLib.def_static("CacheD1_", (void (*)(const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *, gp_Pnt &, gp_Vec &, gp_Vec &)) &BSplSLib::CacheD1, "Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects", py::arg("U"), py::arg("V"), py::arg("UDegree"), py::arg("VDegree"), py::arg("UCacheParameter"), py::arg("VCacheParameter"), py::arg("USpanLenght"), py::arg("VSpanLength"), py::arg("Poles"), py::arg("Weights"), py::arg("Point"), py::arg("VecU"), py::arg("VecV"));
	cls_BSplSLib.def_static("CoefsD1_", (void (*)(const Standard_Real, const Standard_Real, const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *, gp_Pnt &, gp_Vec &, gp_Vec &)) &BSplSLib::CoefsD1, "Calls CacheD0 for Bezier Surfaces Arrays computed with the method PolesCoefficients. Warning: To be used for BezierSurfaces ONLY!!!", py::arg("U"), py::arg("V"), py::arg("Poles"), py::arg("Weights"), py::arg("Point"), py::arg("VecU"), py::arg("VecV"));
	cls_BSplSLib.def_static("CacheD2_", (void (*)(const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real, const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &)) &BSplSLib::CacheD2, "Perform the evaluation of the of the cache the parameter must be normalized between the 0 and 1 for the span. The Cache must be valid when calling this routine. Geom Package will insure that. and then multiplies by the weights this just evaluates the current point the CacheParameter is where the Cache was constructed the SpanLength is to normalize the polynomial in the cache to avoid bad conditioning effects", py::arg("U"), py::arg("V"), py::arg("UDegree"), py::arg("VDegree"), py::arg("UCacheParameter"), py::arg("VCacheParameter"), py::arg("USpanLenght"), py::arg("VSpanLength"), py::arg("Poles"), py::arg("Weights"), py::arg("Point"), py::arg("VecU"), py::arg("VecV"), py::arg("VecUU"), py::arg("VecUV"), py::arg("VecVV"));
	cls_BSplSLib.def_static("CoefsD2_", (void (*)(const Standard_Real, const Standard_Real, const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &)) &BSplSLib::CoefsD2, "Calls CacheD0 for Bezier Surfaces Arrays computed with the method PolesCoefficients. Warning: To be used for BezierSurfaces ONLY!!!", py::arg("U"), py::arg("V"), py::arg("Poles"), py::arg("Weights"), py::arg("Point"), py::arg("VecU"), py::arg("VecV"), py::arg("VecUU"), py::arg("VecUV"), py::arg("VecVV"));
	cls_BSplSLib.def_static("PolesCoefficients_", (void (*)(const TColgp_Array2OfPnt &, TColgp_Array2OfPnt &)) &BSplSLib::PolesCoefficients, "Warning! To be used for BezierSurfaces ONLY!!!", py::arg("Poles"), py::arg("CachePoles"));
	cls_BSplSLib.def_static("PolesCoefficients_", (void (*)(const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *, TColgp_Array2OfPnt &, TColStd_Array2OfReal *)) &BSplSLib::PolesCoefficients, "Encapsulation of BuildCache to perform the evaluation of the Taylor expansion for beziersurfaces at parameters 0.,0.; Warning: To be used for BezierSurfaces ONLY!!!", py::arg("Poles"), py::arg("Weights"), py::arg("CachePoles"), py::arg("CacheWeights"));
	cls_BSplSLib.def_static("Resolution_", (void (*)(const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Real, Standard_Real &, Standard_Real &)) &BSplSLib::Resolution, "Given a tolerance in 3D space returns two tolerances, one in U one in V such that for all (u1,v1) and (u0,v0) in the domain of the surface f(u,v) we have : | u1 - u0 | < UTolerance and | v1 - v0 | < VTolerance we have |f (u1,v1) - f (u0,v0)| < Tolerance3D", py::arg("Poles"), py::arg("Weights"), py::arg("UKnots"), py::arg("VKnots"), py::arg("UMults"), py::arg("VMults"), py::arg("UDegree"), py::arg("VDegree"), py::arg("URat"), py::arg("VRat"), py::arg("UPer"), py::arg("VPer"), py::arg("Tolerance3D"), py::arg("UTolerance"), py::arg("VTolerance"));
	// FIXME cls_BSplSLib.def_static("Interpolate_", (void (*)(const Standard_Integer, const Standard_Integer, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, TColgp_Array2OfPnt &, TColStd_Array2OfReal &, Standard_Integer &)) &BSplSLib::Interpolate, "Performs the interpolation of the data points given in the Poles array in the form [1,...,RL][1,...,RC][1...PolesDimension] . The ColLength CL and the Length of UParameters must be the same. The length of VFlatKnots is VDegree + CL + 1.", py::arg("UDegree"), py::arg("VDegree"), py::arg("UFlatKnots"), py::arg("VFlatKnots"), py::arg("UParameters"), py::arg("VParameters"), py::arg("Poles"), py::arg("Weights"), py::arg("InversionProblem"));
	cls_BSplSLib.def_static("Interpolate_", (void (*)(const Standard_Integer, const Standard_Integer, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, TColgp_Array2OfPnt &, Standard_Integer &)) &BSplSLib::Interpolate, "Performs the interpolation of the data points given in the Poles array. The ColLength CL and the Length of UParameters must be the same. The length of VFlatKnots is VDegree + CL + 1.", py::arg("UDegree"), py::arg("VDegree"), py::arg("UFlatKnots"), py::arg("VFlatKnots"), py::arg("UParameters"), py::arg("VParameters"), py::arg("Poles"), py::arg("InversionProblem"));
	// FIXME cls_BSplSLib.def_static("FunctionMultiply_", (void (*)(const BSplSLib_EvaluatorFunction &, const Standard_Integer, const Standard_Integer, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger *, const TColStd_Array1OfInteger *, const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const Standard_Integer, const Standard_Integer, TColgp_Array2OfPnt &, TColStd_Array2OfReal &, Standard_Integer &)) &BSplSLib::FunctionMultiply, "this will multiply a given BSpline numerator N(u,v) and denominator D(u,v) defined by its U/VBSplineDegree and U/VBSplineKnots, and U/VMults. Its Poles and Weights are arrays which are coded as array2 of the form [1..UNumPoles][1..VNumPoles] by a function a(u,v) which is assumed to satisfy the following : 1. a(u,v) * N(u,v) and a(u,v) * D(u,v) is a polynomial BSpline that can be expressed exactly as a BSpline of degree U/VNewDegree on the knots U/VFlatKnots 2. the range of a(u,v) is the same as the range of N(u,v) or D(u,v) ---Warning: it is the caller's responsability to insure that conditions 1. and 2. above are satisfied : no check whatsoever is made in this method -- theStatus will return 0 if OK else it will return the pivot index -- of the matrix that was inverted to compute the multiplied -- BSpline : the method used is interpolation at Schoenenberg -- points of a(u,v)* N(u,v) and a(u,v) * D(u,v) theStatus will return 0 if OK else it will return the pivot index of the matrix that was inverted to compute the multiplied BSpline : the method used is interpolation at Schoenenberg points of a(u,v)*F(u,v) --", py::arg("Function"), py::arg("UBSplineDegree"), py::arg("VBSplineDegree"), py::arg("UBSplineKnots"), py::arg("VBSplineKnots"), py::arg("UMults"), py::arg("VMults"), py::arg("Poles"), py::arg("Weights"), py::arg("UFlatKnots"), py::arg("VFlatKnots"), py::arg("UNewDegree"), py::arg("VNewDegree"), py::arg("NewNumerator"), py::arg("NewDenominator"), py::arg("theStatus"));

	// C:\Miniconda\envs\occt\Library\include\opencascade\BSplSLib_Cache.hxx
	py::class_<BSplSLib_Cache, opencascade::handle<BSplSLib_Cache>, Standard_Transient> cls_BSplSLib_Cache(mod, "BSplSLib_Cache", "A cache class for Bezier and B-spline surfaces.");
	cls_BSplSLib_Cache.def(py::init<>());
	cls_BSplSLib_Cache.def(py::init<const Standard_Integer &, const Standard_Boolean &, const TColStd_Array1OfReal &, const Standard_Integer &, const Standard_Boolean &, const TColStd_Array1OfReal &, const TColgp_Array2OfPnt &>(), py::arg("theDegreeU"), py::arg("thePeriodicU"), py::arg("theFlatKnotsU"), py::arg("theDegreeV"), py::arg("thePeriodicV"), py::arg("theFlatKnotsV"), py::arg("thePoles"));
	cls_BSplSLib_Cache.def(py::init<const Standard_Integer &, const Standard_Boolean &, const TColStd_Array1OfReal &, const Standard_Integer &, const Standard_Boolean &, const TColStd_Array1OfReal &, const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *>(), py::arg("theDegreeU"), py::arg("thePeriodicU"), py::arg("theFlatKnotsU"), py::arg("theDegreeV"), py::arg("thePeriodicV"), py::arg("theFlatKnotsV"), py::arg("thePoles"), py::arg("theWeights"));
	cls_BSplSLib_Cache.def("IsCacheValid", (Standard_Boolean (BSplSLib_Cache::*)(Standard_Real, Standard_Real) const ) &BSplSLib_Cache::IsCacheValid, "Verifies validity of the cache using parameters of the point", py::arg("theParameterU"), py::arg("theParameterV"));
	cls_BSplSLib_Cache.def("BuildCache", [](BSplSLib_Cache &self, const Standard_Real & a0, const Standard_Real & a1, const Standard_Integer & a2, const Standard_Boolean & a3, const TColStd_Array1OfReal & a4, const Standard_Integer & a5, const Standard_Boolean & a6, const TColStd_Array1OfReal & a7, const TColgp_Array2OfPnt & a8) -> void { return self.BuildCache(a0, a1, a2, a3, a4, a5, a6, a7, a8); }, py::arg("theParameterU"), py::arg("theParameterV"), py::arg("theDegreeU"), py::arg("thePeriodicU"), py::arg("theFlatKnotsU"), py::arg("theDegreeV"), py::arg("thePeriodicV"), py::arg("theFlatKnotsV"), py::arg("thePoles"));
	cls_BSplSLib_Cache.def("BuildCache", (void (BSplSLib_Cache::*)(const Standard_Real &, const Standard_Real &, const Standard_Integer &, const Standard_Boolean &, const TColStd_Array1OfReal &, const Standard_Integer &, const Standard_Boolean &, const TColStd_Array1OfReal &, const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *)) &BSplSLib_Cache::BuildCache, "Recomputes the cache data. Does not verify validity of the cache", py::arg("theParameterU"), py::arg("theParameterV"), py::arg("theDegreeU"), py::arg("thePeriodicU"), py::arg("theFlatKnotsU"), py::arg("theDegreeV"), py::arg("thePeriodicV"), py::arg("theFlatKnotsV"), py::arg("thePoles"), py::arg("theWeights"));
	cls_BSplSLib_Cache.def("D0", (void (BSplSLib_Cache::*)(const Standard_Real &, const Standard_Real &, gp_Pnt &) const ) &BSplSLib_Cache::D0, "Calculates the point on the surface for specified parameters", py::arg("theU"), py::arg("theV"), py::arg("thePoint"));
	cls_BSplSLib_Cache.def("D1", (void (BSplSLib_Cache::*)(const Standard_Real &, const Standard_Real &, gp_Pnt &, gp_Vec &, gp_Vec &) const ) &BSplSLib_Cache::D1, "Calculates the point on the surface and its first derivative", py::arg("theU"), py::arg("theV"), py::arg("thePoint"), py::arg("theTangentU"), py::arg("theTangentV"));
	cls_BSplSLib_Cache.def("D2", (void (BSplSLib_Cache::*)(const Standard_Real &, const Standard_Real &, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &) const ) &BSplSLib_Cache::D2, "Calculates the point on the surface and derivatives till second order", py::arg("theU"), py::arg("theV"), py::arg("thePoint"), py::arg("theTangentU"), py::arg("theTangentV"), py::arg("theCurvatureU"), py::arg("theCurvatureV"), py::arg("theCurvatureUV"));
	cls_BSplSLib_Cache.def_static("get_type_name_", (const char * (*)()) &BSplSLib_Cache::get_type_name, "None");
	cls_BSplSLib_Cache.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &BSplSLib_Cache::get_type_descriptor, "None");
	cls_BSplSLib_Cache.def("DynamicType", (const opencascade::handle<Standard_Type> & (BSplSLib_Cache::*)() const ) &BSplSLib_Cache::DynamicType, "None");


}
