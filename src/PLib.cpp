#include <pyOCCT_Common.hpp>

#include <Standard_Transient.hxx>
#include <Standard_TypeDef.hxx>
#include <TColStd_Array1OfReal.hxx>
#include <Standard_Handle.hxx>
#include <Standard_Type.hxx>
#include <PLib_Base.hxx>
#include <GeomAbs_Shape.hxx>
#include <TColStd_Array2OfReal.hxx>
#include <PLib_JacobiPolynomial.hxx>
#include <PLib_HermitJacobi.hxx>
#include <TColStd_HArray1OfReal.hxx>
#include <PLib_DoubleJacobiPolynomial.hxx>
#include <TColgp_Array1OfPnt.hxx>
#include <TColgp_Array1OfPnt2d.hxx>
#include <math_Matrix.hxx>
#include <TColgp_Array2OfPnt.hxx>
#include <PLib.hxx>

PYBIND11_MODULE(PLib, mod) {

	// IMPORT
	py::module::import("OCCT.Standard");
	py::module::import("OCCT.TColStd");
	py::module::import("OCCT.GeomAbs");
	py::module::import("OCCT.TColgp");
	py::module::import("OCCT.math");

	py::module other_mod;

	// IMPORT GUARDS

	// ENUMS

	// FUNCTIONS

	// CLASSES
	// C:\Miniconda\envs\occt\Library\include\opencascade\PLib_Base.hxx
	py::class_<PLib_Base, opencascade::handle<PLib_Base>, Standard_Transient> cls_PLib_Base(mod, "PLib_Base", "To work with different polynomial's Bases");
	cls_PLib_Base.def("ToCoefficients", (void (PLib_Base::*)(const Standard_Integer, const Standard_Integer, const TColStd_Array1OfReal &, TColStd_Array1OfReal &) const ) &PLib_Base::ToCoefficients, "Convert the polynomial P(t) in the canonical base.", py::arg("Dimension"), py::arg("Degree"), py::arg("CoeffinBase"), py::arg("Coefficients"));
	cls_PLib_Base.def("D0", (void (PLib_Base::*)(const Standard_Real, TColStd_Array1OfReal &)) &PLib_Base::D0, "Compute the values of the basis functions in u", py::arg("U"), py::arg("BasisValue"));
	cls_PLib_Base.def("D1", (void (PLib_Base::*)(const Standard_Real, TColStd_Array1OfReal &, TColStd_Array1OfReal &)) &PLib_Base::D1, "Compute the values and the derivatives values of the basis functions in u", py::arg("U"), py::arg("BasisValue"), py::arg("BasisD1"));
	cls_PLib_Base.def("D2", (void (PLib_Base::*)(const Standard_Real, TColStd_Array1OfReal &, TColStd_Array1OfReal &, TColStd_Array1OfReal &)) &PLib_Base::D2, "Compute the values and the derivatives values of the basis functions in u", py::arg("U"), py::arg("BasisValue"), py::arg("BasisD1"), py::arg("BasisD2"));
	cls_PLib_Base.def("D3", (void (PLib_Base::*)(const Standard_Real, TColStd_Array1OfReal &, TColStd_Array1OfReal &, TColStd_Array1OfReal &, TColStd_Array1OfReal &)) &PLib_Base::D3, "Compute the values and the derivatives values of the basis functions in u", py::arg("U"), py::arg("BasisValue"), py::arg("BasisD1"), py::arg("BasisD2"), py::arg("BasisD3"));
	cls_PLib_Base.def("WorkDegree", (Standard_Integer (PLib_Base::*)() const ) &PLib_Base::WorkDegree, "returns WorkDegree");
	cls_PLib_Base.def("ReduceDegree", (void (PLib_Base::*)(const Standard_Integer, const Standard_Integer, const Standard_Real, Standard_Real &, Standard_Integer &, Standard_Real &) const ) &PLib_Base::ReduceDegree, "Compute NewDegree <= MaxDegree so that MaxError is lower than Tol. MaxError can be greater than Tol if it is not possible to find a NewDegree <= MaxDegree. In this case NewDegree = MaxDegree", py::arg("Dimension"), py::arg("MaxDegree"), py::arg("Tol"), py::arg("BaseCoeff"), py::arg("NewDegree"), py::arg("MaxError"));
	cls_PLib_Base.def_static("get_type_name_", (const char * (*)()) &PLib_Base::get_type_name, "None");
	cls_PLib_Base.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &PLib_Base::get_type_descriptor, "None");
	cls_PLib_Base.def("DynamicType", (const opencascade::handle<Standard_Type> & (PLib_Base::*)() const ) &PLib_Base::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\PLib_JacobiPolynomial.hxx
	py::class_<PLib_JacobiPolynomial, opencascade::handle<PLib_JacobiPolynomial>, PLib_Base> cls_PLib_JacobiPolynomial(mod, "PLib_JacobiPolynomial", "This class provides method to work with Jacobi Polynomials relativly to an order of constraint q = myWorkDegree-2*(myNivConstr+1) Jk(t) for k=0,q compose the Jacobi Polynomial base relativly to the weigth W(t) iorder is the integer value for the constraints: iorder = 0 <=> ConstraintOrder = GeomAbs_C0 iorder = 1 <=> ConstraintOrder = GeomAbs_C1 iorder = 2 <=> ConstraintOrder = GeomAbs_C2 P(t) = R(t) + W(t) * Q(t) Where W(t) = (1-t**2)**(2*iordre+2) the coefficients JacCoeff represents P(t) JacCoeff are stored as follow:");
	cls_PLib_JacobiPolynomial.def(py::init<const Standard_Integer, const GeomAbs_Shape>(), py::arg("WorkDegree"), py::arg("ConstraintOrder"));
	cls_PLib_JacobiPolynomial.def("Points", (void (PLib_JacobiPolynomial::*)(const Standard_Integer, TColStd_Array1OfReal &) const ) &PLib_JacobiPolynomial::Points, "returns the Jacobi Points for Gauss integration ie the positive values of the Legendre roots by increasing values NbGaussPoints is the number of points choosen for the integral computation. TabPoints (0,NbGaussPoints/2) TabPoints (0) is loaded only for the odd values of NbGaussPoints The possible values for NbGaussPoints are : 8, 10, 15, 20, 25, 30, 35, 40, 50, 61 NbGaussPoints must be greater than Degree", py::arg("NbGaussPoints"), py::arg("TabPoints"));
	cls_PLib_JacobiPolynomial.def("Weights", (void (PLib_JacobiPolynomial::*)(const Standard_Integer, TColStd_Array2OfReal &) const ) &PLib_JacobiPolynomial::Weights, "returns the Jacobi weigths for Gauss integration only for the positive values of the Legendre roots in the order they are given by the method Points NbGaussPoints is the number of points choosen for the integral computation. TabWeights (0,NbGaussPoints/2,0,Degree) TabWeights (0,.) are only loaded for the odd values of NbGaussPoints The possible values for NbGaussPoints are : 8 , 10 , 15 ,20 ,25 , 30, 35 , 40 , 50 , 61 NbGaussPoints must be greater than Degree", py::arg("NbGaussPoints"), py::arg("TabWeights"));
	cls_PLib_JacobiPolynomial.def("MaxValue", (void (PLib_JacobiPolynomial::*)(TColStd_Array1OfReal &) const ) &PLib_JacobiPolynomial::MaxValue, "this method loads for k=0,q the maximum value of abs ( W(t)*Jk(t) )for t bellonging to [-1,1] This values are loaded is the array TabMax(0,myWorkDegree-2*(myNivConst+1)) MaxValue ( me ; TabMaxPointer : in out Real );", py::arg("TabMax"));
	cls_PLib_JacobiPolynomial.def("MaxError", (Standard_Real (PLib_JacobiPolynomial::*)(const Standard_Integer, Standard_Real &, const Standard_Integer) const ) &PLib_JacobiPolynomial::MaxError, "This method computes the maximum error on the polynomial W(t) Q(t) obtained by missing the coefficients of JacCoeff from NewDegree +1 to Degree", py::arg("Dimension"), py::arg("JacCoeff"), py::arg("NewDegree"));
	cls_PLib_JacobiPolynomial.def("ReduceDegree", (void (PLib_JacobiPolynomial::*)(const Standard_Integer, const Standard_Integer, const Standard_Real, Standard_Real &, Standard_Integer &, Standard_Real &) const ) &PLib_JacobiPolynomial::ReduceDegree, "Compute NewDegree <= MaxDegree so that MaxError is lower than Tol. MaxError can be greater than Tol if it is not possible to find a NewDegree <= MaxDegree. In this case NewDegree = MaxDegree", py::arg("Dimension"), py::arg("MaxDegree"), py::arg("Tol"), py::arg("JacCoeff"), py::arg("NewDegree"), py::arg("MaxError"));
	cls_PLib_JacobiPolynomial.def("AverageError", (Standard_Real (PLib_JacobiPolynomial::*)(const Standard_Integer, Standard_Real &, const Standard_Integer) const ) &PLib_JacobiPolynomial::AverageError, "None", py::arg("Dimension"), py::arg("JacCoeff"), py::arg("NewDegree"));
	cls_PLib_JacobiPolynomial.def("ToCoefficients", (void (PLib_JacobiPolynomial::*)(const Standard_Integer, const Standard_Integer, const TColStd_Array1OfReal &, TColStd_Array1OfReal &) const ) &PLib_JacobiPolynomial::ToCoefficients, "Convert the polynomial P(t) = R(t) + W(t) Q(t) in the canonical base.", py::arg("Dimension"), py::arg("Degree"), py::arg("JacCoeff"), py::arg("Coefficients"));
	cls_PLib_JacobiPolynomial.def("D0", (void (PLib_JacobiPolynomial::*)(const Standard_Real, TColStd_Array1OfReal &)) &PLib_JacobiPolynomial::D0, "Compute the values of the basis functions in u", py::arg("U"), py::arg("BasisValue"));
	cls_PLib_JacobiPolynomial.def("D1", (void (PLib_JacobiPolynomial::*)(const Standard_Real, TColStd_Array1OfReal &, TColStd_Array1OfReal &)) &PLib_JacobiPolynomial::D1, "Compute the values and the derivatives values of the basis functions in u", py::arg("U"), py::arg("BasisValue"), py::arg("BasisD1"));
	cls_PLib_JacobiPolynomial.def("D2", (void (PLib_JacobiPolynomial::*)(const Standard_Real, TColStd_Array1OfReal &, TColStd_Array1OfReal &, TColStd_Array1OfReal &)) &PLib_JacobiPolynomial::D2, "Compute the values and the derivatives values of the basis functions in u", py::arg("U"), py::arg("BasisValue"), py::arg("BasisD1"), py::arg("BasisD2"));
	cls_PLib_JacobiPolynomial.def("D3", (void (PLib_JacobiPolynomial::*)(const Standard_Real, TColStd_Array1OfReal &, TColStd_Array1OfReal &, TColStd_Array1OfReal &, TColStd_Array1OfReal &)) &PLib_JacobiPolynomial::D3, "Compute the values and the derivatives values of the basis functions in u", py::arg("U"), py::arg("BasisValue"), py::arg("BasisD1"), py::arg("BasisD2"), py::arg("BasisD3"));
	cls_PLib_JacobiPolynomial.def("WorkDegree", (Standard_Integer (PLib_JacobiPolynomial::*)() const ) &PLib_JacobiPolynomial::WorkDegree, "returns WorkDegree");
	cls_PLib_JacobiPolynomial.def("NivConstr", (Standard_Integer (PLib_JacobiPolynomial::*)() const ) &PLib_JacobiPolynomial::NivConstr, "returns NivConstr");
	cls_PLib_JacobiPolynomial.def_static("get_type_name_", (const char * (*)()) &PLib_JacobiPolynomial::get_type_name, "None");
	cls_PLib_JacobiPolynomial.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &PLib_JacobiPolynomial::get_type_descriptor, "None");
	cls_PLib_JacobiPolynomial.def("DynamicType", (const opencascade::handle<Standard_Type> & (PLib_JacobiPolynomial::*)() const ) &PLib_JacobiPolynomial::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\PLib_HermitJacobi.hxx
	py::class_<PLib_HermitJacobi, opencascade::handle<PLib_HermitJacobi>, PLib_Base> cls_PLib_HermitJacobi(mod, "PLib_HermitJacobi", "This class provides method to work with Jacobi Polynomials relativly to an order of constraint q = myWorkDegree-2*(myNivConstr+1) Jk(t) for k=0,q compose the Jacobi Polynomial base relativly to the weigth W(t) iorder is the integer value for the constraints: iorder = 0 <=> ConstraintOrder = GeomAbs_C0 iorder = 1 <=> ConstraintOrder = GeomAbs_C1 iorder = 2 <=> ConstraintOrder = GeomAbs_C2 P(t) = H(t) + W(t) * Q(t) Where W(t) = (1-t**2)**(2*iordre+2) the coefficients JacCoeff represents P(t) JacCoeff are stored as follow:");
	cls_PLib_HermitJacobi.def(py::init<const Standard_Integer, const GeomAbs_Shape>(), py::arg("WorkDegree"), py::arg("ConstraintOrder"));
	cls_PLib_HermitJacobi.def("MaxError", (Standard_Real (PLib_HermitJacobi::*)(const Standard_Integer, Standard_Real &, const Standard_Integer) const ) &PLib_HermitJacobi::MaxError, "This method computes the maximum error on the polynomial W(t) Q(t) obtained by missing the coefficients of JacCoeff from NewDegree +1 to Degree", py::arg("Dimension"), py::arg("HermJacCoeff"), py::arg("NewDegree"));
	cls_PLib_HermitJacobi.def("ReduceDegree", (void (PLib_HermitJacobi::*)(const Standard_Integer, const Standard_Integer, const Standard_Real, Standard_Real &, Standard_Integer &, Standard_Real &) const ) &PLib_HermitJacobi::ReduceDegree, "Compute NewDegree <= MaxDegree so that MaxError is lower than Tol. MaxError can be greater than Tol if it is not possible to find a NewDegree <= MaxDegree. In this case NewDegree = MaxDegree", py::arg("Dimension"), py::arg("MaxDegree"), py::arg("Tol"), py::arg("HermJacCoeff"), py::arg("NewDegree"), py::arg("MaxError"));
	cls_PLib_HermitJacobi.def("AverageError", (Standard_Real (PLib_HermitJacobi::*)(const Standard_Integer, Standard_Real &, const Standard_Integer) const ) &PLib_HermitJacobi::AverageError, "None", py::arg("Dimension"), py::arg("HermJacCoeff"), py::arg("NewDegree"));
	cls_PLib_HermitJacobi.def("ToCoefficients", (void (PLib_HermitJacobi::*)(const Standard_Integer, const Standard_Integer, const TColStd_Array1OfReal &, TColStd_Array1OfReal &) const ) &PLib_HermitJacobi::ToCoefficients, "Convert the polynomial P(t) = H(t) + W(t) Q(t) in the canonical base.", py::arg("Dimension"), py::arg("Degree"), py::arg("HermJacCoeff"), py::arg("Coefficients"));
	cls_PLib_HermitJacobi.def("D0", (void (PLib_HermitJacobi::*)(const Standard_Real, TColStd_Array1OfReal &)) &PLib_HermitJacobi::D0, "Compute the values of the basis functions in u", py::arg("U"), py::arg("BasisValue"));
	cls_PLib_HermitJacobi.def("D1", (void (PLib_HermitJacobi::*)(const Standard_Real, TColStd_Array1OfReal &, TColStd_Array1OfReal &)) &PLib_HermitJacobi::D1, "Compute the values and the derivatives values of the basis functions in u", py::arg("U"), py::arg("BasisValue"), py::arg("BasisD1"));
	cls_PLib_HermitJacobi.def("D2", (void (PLib_HermitJacobi::*)(const Standard_Real, TColStd_Array1OfReal &, TColStd_Array1OfReal &, TColStd_Array1OfReal &)) &PLib_HermitJacobi::D2, "Compute the values and the derivatives values of the basis functions in u", py::arg("U"), py::arg("BasisValue"), py::arg("BasisD1"), py::arg("BasisD2"));
	cls_PLib_HermitJacobi.def("D3", (void (PLib_HermitJacobi::*)(const Standard_Real, TColStd_Array1OfReal &, TColStd_Array1OfReal &, TColStd_Array1OfReal &, TColStd_Array1OfReal &)) &PLib_HermitJacobi::D3, "Compute the values and the derivatives values of the basis functions in u", py::arg("U"), py::arg("BasisValue"), py::arg("BasisD1"), py::arg("BasisD2"), py::arg("BasisD3"));
	cls_PLib_HermitJacobi.def("WorkDegree", (Standard_Integer (PLib_HermitJacobi::*)() const ) &PLib_HermitJacobi::WorkDegree, "returns WorkDegree");
	cls_PLib_HermitJacobi.def("NivConstr", (Standard_Integer (PLib_HermitJacobi::*)() const ) &PLib_HermitJacobi::NivConstr, "returns NivConstr");
	cls_PLib_HermitJacobi.def_static("get_type_name_", (const char * (*)()) &PLib_HermitJacobi::get_type_name, "None");
	cls_PLib_HermitJacobi.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &PLib_HermitJacobi::get_type_descriptor, "None");
	cls_PLib_HermitJacobi.def("DynamicType", (const opencascade::handle<Standard_Type> & (PLib_HermitJacobi::*)() const ) &PLib_HermitJacobi::DynamicType, "None");

	// C:\Miniconda\envs\occt\Library\include\opencascade\PLib_DoubleJacobiPolynomial.hxx
	py::class_<PLib_DoubleJacobiPolynomial, std::unique_ptr<PLib_DoubleJacobiPolynomial, Deleter<PLib_DoubleJacobiPolynomial>>> cls_PLib_DoubleJacobiPolynomial(mod, "PLib_DoubleJacobiPolynomial", "None");
	cls_PLib_DoubleJacobiPolynomial.def(py::init<>());
	cls_PLib_DoubleJacobiPolynomial.def(py::init<const opencascade::handle<PLib_JacobiPolynomial> &, const opencascade::handle<PLib_JacobiPolynomial> &>(), py::arg("JacPolU"), py::arg("JacPolV"));
	cls_PLib_DoubleJacobiPolynomial.def("MaxErrorU", (Standard_Real (PLib_DoubleJacobiPolynomial::*)(const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const TColStd_Array1OfReal &) const ) &PLib_DoubleJacobiPolynomial::MaxErrorU, "None", py::arg("Dimension"), py::arg("DegreeU"), py::arg("DegreeV"), py::arg("dJacCoeff"), py::arg("JacCoeff"));
	cls_PLib_DoubleJacobiPolynomial.def("MaxErrorV", (Standard_Real (PLib_DoubleJacobiPolynomial::*)(const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const TColStd_Array1OfReal &) const ) &PLib_DoubleJacobiPolynomial::MaxErrorV, "None", py::arg("Dimension"), py::arg("DegreeU"), py::arg("DegreeV"), py::arg("dJacCoeff"), py::arg("JacCoeff"));
	cls_PLib_DoubleJacobiPolynomial.def("MaxError", (Standard_Real (PLib_DoubleJacobiPolynomial::*)(const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const TColStd_Array1OfReal &, const Standard_Real) const ) &PLib_DoubleJacobiPolynomial::MaxError, "None", py::arg("Dimension"), py::arg("MinDegreeU"), py::arg("MaxDegreeU"), py::arg("MinDegreeV"), py::arg("MaxDegreeV"), py::arg("dJacCoeff"), py::arg("JacCoeff"), py::arg("Error"));
	cls_PLib_DoubleJacobiPolynomial.def("ReduceDegree", (void (PLib_DoubleJacobiPolynomial::*)(const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const TColStd_Array1OfReal &, const Standard_Real, Standard_Real &, Standard_Integer &, Standard_Integer &) const ) &PLib_DoubleJacobiPolynomial::ReduceDegree, "None", py::arg("Dimension"), py::arg("MinDegreeU"), py::arg("MaxDegreeU"), py::arg("MinDegreeV"), py::arg("MaxDegreeV"), py::arg("dJacCoeff"), py::arg("JacCoeff"), py::arg("EpmsCut"), py::arg("MaxError"), py::arg("NewDegreeU"), py::arg("NewDegreeV"));
	cls_PLib_DoubleJacobiPolynomial.def("AverageError", (Standard_Real (PLib_DoubleJacobiPolynomial::*)(const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const TColStd_Array1OfReal &) const ) &PLib_DoubleJacobiPolynomial::AverageError, "None", py::arg("Dimension"), py::arg("DegreeU"), py::arg("DegreeV"), py::arg("dJacCoeff"), py::arg("JacCoeff"));
	cls_PLib_DoubleJacobiPolynomial.def("WDoubleJacobiToCoefficients", (void (PLib_DoubleJacobiPolynomial::*)(const Standard_Integer, const Standard_Integer, const Standard_Integer, const TColStd_Array1OfReal &, TColStd_Array1OfReal &) const ) &PLib_DoubleJacobiPolynomial::WDoubleJacobiToCoefficients, "None", py::arg("Dimension"), py::arg("DegreeU"), py::arg("DegreeV"), py::arg("JacCoeff"), py::arg("Coefficients"));
	cls_PLib_DoubleJacobiPolynomial.def("U", (opencascade::handle<PLib_JacobiPolynomial> (PLib_DoubleJacobiPolynomial::*)() const ) &PLib_DoubleJacobiPolynomial::U, "returns myJacPolU;");
	cls_PLib_DoubleJacobiPolynomial.def("V", (opencascade::handle<PLib_JacobiPolynomial> (PLib_DoubleJacobiPolynomial::*)() const ) &PLib_DoubleJacobiPolynomial::V, "returns myJacPolV;");
	cls_PLib_DoubleJacobiPolynomial.def("TabMaxU", (opencascade::handle<TColStd_HArray1OfReal> (PLib_DoubleJacobiPolynomial::*)() const ) &PLib_DoubleJacobiPolynomial::TabMaxU, "returns myTabMaxU;");
	cls_PLib_DoubleJacobiPolynomial.def("TabMaxV", (opencascade::handle<TColStd_HArray1OfReal> (PLib_DoubleJacobiPolynomial::*)() const ) &PLib_DoubleJacobiPolynomial::TabMaxV, "returns myTabMaxV;");

	// C:\Miniconda\envs\occt\Library\include\opencascade\PLib.hxx
	py::class_<PLib, std::unique_ptr<PLib, Deleter<PLib>>> cls_PLib(mod, "PLib", "PLib means Polynomial functions library. This pk provides basic computation functions for polynomial functions. Note: weight arrays can be passed by pointer for some functions so that NULL pointer is valid. That means no weights passed.");
	cls_PLib.def(py::init<>());
	cls_PLib.def_static("NoWeights_", (TColStd_Array1OfReal * (*)()) &PLib::NoWeights, "Used as argument for a non rational functions");
	cls_PLib.def_static("NoWeights2_", (TColStd_Array2OfReal * (*)()) &PLib::NoWeights2, "Used as argument for a non rational functions");
	cls_PLib.def_static("SetPoles_", (void (*)(const TColgp_Array1OfPnt &, TColStd_Array1OfReal &)) &PLib::SetPoles, "Copy in FP the coordinates of the poles.", py::arg("Poles"), py::arg("FP"));
	cls_PLib.def_static("SetPoles_", (void (*)(const TColgp_Array1OfPnt &, const TColStd_Array1OfReal &, TColStd_Array1OfReal &)) &PLib::SetPoles, "Copy in FP the coordinates of the poles.", py::arg("Poles"), py::arg("Weights"), py::arg("FP"));
	cls_PLib.def_static("GetPoles_", (void (*)(const TColStd_Array1OfReal &, TColgp_Array1OfPnt &)) &PLib::GetPoles, "Get from FP the coordinates of the poles.", py::arg("FP"), py::arg("Poles"));
	cls_PLib.def_static("GetPoles_", (void (*)(const TColStd_Array1OfReal &, TColgp_Array1OfPnt &, TColStd_Array1OfReal &)) &PLib::GetPoles, "Get from FP the coordinates of the poles.", py::arg("FP"), py::arg("Poles"), py::arg("Weights"));
	cls_PLib.def_static("SetPoles_", (void (*)(const TColgp_Array1OfPnt2d &, TColStd_Array1OfReal &)) &PLib::SetPoles, "Copy in FP the coordinates of the poles.", py::arg("Poles"), py::arg("FP"));
	cls_PLib.def_static("SetPoles_", (void (*)(const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal &, TColStd_Array1OfReal &)) &PLib::SetPoles, "Copy in FP the coordinates of the poles.", py::arg("Poles"), py::arg("Weights"), py::arg("FP"));
	cls_PLib.def_static("GetPoles_", (void (*)(const TColStd_Array1OfReal &, TColgp_Array1OfPnt2d &)) &PLib::GetPoles, "Get from FP the coordinates of the poles.", py::arg("FP"), py::arg("Poles"));
	cls_PLib.def_static("GetPoles_", (void (*)(const TColStd_Array1OfReal &, TColgp_Array1OfPnt2d &, TColStd_Array1OfReal &)) &PLib::GetPoles, "Get from FP the coordinates of the poles.", py::arg("FP"), py::arg("Poles"), py::arg("Weights"));
	cls_PLib.def_static("Bin_", (Standard_Real (*)(const Standard_Integer, const Standard_Integer)) &PLib::Bin, "Returns the Binomial Cnp. N should be <= BSplCLib::MaxDegree().", py::arg("N"), py::arg("P"));
	cls_PLib.def_static("RationalDerivative_", [](const Standard_Integer a0, const Standard_Integer a1, const Standard_Integer a2, Standard_Real & a3, Standard_Real & a4) -> void { return PLib::RationalDerivative(a0, a1, a2, a3, a4); }, py::arg("Degree"), py::arg("N"), py::arg("Dimension"), py::arg("Ders"), py::arg("RDers"));
	cls_PLib.def_static("RationalDerivative_", (void (*)(const Standard_Integer, const Standard_Integer, const Standard_Integer, Standard_Real &, Standard_Real &, const Standard_Boolean)) &PLib::RationalDerivative, "Computes the derivatives of a ratio at order <N> in dimension <Dimension>.", py::arg("Degree"), py::arg("N"), py::arg("Dimension"), py::arg("Ders"), py::arg("RDers"), py::arg("All"));
	cls_PLib.def_static("RationalDerivatives_", (void (*)(const Standard_Integer, const Standard_Integer, Standard_Real &, Standard_Real &, Standard_Real &)) &PLib::RationalDerivatives, "Computes DerivativesRequest derivatives of a ratio at of a BSpline function of degree <Degree> dimension <Dimension>.", py::arg("DerivativesRequest"), py::arg("Dimension"), py::arg("PolesDerivatives"), py::arg("WeightsDerivatives"), py::arg("RationalDerivates"));
	cls_PLib.def_static("EvalPolynomial_", (void (*)(const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Integer, Standard_Real &, Standard_Real &)) &PLib::EvalPolynomial, "Performs Horner method with synthethic division for derivatives parameter <U>, with <Degree> and <Dimension>. PolynomialCoeff are stored in the following fashion c0(1) c0(2) .... c0(Dimension) c1(1) c1(2) .... c1(Dimension)", py::arg("U"), py::arg("DerivativeOrder"), py::arg("Degree"), py::arg("Dimension"), py::arg("PolynomialCoeff"), py::arg("Results"));
	cls_PLib.def_static("NoDerivativeEvalPolynomial_", (void (*)(const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Integer, Standard_Real &, Standard_Real &)) &PLib::NoDerivativeEvalPolynomial, "Same as above with DerivativeOrder = 0;", py::arg("U"), py::arg("Degree"), py::arg("Dimension"), py::arg("DegreeDimension"), py::arg("PolynomialCoeff"), py::arg("Results"));
	cls_PLib.def_static("EvalPoly2Var_", (void (*)(const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, Standard_Real &, Standard_Real &)) &PLib::EvalPoly2Var, "Applies EvalPolynomial twice to evaluate the derivative of orders UDerivativeOrder in U, VDerivativeOrder in V at parameters U,V", py::arg("U"), py::arg("V"), py::arg("UDerivativeOrder"), py::arg("VDerivativeOrder"), py::arg("UDegree"), py::arg("VDegree"), py::arg("Dimension"), py::arg("PolynomialCoeff"), py::arg("Results"));
	cls_PLib.def_static("EvalLagrange_", (Standard_Integer (*)(const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Integer, Standard_Real &, Standard_Real &, Standard_Real &)) &PLib::EvalLagrange, "Performs the Lagrange Interpolation of given series of points with given parameters with the requested derivative order Results will store things in the following format with d = DerivativeOrder", py::arg("U"), py::arg("DerivativeOrder"), py::arg("Degree"), py::arg("Dimension"), py::arg("ValueArray"), py::arg("ParameterArray"), py::arg("Results"));
	cls_PLib.def_static("EvalCubicHermite_", (Standard_Integer (*)(const Standard_Real, const Standard_Integer, const Standard_Integer, Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &)) &PLib::EvalCubicHermite, "Performs the Cubic Hermite Interpolation of given series of points with given parameters with the requested derivative order. ValueArray stores the value at the first and last parameter. It has the following format : [0], [Dimension-1] : value at first param [Dimension], [Dimension + Dimension-1] : value at last param Derivative array stores the value of the derivatives at the first parameter and at the last parameter in the following format [0], [Dimension-1] : derivative at first param [Dimension], [Dimension + Dimension-1] : derivative at last param", py::arg("U"), py::arg("DerivativeOrder"), py::arg("Dimension"), py::arg("ValueArray"), py::arg("DerivativeArray"), py::arg("ParameterArray"), py::arg("Results"));
	cls_PLib.def_static("HermiteCoefficients_", (Standard_Boolean (*)(const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer, math_Matrix &)) &PLib::HermiteCoefficients, "This build the coefficient of Hermite's polynomes on [FirstParameter, LastParameter]", py::arg("FirstParameter"), py::arg("LastParameter"), py::arg("FirstOrder"), py::arg("LastOrder"), py::arg("MatrixCoefs"));
	cls_PLib.def_static("CoefficientsPoles_", (void (*)(const TColgp_Array1OfPnt &, const TColStd_Array1OfReal *, TColgp_Array1OfPnt &, TColStd_Array1OfReal *)) &PLib::CoefficientsPoles, "None", py::arg("Coefs"), py::arg("WCoefs"), py::arg("Poles"), py::arg("WPoles"));
	cls_PLib.def_static("CoefficientsPoles_", (void (*)(const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal *, TColgp_Array1OfPnt2d &, TColStd_Array1OfReal *)) &PLib::CoefficientsPoles, "None", py::arg("Coefs"), py::arg("WCoefs"), py::arg("Poles"), py::arg("WPoles"));
	cls_PLib.def_static("CoefficientsPoles_", (void (*)(const TColStd_Array1OfReal &, const TColStd_Array1OfReal *, TColStd_Array1OfReal &, TColStd_Array1OfReal *)) &PLib::CoefficientsPoles, "None", py::arg("Coefs"), py::arg("WCoefs"), py::arg("Poles"), py::arg("WPoles"));
	cls_PLib.def_static("CoefficientsPoles_", (void (*)(const Standard_Integer, const TColStd_Array1OfReal &, const TColStd_Array1OfReal *, TColStd_Array1OfReal &, TColStd_Array1OfReal *)) &PLib::CoefficientsPoles, "None", py::arg("dim"), py::arg("Coefs"), py::arg("WCoefs"), py::arg("Poles"), py::arg("WPoles"));
	cls_PLib.def_static("Trimming_", (void (*)(const Standard_Real, const Standard_Real, TColgp_Array1OfPnt &, TColStd_Array1OfReal *)) &PLib::Trimming, "None", py::arg("U1"), py::arg("U2"), py::arg("Coeffs"), py::arg("WCoeffs"));
	cls_PLib.def_static("Trimming_", (void (*)(const Standard_Real, const Standard_Real, TColgp_Array1OfPnt2d &, TColStd_Array1OfReal *)) &PLib::Trimming, "None", py::arg("U1"), py::arg("U2"), py::arg("Coeffs"), py::arg("WCoeffs"));
	cls_PLib.def_static("Trimming_", (void (*)(const Standard_Real, const Standard_Real, TColStd_Array1OfReal &, TColStd_Array1OfReal *)) &PLib::Trimming, "None", py::arg("U1"), py::arg("U2"), py::arg("Coeffs"), py::arg("WCoeffs"));
	cls_PLib.def_static("Trimming_", (void (*)(const Standard_Real, const Standard_Real, const Standard_Integer, TColStd_Array1OfReal &, TColStd_Array1OfReal *)) &PLib::Trimming, "None", py::arg("U1"), py::arg("U2"), py::arg("dim"), py::arg("Coeffs"), py::arg("WCoeffs"));
	cls_PLib.def_static("CoefficientsPoles_", (void (*)(const TColgp_Array2OfPnt &, const TColStd_Array2OfReal *, TColgp_Array2OfPnt &, TColStd_Array2OfReal *)) &PLib::CoefficientsPoles, "None", py::arg("Coefs"), py::arg("WCoefs"), py::arg("Poles"), py::arg("WPoles"));
	cls_PLib.def_static("UTrimming_", (void (*)(const Standard_Real, const Standard_Real, TColgp_Array2OfPnt &, TColStd_Array2OfReal *)) &PLib::UTrimming, "None", py::arg("U1"), py::arg("U2"), py::arg("Coeffs"), py::arg("WCoeffs"));
	cls_PLib.def_static("VTrimming_", (void (*)(const Standard_Real, const Standard_Real, TColgp_Array2OfPnt &, TColStd_Array2OfReal *)) &PLib::VTrimming, "None", py::arg("V1"), py::arg("V2"), py::arg("Coeffs"), py::arg("WCoeffs"));
	cls_PLib.def_static("HermiteInterpolate_", (Standard_Boolean (*)(const Standard_Integer, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer, const TColStd_Array2OfReal &, const TColStd_Array2OfReal &, TColStd_Array1OfReal &)) &PLib::HermiteInterpolate, "Compute the coefficients in the canonical base of the polynomial satisfying the given constraints at the given parameters The array FirstContr(i,j) i=1,Dimension j=0,FirstOrder contains the values of the constraint at parameter FirstParameter idem for LastConstr", py::arg("Dimension"), py::arg("FirstParameter"), py::arg("LastParameter"), py::arg("FirstOrder"), py::arg("LastOrder"), py::arg("FirstConstr"), py::arg("LastConstr"), py::arg("Coefficients"));
	cls_PLib.def_static("JacobiParameters_", (void (*)(const GeomAbs_Shape, const Standard_Integer, const Standard_Integer, Standard_Integer &, Standard_Integer &)) &PLib::JacobiParameters, "Compute the number of points used for integral computations (NbGaussPoints) and the degree of Jacobi Polynomial (WorkDegree). ConstraintOrder has to be GeomAbs_C0, GeomAbs_C1 or GeomAbs_C2 Code: Code d' init. des parametres de discretisation. = -5 = -4 = -3 = -2 = -1 = 1 calcul rapide avec precision moyenne. = 2 calcul rapide avec meilleure precision. = 3 calcul un peu plus lent avec bonne precision. = 4 calcul lent avec la meilleure precision possible.", py::arg("ConstraintOrder"), py::arg("MaxDegree"), py::arg("Code"), py::arg("NbGaussPoints"), py::arg("WorkDegree"));
	cls_PLib.def_static("NivConstr_", (Standard_Integer (*)(const GeomAbs_Shape)) &PLib::NivConstr, "translates from GeomAbs_Shape to Integer", py::arg("ConstraintOrder"));
	cls_PLib.def_static("ConstraintOrder_", (GeomAbs_Shape (*)(const Standard_Integer)) &PLib::ConstraintOrder, "translates from Integer to GeomAbs_Shape", py::arg("NivConstr"));
	cls_PLib.def_static("EvalLength_", (void (*)(const Standard_Integer, const Standard_Integer, Standard_Real &, const Standard_Real, const Standard_Real, Standard_Real &)) &PLib::EvalLength, "None", py::arg("Degree"), py::arg("Dimension"), py::arg("PolynomialCoeff"), py::arg("U1"), py::arg("U2"), py::arg("Length"));
	cls_PLib.def_static("EvalLength_", (void (*)(const Standard_Integer, const Standard_Integer, Standard_Real &, const Standard_Real, const Standard_Real, const Standard_Real, Standard_Real &, Standard_Real &)) &PLib::EvalLength, "None", py::arg("Degree"), py::arg("Dimension"), py::arg("PolynomialCoeff"), py::arg("U1"), py::arg("U2"), py::arg("Tol"), py::arg("Length"), py::arg("Error"));


}
